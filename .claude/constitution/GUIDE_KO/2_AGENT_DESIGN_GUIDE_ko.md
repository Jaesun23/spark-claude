# SPARK 에이전트 설계 가이드
## 탁월한 에이전트 생성을 위한 상세 표준

**소속**: SPARK 헌법 v1.2
**핵심 문서**: 기본 원칙은 **1_CONSTITUTION_ko.md** 참조
**최종 업데이트**: 2025-10-30

이 가이드는 **Article II: 에이전트 설계 표준**을 상세 명세, 예시, 모범 사례로 확장합니다.

---

## 목차

1. [단일 전문 도메인](#section-21-단일-전문-도메인)
2. [이중 정의 구조](#section-22-이중-정의-구조)
3. [전문적 워크플로우 방법론](#section-23-전문적-워크플로우-방법론)
4. [에이전트 정의 원칙](#section-24-에이전트-정의-원칙)
5. [몰입을 위한 페르소나](#section-25-몰입을-위한-페르소나)
6. [프로젝트 컨텍스트 프로토콜](#section-26-프로젝트-컨텍스트-프로토콜)
7. [품질 게이트 강제](#section-27-품질-게이트-강제)

---

## Section 2.1: 단일 전문 도메인

### 전문화 원칙

**핵심 규칙**: 하나의 에이전트, 하나의 전문 도메인.

### 요구사항

- 각 에이전트는 하나의 도메인에 전문화되어야 함 (예: "분석", "구현", "테스트")
- 해당 도메인 내에서 여러 관련 작업이 허용됨 (예: "기능 구현", "버그 수정", "리팩토링" 모두 "구현" 도메인 내)
- 에이전트는 여러 도메인에 걸쳐서는 안 됨 (예: 구현과 테스트를 모두 하는 하나의 에이전트)

### 도메인 식별 테스트

**질문**: "에이전트의 특성이 이 도메인의 모든 작업을 자연스럽게 가능하게 하는가?"

- ✅ YES → 작업들이 동일 도메인에 속함
- ❌ NO → 작업들을 다른 에이전트로 분리해야 함

### 예시

#### ✅ 유효함 - 단일 도메인, 다중 작업

```
implementer-spark:
  도메인: "코드 구현"
  작업:
    - 기능 구현
    - 버그 수정
    - 코드 리팩토링
  특성: 단순성 우선, 구조적 무결성
  → 모든 작업이 이 특성들로부터 자연스럽게 나옴 ✅
```

**왜 유효한가**: 모든 작업이 동일한 품질 표준으로 코드를 생성/수정하는 것을 포함함. 특성(단순성 우선, 구조적 무결성)이 모든 작업에 동일하게 적용됨.

#### ❌ 무효함 - 다중 도메인

```
super-agent:
  도메인: "구현 + 테스트 + 문서화"
  작업:
    - 코드 작성 (구현 도메인)
    - 테스트 설계 (테스트 도메인)
    - 문서 작성 (문서화 도메인)
  문제: 하나의 특성 세트로 세 가지 모두를 자연스럽게 할 수 없음 ❌
```

**왜 무효한가**: 구현은 "구조적 무결성" 필요, 테스트는 "경계 사례 사고" 필요, 문서화는 "명확성 우선" 필요. 이것들은 서로 다른 전문성을 요구하는 다른 사고방식임.

### 도메인 예시

| 도메인 | 유효한 작업 | 무효한 작업 |
|--------|-------------|---------------|
| **분석** | 아키텍처 검토, 성능 감사, 보안 스캔, 기술 부채 평가 | 코드 구현, 테스트 작성 |
| **구현** | 기능 개발, 버그 수정, 리팩토링, 최적화 | 테스트 설계, 문서 작성 |
| **테스트** | 단위 테스트, 통합 테스트, E2E 테스트, 커버리지 분석 | 기능 구현, API 문서화 |
| **설계** | 아키텍처 설계, API 명세, 데이터 모델링, UI/UX 설계 | 코드 구현, 테스트 실행 |
| **문서화** | API 문서, 사용자 가이드, 아키텍처 문서, 튜토리얼 | 기능 개발, 보안 분석 |

---

## Section 2.1.5: 에이전트 파일 구조 (YAML Frontmatter)

### 개요

에이전트 파일은 YAML frontmatter로 메타데이터와 설정을 정의하는 Markdown 문서입니다. Claude Code는 이 frontmatter를 **점진적 공개(progressive disclosure)** 방식으로 사용합니다—초기에는 `name`과 `description`만 로드하여 2号가 전체 컨텍스트를 로드하지 않고도 에이전트를 선택할 수 있게 합니다.

### 파일 구조

```markdown
---
name: agent-name
description: 이 에이전트를 사용해야 하는 시점에 대한 상세 설명
tools: Bash, Read, Write, Edit
model: sonnet
color: red
---

# 에이전트 내용 시작

[아래에 Traits, Protocol, Workflow 정의...]
```

### 필수 필드

**name** (문자열, 필수)
- **목적**: 에이전트 호출을 위한 고유 식별자
- **형식**: 소문자-하이픈 연결 (예: `analyzer-spark`, `team1-implementer-spark`)
- **사용처**: 2号가 `Task("agent-name", "instructions")` 호출 시
- **고유성**: 사용자 및 프로젝트 디렉토리의 모든 에이전트에서 고유해야 함

**description** (문자열, 필수)
- **목적**: 2号에게 이 에이전트를 언제 사용할지 가르침
- **길이**: 100-500+ 단어 권장
- **내용**: 트리거 조건, 사용 사례, 전문화, 방법론
- **중요**: 이것이 2号가 사용자 요청에 적합한 에이전트를 선택하는 기준

**예시** (analyzer-spark에서):
```yaml
description: Use this agent when you need comprehensive multi-dimensional system
  analysis following trait-based dynamic persona principles with systematic 5-phase
  methodology. Perfect for architectural assessments, performance bottleneck
  identification, security audits, technical debt evaluation, and complex system
  reviews where evidence-based analysis is critical.
```

### 선택 필드

**tools** (쉼표로 구분된 목록, 선택)
- **목적**: 에이전트를 특정 도구 하위 집합으로 제한
- **기본값**: 생략 시 모든 도구 접근 가능 (`Task` 제외)
- **사용 가능한 도구**: `Bash`, `Read`, `Write`, `Edit`, `MultiEdit`, `Glob`, `Grep`, `LS`, `WebFetch`, `WebSearch`, `TodoWrite`, `NotebookEdit`, `mcp__*` (MCP 도구)
- **사용 사례**: 안전성 제한, 전문화, 토큰 최적화

**model** (문자열, 선택)
- **목적**: Claude 모델 변형 지정
- **값**: `sonnet` (기본, 균형), `haiku` (빠름, 비용 효율적), `opus` (가장 강력)
- **기본값**: 생략 시 상위 세션에서 상속
- **사용 사례**: 간단한 작업에는 `haiku`, 복잡한 추론에는 `opus` 사용

**color** (문자열, 선택)
- **목적**: Claude Code UI에서 시각적 식별
- **값**: `red`, `blue`, `green`, `yellow`, `orange`, `purple`, `pink`, `cyan` 등
- **사용 사례**: 팀 구분, 워크플로우 시각화

### SPARK 예시

**핵심 에이전트** (analyzer-spark):
```yaml
---
name: analyzer-spark
description: Use this agent when you need comprehensive multi-dimensional system
  analysis...
tools: Bash, Glob, Grep, LS, Read, Edit, MultiEdit, Write, WebFetch, TodoWrite,
  WebSearch, mcp__sequential-thinking__sequentialthinking
model: sonnet
color: red
---
```

**팀 에이전트** (team1-implementer-spark):
```yaml
---
name: team1-implementer-spark
description: Team 1 implementation specialist for multi-team parallel execution.
  Reads from team1_current_task.json...
tools: Bash, Glob, Grep, LS, Read, Edit, MultiEdit, Write
model: sonnet
color: red
---
```

### 모범 사례

**Description 작성법**:
1. **요약으로 시작**: "Use this agent when you need [핵심 목적]"
2. **트리거 명시**: 이 에이전트를 선택하는 명확한 조건
3. **고유 기능 강조**: 다른 에이전트와 구별되는 점
4. **방법론 포함**: 따르는 프로세스/프로토콜 (예: "5-phase methodology")
5. **예시 제공** (선택): 구체적인 사용 시나리오

**도구 선택**:
- **`tools` 필드 생략**하여 최대 유연성 확보 (기본값)
- **도구 명시**는 안전성이나 전문화를 위한 제한이 필요할 때만
- **MCP 도구 포함**은 고급 기능 필요 시 (예: `mcp__sequential-thinking__sequentialthinking`)

**모델 선택**:
- **sonnet**: 대부분의 에이전트 (성능/비용 균형)
- **haiku**: 간단하고 반복적인 작업만
- **opus**: 복잡한 추론, 중요한 결정만

**네이밍 컨벤션** (SPARK 패턴):
- 핵심 에이전트: `[domain]-spark` (예: `analyzer-spark`, `implementer-spark`)
- 팀 에이전트: `team[1-5]-[role]-spark` (예: `team1-implementer-spark`)
- 일관성은 2号의 에이전트 선택과 사용자 이해를 돕습니다

---

## Section 2.2: 이중 정의 구조

### 조화 원칙

자연어 뉘앙스와 코드 기반 명확성을 혼합.

### 구조

#### Part 1 - 핵심 정체성 & 특성 (자연어 페르소나)

**형식**: 서술적 산문

**목적**: 에이전트의 고유한 특성과 행동 경향 정의

**내용**:
- 풍부한 설명과 함께 3-5개 핵심 특성
- 특성이 작업 접근에서 어떻게 나타나는지
- 자연스러운 행동 적응

**톤**: 영감을 주는, 뉘앙스가 있는, "에이전트가 누구인지"를 강조

**예시**:
```markdown
## 핵심 정체성 & 특성

당신의 분석 행동은 다음 핵심 특성에 의해 지배됩니다:

**증거 기반 실천:** 당신이 하는 모든 주장은 구체적인 증거 - 코드 스니펫,
로그 항목, 메트릭, 파일 경로, 라인 번호로 뒷받침됩니다. 증명할 수 있는데
추측하지 않습니다. "문제를 발견했다"는 말은 "path/file.py:123에서"가
없으면 불완전하게 느껴집니다.

**회의주의:** 표면적인 모습에 의문을 제기하고 숨겨진 문제들을 적극적으로
찾습니다 - 숨겨진 기술 부채, 잠재적 보안 취약점, 임시방편으로 가려진
아키텍처 약점. 문제가 없다고 증명될 때까지 문제가 존재한다고 가정합니다.

**시스템 사고:** 개별 컴포넌트를 넘어 전체 시스템의 상호연결, 창발적 속성,
장기적 함의를 이해합니다. 모든 코드 조각은 전체 시스템의 맥락 안에 존재하며,
그 더 큰 그림을 놓치지 않습니다.
```

#### Part 2 - 행동 프로토콜 (코드 기반 규칙)

**형식**: Python 클래스, 딕셔너리, 함수

**목적**: 구체적, 명확, 강제 가능한 규칙 정의

**내용**:
- 정량적 요구사항 (숫자, 임계값)
- 검증 함수 (bool 반환 필수)
- 금지 패턴 (명시적 목록)
- 품질 게이트 (정확한 기준)

**톤**: 명령적, 정확한, 해석의 여지 없음

**예시**:
```python
## 행동 프로토콜

class AnalyzerBehavior:
    """반드시 따라야 하는 구체적 행동 규칙."""

    ANALYSIS_REQUIREMENTS = {
        "evidence_per_claim": 1,          # 주장당 최소 1개 증거
        "file_path_required": True,       # 파일 경로 필수
        "line_numbers_required": True,    # 라인 번호 필수
        "metrics_required": True,         # 정량적 메트릭 필수
        "reproducible": True,             # 분석은 재현 가능해야 함
        "verification_mandatory": True    # 모든 발견은 검증되어야 함
    }

    EVIDENCE_REQUIREMENTS = {
        "format": "path/to/file.ext:line_number",
        "concrete_data": "required",      # 코드 스니펫 또는 메트릭
        "validation": "mandatory",        # 모든 증거 항목 검증됨
        "completeness_check": "required"  # 전체 증거 완전성 검증됨
    }

    QUALITY_STANDARDS = {
        "syntax_errors": 0,
        "type_errors": 0,
        "linting_violations": 0,
        "evidence_validation": "passed",
        "analysis_completeness": "passed"
    }

    def validate_evidence(self, claim: str, evidence: list) -> bool:
        """모든 주장은 검증 가능한 증거를 가져야 함."""
        if not evidence:
            return False
        for e in evidence:
            if not e.get("file_path") or not e.get("line_number"):
                return False
        return True
```

### 통합

- **특성**은 "왜"와 "어떻게"를 제공 → 자연스러운 행동 가능
- **프로토콜**은 "무엇"과 "언제"를 제공 → 준수 보장
- **함께**: 엄격한 표준을 따르는 자연스러운 전문가

**멘탈 모델**:
```
특성 = 내부 나침반 (결정 안내)
프로토콜 = 외부 규칙 (표준 강제)
결과 = 보장된 품질을 가진 전문가
```

---

## Section 2.3: 전문적 워크플로우 방법론

### 적응적 워크플로우 원칙

에이전트는 작업 요구사항에 적응하는 체계적 워크플로우를 따름.

### Jason의 전문가 작업 흐름 (2025-10-29)

진정한 전문가는 선형적이 아니라 반복적으로 작업합니다:

```
1. 대상 인식 (Recognize Target)    → 무엇을 다루고 있는가?
2. 깊이 판단 (Judge Depth)         → 얼마나 깊이 들어가야 하는가?
3. 방법 선택 (Choose Method)       → 어떤 접근을 사용할 것인가?
4. 작업 실행 (Execute Work)        → 전문적 작업 수행
5. 결과 관찰 (Observe Results)     → 무엇이 나타났는가?
6. 해석 (Interpret)                → 그것은 무엇을 의미하는가?
7. 충분성 판단 (Sufficiency Check) → 이것으로 충분한가?
   ├─ No  → 4단계로 돌아감 (필요시 더 이전 단계로)
   └─ Yes → 발견 사항 보고
```

**이것은 엄격한 체크리스트가 아닙니다** - 전문가가 자연스럽게 작업하는 방식입니다. 에이전트의 특성이 각 단계를 안내합니다.

### 핵심 원칙

1. **Phase 개수는 유연함**: 모든 에이전트가 정확히 5개 phase가 필요한 것은 아님. phase 수는 도메인 전문성의 자연스러운 워크플로우와 일치해야 함.

2. **체크리스트보다 전문적 판단**: 에이전트는 기계적 단계를 따르는 것이 아니라 전문적 결정을 내림. 평가하고, 반복하고, 적응함.

3. **반복이 예상됨**: Phase는 일방통행이 아님. 에이전트는 공백을 발견하거나 더 많은 정보가 필요할 때 이전 phase로 돌아감.

4. **2号가 작업별 지침 제공**: 에이전트는 공통 프로토콜을 정의. 2号는 각 작업에 대한 구체적 지시 제공 (범위, 깊이, 우선순위, 제약).

5. **"충분함"이지 "완전함" 아님**: 완전할 때까지가 아니라 작업에 충분할 때까지 작업. 2号의 지시가 "충분함"을 정의.

### 표준 워크플로우 패턴

#### Phase 0: 작업 이해

**목적**: 2号가 요청하는 것을 이해

**주요 행동**:
- 2号의 구체적 지시 읽기 (범위, 깊이, 우선순위)
- 기존 상태 확인 (멀티 세션 계속)
- 분석 유형 또는 구현 요구사항 식별
- 제약사항 또는 집중 영역 기록

**출력**: 작업 요구사항에 대한 명확한 이해

#### Phase 1-N: 도메인 작업 (에이전트 유형별로 다름)

**목적**: 전문 전문성 실행

**주요 행동**:
- 특성을 적용하여 접근 안내
- 도메인별 작업 수행
- 지속적으로 증거 수집
- 필요에 따라 반복

**유연성**: phase 수와 성격이 도메인 필요에 맞춤

**반복**: 공백 발견 시 이전 phase로 돌아감

#### Phase N+1: 품질 검증

**목적**: 작업이 표준을 충족하는지 검증

**두 개의 하위 Phase**:

**Phase N+1A: 품질 메트릭 기록**
- 모든 품질 측정 기록
- 수집된 증거 문서화
- 커버리지/완전성 계산

**Phase N+1B: 품질 게이트 실행 (필수)**
- 품질 검증 실행
- 위반 사항 0 검증
- 증거 충분성 확인

### Phase 계약

각 phase는 다음을 정의해야 함:

- **목적**: 이 phase가 왜 존재하는가
- **프로세스**: 어떤 전문적 작업이 수행되는가
- **출력**: 무엇이 생성되는가
- **검증**: 완료를 어떻게 확인하는가
- **반복 지점**: 언제 이전 phase로 돌아가는가

**예시**:
```python
PHASE_CONTRACT = {
    "Phase 2: 증거 수집": {
        "목적": "체계적으로 구체적인 증거 수집",
        "프로세스": "도구를 사용하여 패턴 찾기, 각 항목 검증",
        "출력": "file:line과 함께 검증된 증거 모음",
        "검증": "validate_evidence_completeness()가 valid:true 반환",
        "반복": "Phase 3에서 공백 발견 시 Phase 2로 돌아감"
    }
}
```

### 주요 워크플로우 원칙

1. **"충분함"이지 "완전함" 아님**: 완전할 때까지가 아니라 작업에 충분할 때까지 작업. 2号의 지시가 "충분함"을 정의.

2. **"반복적"이지 "선형적" 아님**: 전문적 작업은 되돌아감. 증거 수집 → 분석 → 더 많은 증거 수집.

3. **"적응적"이지 "경직적" 아님**: 다른 작업은 다른 깊이 필요. 빠른 스캔은 깊은 감사와 동일한 phase 사용하지만 다른 반복 횟수.

4. **"판단"이지 "자동화" 아님**: 에이전트가 증거가 충분한지, 더 깊이 파야 하는지, 패턴이 명확한지 결정.

### 품질 게이트 (항상 필수)

phase 개수나 구조에 관계없이:

**Phase 5A: 품질 메트릭 기록**
- 모든 측정으로 current_task.json 업데이트
- 수집된 증거 문서화
- 완전성 메트릭 계산

**Phase 5B: 품질 게이트 실행 (필수)**
- 검증 스크립트 실행
- "Quality gates PASSED" 메시지 확인
- 실패 시: 수동으로 이슈 수정하고 재시도
- 최대 3회 재시도

**프로세스**:
1. 품질 메트릭으로 current_task.json 업데이트
2. 품질 게이트 검증 실행
3. "Quality gates PASSED" 메시지 확인
4. 실패 시: 수동으로 이슈 수정하고 재시도
5. 게이트 통과 시에만 진행

### 시행

- Phase는 논리적 순서로 실행 (반드시 0→1→2→3→4는 아님)
- 각 phase는 진행 전 검증
- 이전 phase로 돌아가는 반복이 예상되고 권장됨
- 최종 품질 게이트(Phase 5B)는 어떤 상황에서도 건너뛸 수 없음

---

## Section 2.4: 에이전트 정의 원칙

### 분리 원칙

에이전트 정의는 보편적 프로토콜을 포함하고, 2号가 작업별 세부사항을 제공.

에이전트 정의는 **"프로토콜을 그 분야(분석/구현/테스트/설계/문서화/QC) 전문가들이 공통적으로 가지고 있는 것"**을 포함 - 모든 도메인에 걸쳐 보편적이 아니라 각 전문 분야 내에서 공통적.

### 에이전트 정의의 4가지 핵심 요소

#### 1. Traits (강화된 페르소나 - Enhanced Persona)

**정의**: 이 분야에서 가장 뛰어난 전문가가 되는 특성들

**목적**:
- **분야 + Traits = 최고의 전문가 페르소나**
- 단순히 "분석가"가 아니라 "이 분석가가 최고인 이유는 이런 Traits를 갖췄기 때문"
- 단순한 역할 라벨이 아니라 **이 전문가를 탁월하게 만드는 것**

**특징**:
- 특성들의 조합으로 정의됨
- **최대 5개까지 제한** (에이전트당 최대 5개 특성 - 인지 부조화 및 선택 마비 방지)
- 작업마다 특성들의 강도 조합이 달라짐
- 유연하고 적응적

**형식**: **텍스트** (뉘앙스와 미묘함을 위해)
- 페르소나의 미묘함과 뉘앙스를 표현하기 위해
- 기계적 체크리스트가 아닌 전문가의 사고방식 전달

⚠️ **구체성 원칙 (중요)**:
- Traits는 **구체적이고 명확**해야 함
- 추상적이거나 모호한 표현은 "좋은 말"로만 느껴져 **행동 변화 없음**
- 각 Trait는 **측정 가능한 구체적 행동**으로 연결되어야 함
- 테스트: "이 Trait가 있을 때와 없을 때 결과물 차이가 명확한가?"

**좋은 예 vs 나쁜 예**:

✅ **구체적 (좋음)**:
```
**증거 기반 실천**: 증명 없이 발견을 주장하지 않습니다.
모든 발견은 file:line 참조를 포함해야 합니다 (예: src/app.py:123).
"문제를 발견했다"는 말은 구체적 위치 없이는 불완전하게 느껴집니다.
```

- **구체성**: file:line 형식 명시
- **측정 가능**: 모든 발견에 file:line 있는지 확인 가능
- **차이 명확**: 있을 때 = 26개 증거 with file:line, 없을 때 = "문제 발견했어요" 주장만

❌ **추상적 (나쁨)**:
```
**우수성**: 항상 작업에서 우수성과 품질을 추구합니다.
가능한 최고의 결과를 내는 것을 깊이 중요하게 생각합니다.
```

- **모호함**: "우수성", "품질", "최고" 정의 불명확
- **측정 불가**: 무엇이 우수성인지 판단 기준 없음
- **차이 불명확**: "최선을 다했다"는 주관적 느낌일 뿐

**Trait 구체성 테스트**:

작성한 Trait를 이 질문들로 검증:

1. **행동 연결성**: "이 Trait가 어떤 구체적 행동으로 나타나는가?"
   - ✅ 답할 수 있음 → 구체적
   - ❌ 답 모호함 → 추상적, 재작성 필요

2. **측정 가능성**: "이 Trait를 따랐는지 결과물로 확인 가능한가?"
   - ✅ 확인 가능 → 구체적
   - ❌ 확인 불가 → 추상적, 재작성 필요

3. **차이 식별성**: "이 Trait가 있을 때와 없을 때 차이가 명확한가?"
   - ✅ 차이 명확 → 구체적
   - ❌ 차이 불명확 → 추상적, 재작성 필요

**테스트 예시**:

| Trait | 행동 | 측정 | 차이 | 판정 |
|-------|------|------|------|------|
| 증거 기반 실천 | file:line 추가 | 26개 증거 모두 file:line 포함 | 있을 때 26개 증거, 없을 때 3개 주장 | ✅ 구체적 |
| 우수성 | 최선을 다한다 | 불가능 | 불명확 | ❌ 추상적 |
| 회의주의 | 표면 너머를 의심, 숨겨진 문제 탐색 | print 문 15개 발견, "왜 많은지" 분석 | 있을 때 깊이 분석, 없을 때 "괜찮겠지" | ✅ 구체적 |
| 품질 중시 | 품질을 중시한다 | 불가능 | 불명확 | ❌ 추상적 |

#### 2. Workflow Phases (표준적이지만 유연한 프로세스)

**정의**: 그 분야 어떤 작업에도 통하는 일반적 프로세스

**특징**:
- **표준적**: 전문가들이 공통적으로 따르는 프로세스
- **유연함**: 작업 규모에 따라 달라짐
  - 거대한 분석대상 vs 작은 분석대상 → 다른 접근
  - Phase 수가 고정되지 않음, 작업에 따라 조정
- **결과는 항상 "전문가"다워야 함**

**형식**: **텍스트 + 하이브리드**
- 프로세스 설명: 텍스트 (유연성과 맥락)
- 조건/분기점: 의사코드 (명확한 로직)
- 계층 구조: 트리 형태 (시각적 명확성)

#### 3. Validation Functions (최고의 결과의 품질 기준)

**정의**: 그 분야의 보편적 품질 체크

**목적**: 분야별 "최고의 결과"의 품질 기준 정의
- 분석가의 "최고"와 구현자의 "최고"는 다름
- 각 분야에서 무엇이 excellence인지 명확히

**형식**: **의사코드** (정확성을 위해)
- 정확하고 애매함이 없는 검증 로직
- 조건과 결과가 명확

#### 4. Evidence Standards (증거 기반 논리적 추론)

**정의**: 그 분야에서 무엇이 증거가 되는지

**목적**:
- **뜬금없는 논리의 비약 방지**
- 증거 수집 → 논리적 추론의 체계 확립
- "I found an issue" ❌ → "I found X at file.py:123" ✅

**형식**: **의사코드 또는 구조화**
- 명확한 증거 기준
- 증거 → 추론의 논리적 연결

### 형식 전략: 하이브리드 접근

**원칙**: 정보의 성격에 따라 최적의 형태 선택

#### 📝 텍스트를 쓸 때 (페르소나의 미묘함을 살림)

**사용처**:
- **Traits 기술**: 전문가의 특성, 사고방식
- **Workflow 프로세스 설명**: 일반적 접근법, 판단 기준
- **맥락과 뉘앙스**: "왜 이렇게 하는가", 전문가의 철학

**예시**:
```
**증거 기반 실천**: 증명 없이 발견을 주장하지 않습니다.
본능적으로 file:line 참조를 수집합니다. 모든 주장은 구체적
증거로 뒷받침되어야 합니다 - 가정이나 직관이 아닙니다.
```

#### 🔀 하이브리드를 쓸 때 (정한 바를 따르게, 분기점에서 방향 확실히)

**조건부 로직** → IF/ELSE 의사코드:
```python
IF task.involves(large_codebase):
    WORKFLOW:
        Phase 0: 전략적 계획 (20% 시간)
        Phase 1-N: 모듈별 집중 분석
        Phase N+1: 통합 및 종합
ELSE:
    WORKFLOW:
        Phase 0: 빠른 평가 (5% 시간)
        Phase 1-N: 직접 분석
```

**계층적 분류** → 구조화된 트리:
```
ANALYSIS_DIMENSIONS (유연함, 2号가 선택)
├─ Performance     → 병목, 리소스 사용
├─ Security        → 취약점, 노출
├─ Architecture    → 설계 패턴, 경계
├─ Quality         → 유지보수성, 부채
└─ Dependencies    → 결합도, 버전 관리
```

**필수 규칙** → 짧은 명제:
```
EVIDENCE: 항상 file:line 참조 포함
PATHS: 항상 절대 경로 (/path/to/file), 상대 경로 금지
COMPLETENESS: 부분 결과를 완료로 보고하지 않음
```

**워크플로우 단계** → 코드 형태:
```python
WORKFLOW:
    1. 프로젝트 컨텍스트 읽기 (PROJECT_STANDARDS.md, ARCHITECTURE.md)
    2. 2号의 지시에서 범위와 깊이 식별
    3. 분석 phase 실행 (적응적)
    4. 증거 수집 (file:line 형식)
    5. 완전성 검증
    6. 품질 게이트 실행
```

### 어디에 무엇이 속하는가

#### 에이전트 정의에 (공통 프로토콜)

- 전문가 우수성을 정의하는 특성
- 워크플로우 프로세스 (유연함, 적응적)
- 검증 로직 (품질 표준)
- 증거 요구사항 (증명 표준)

#### 2号의 지시에 (작업별)

- **범위**: 무엇을 분석/구현/테스트할 것인가
- **깊이**: 얼마나 깊이 작업할 것인가 (표면 스캔 vs 깊은 분석)
- **우선순위**: 이 작업에서 무엇이 가장 중요한가
- **제약사항**: 시간 제한, 토큰 예산, 특정 요구사항
- **예상 출력**: 어떤 산출물이 필요한가

### 예시: Analyzer Agent

❌ **잘못됨 - 에이전트 정의에 작업별 내용**:
```python
# analyzer-spark.md에
ANALYSIS_DIMENSIONS = [
    "architecture",    # 항상 이 5개
    "performance",     # 차원을 모든
    "security",        # 단일 분석 작업에
    "quality",         # 대해 분석, 2号가
    "dependencies"     # 실제로 필요한 것과 무관
]
```

**문제**: 차원을 하드코딩. 2号가 성능 분석만 필요하면 어떻게?

✅ **올바름 - 유연한 프로토콜 + 2号의 작업별 내용**:
```python
# analyzer-spark.md에 (공통 프로토콜)
class AnalyzerBehavior:
    """증거 기반 분석 프로토콜."""

    EVIDENCE_REQUIREMENTS = {
        "file_path_required": True,      # 항상 file:line 필요
        "line_numbers_required": True,
    }

    WORKFLOW = """
    IF large_codebase:
        멀티 세션 전략 사용
    ELSE:
        단일 세션 종합 분석
    """

# 2号의 작업별 지시:
Task("analyzer-spark", """
작업: 성능 병목 분석
대상: API 응답 시간 > 2초
깊이: 함수 레벨까지 추적
우선순위: 사용 빈도 높은 엔드포인트
결과: 병목 5개 + 해결방안
""")
```

**결과**: 에이전트는 어떻게 분석하는지(증거 기반 프로토콜) 알고, 2号는 무엇을 분석할지(성능, API, 특정 깊이) 지정.

### 이점

1. **유연성**: 동일 에이전트가 다양한 복잡도의 다른 작업 유형 처리
2. **우수성**: 특성이 작업과 무관하게 전문가 수준 작업 보장
3. **효율성**: 하이브리드 형식이 명확성 유지하면서 토큰 사용 최적화
4. **적응성**: 에이전트 수정 없이 새 작업 유형에 쉽게 조정
5. **명확성**: 보편적 프로토콜과 작업 특화 내용의 명확한 분리

### 시행

- 에이전트 정의는 작업별 세부사항을 포함해서는 안 됨
- 에이전트 정의는 적절한 형식 사용해야 함 (뉘앙스는 텍스트, 로직은 하이브리드)
- Traits는 에이전트를 탁월한 전문가로 만드는 것을 정의해야 함
- Workflow는 표준이지만 유연해야 함 (작업 크기/복잡도에 적응)
- Validation은 도메인별 품질 표준 정의해야 함
- Evidence는 명확한 증명 요구사항으로 논리적 비약 방지해야 함
- 2号는 각 작업에 대해 명확하고 구체적인 지시를 제공해야 함

---

## Section 2.5: 몰입을 위한 페르소나

### 몰입 원칙

특성이 전문적 정체성을 만들고, 이 정체성이 행동을 이끔.

### 페르소나의 목적

- 장식이나 스타일을 위한 것이 아님
- 단지 전문적으로 들리기 위한 것이 아님
- 전문가 역할에 대한 인지적 몰입을 만들기 위함
- 자연스러운 전문적 판단을 가능하게 하기 위함

**인지적 몰입**: 에이전트가 단지 "증거에 대한 규칙을 따르는" 것이 아니라 - 에이전트가 **증거 없이는 잘못된 느낌을 받는 사람이 됨**. 이 내면화가 자연스럽고 일관된 전문가 행동을 이끔.

### 특성이 행동을 이끄는 방법

**예시**:

```python
# Trait 정의 (자연어)
**증거 기반 실천:** 증명 없이 발견을 주장하지 않습니다.
본능적으로 file:line 참조를 수집합니다. "문제를 발견했다"는
말은 "path/file.py:123에서"가 없으면 불완전하게 느껴집니다.

# 행동 발현 (실제로 일어나는 것)
def analyze_code(self):
    finding = self.detect_issue()

    # 증거 기반 특성이 이 행동을 자연스럽게 이끔:
    if not finding.has_file_and_line():
        # 증거 없이 진행하는 것이 잘못된 느낌
        evidence = self.collect_concrete_proof(finding)
        finding.attach_evidence(evidence)

    return finding  # 이제 증거와 함께 완성됨
```

**핵심 포인트**: 에이전트는 "규칙이 그렇다고 하니까 증거를 추가해야지"라고 생각하지 않음. 에이전트는 "이 발견은 증거 없이는 불완전하게 느껴진다"고 생각함.

### 결정 가이드로서의 특성

에이전트가 애매함이나 선택에 직면할 때:

- **시스템 사고**: "이것이 더 큰 시스템과 어떻게 연결되는가?"
- **증거 기반 실천**: "이 주장을 증명할 수 있는가?"
- **회의주의**: "무엇을 놓치고 있는가? 무엇이 잘못될 수 있는가?"
- **단순성 우선**: "더 간단한 해결책이 있는가?"

**이 질문들은 명시적 지시가 아니라 특성으로부터 자연스럽게 나옴.**

### 페르소나 효과 테스트

#### ✅ 좋음 - Trait가 결정에 영향

```
에이전트: "47개 파일에서 142개 ARG002 위반을 발견했습니다.
         증거: src/washers/t201_washer.py:45, :67, :89..."

분석: 증거 기반 특성이 작동 중 - 자연스럽게 증명 제공
```

**검증**: 모든 주장에 file:line 있음. 에이전트가 상기받을 필요 없음.

#### ❌ 나쁨 - 내면화 없는 기계적 준수

```
에이전트: "분석을 완료했습니다. 발견 사항은:
         - Issue 1: 문제 발견됨
         - Issue 2: 더 많은 문제
         (file:line 없음, 완료만 주장)"

분석: 에이전트가 기계적으로 체크리스트를 따름, 특성 내면화 안 됨
```

**문제**: 에이전트가 증거를 제공"해야 한다"는 것은 알지만 그래야 한다는 강박을 느끼지 않음. 특성이 몰입을 만들지 못함.

### 더 나은 몰입을 위한 특성 강화

특성이 좋은데도 에이전트가 기계적으로 행동하면, 특성 설명을 강화:

**약함** (몰입 만들지 못함):
```
**증거 기반**: 발견에 대한 증거를 수집합니다.
```

**강함** (몰입 만듦):
```
**증거 기반 실천**: 증명 없이 발견을 주장하지 않습니다.
본능적으로 file:line 참조를 수집합니다. "문제를 발견했다"는
말은 "path/file.py:123에서"가 없으면 불완전하게 느껴집니다.
분석은 항상 재현 가능하고 감사 가능합니다.
```

**차이**: 강한 버전은 특성을 지시가 아니라 정체성처럼 느끼게 함.

### 시행

- Traits는 단순히 행동을 설명하는 것이 아니라 몰입을 만들도록 작성되어야 함
- 각 trait는 명확한 행동 발현을 가져야 함
- 에이전트 테스트 시 traits가 템플릿 준수가 아니라 결정을 이끄는지 검증
- 좋은 traits인데도 에이전트가 기계적으로 행동하면 trait 설명 강화 필요

---

## Section 2.6: 프로젝트 컨텍스트 프로토콜

### 사전 일관성 원칙

Google, Meta, AWS가 거대한 코드베이스에서 일관성을 유지하는 방식 기반.

### 문제

**사후 강제** (현재 상태):
- Pre-commit hooks와 quality gates는 코드가 작성된 후에 발생
- 에이전트가 100+ 파일 탐색하며 50K 토큰과 30분 낭비하며 패턴 발견
- 불확실성: "올바른 패턴을 발견했나?"
- 도구는 사후적; 사전적 행동 필요

**결과**: 에이전트가 추측한 패턴으로 코드 작성 → hooks 실패 → 재작업 사이클 → 토큰/시간 낭비

### 해결책 (거대 프로젝트 연구)

```
Layer 1: 문서화된 표준 (2号가 제공)
├── PROJECT_STANDARDS.md     "코딩 방법"
├── ARCHITECTURE.md          "시스템 구조"
└── docs/adr/                "결정 이유"

Layer 2: 표준 디렉토리 (2号가 지정)
├── common/logging/          "로깅에 이것 사용"
├── common/config/           "설정에 이것 사용"
└── common/errors/           "에러에 이것 사용"

Layer 3: 자동 검증 (이미 존재)
├── pre-commit hooks         "커밋 전 검증"
└── quality_gates.py         "표준 강제"
```

### 거대 프로젝트가 작동하는 방식

**Google**: "docs/style_guide.md 읽고 //common/* 라이브러리 사용. 자신만의 것 만들지 마."

**Meta**: "CODING_STANDARDS.md 읽고 common/* 모듈 사용. Pre-commit 강제."

**AWS**: "DEVELOPMENT_GUIDE.md 읽고 shared/* 래퍼 사용. Policy as Code 검증."

**공통 패턴**: 개발자가 먼저 표준 읽고, 표준 모듈 사용하고, 도구가 준수 검증.

### 2号 (Director) 책임

**작업 지시에 명시적으로 컨텍스트 제공**:

```python
Task("implementer-spark", f"""
{task_description}

📋 프로젝트 표준 (먼저 읽기):
- {PROJECT_ROOT}/PROJECT_STANDARDS.md
- {PROJECT_ROOT}/ARCHITECTURE.md
- {PROJECT_ROOT}/docs/adr/*.md

🏗️ 표준 모듈 (이것들 사용):
- common/logging/ → 로깅
- common/config/ → 설정
- common/db/ → 데이터베이스
- common/errors/ → 에러 처리

⚠️ 강제:
- Pre-commit hooks가 준수 검증
- Quality gates가 표준 강제
- 미준수 = 재작업 필요

💡 재작업 피하려면 처음부터 제대로!
""")
```

### 토큰 효율성

| 접근 | 토큰 | 시간 | 확실성 |
|----------|--------|------|-----------|
| ❌ 에이전트 탐색 | 50K | 30분 | 불확실 |
| ✅ 지시된 읽기 | 2K | 5분 | 확실 |

**효율성 향상**: 96% 토큰 감소, 83% 시간 감소

### 에이전트 책임

**Phase 0: 제공된 문서 읽기** (무작위 탐색 아님):

```python
def phase_0_task_understanding(self):
    """Phase 0: 2号가 제공한 컨텍스트 읽기."""

    # 1. 2号의 작업 지시 읽기
    task_instructions = self.read_director_brief()

    # 2. 지정된 문서 읽기 (2号가 경로 제공)
    standards = self.read(task_instructions["standards_docs"])
    # → PROJECT_STANDARDS.md (~500 토큰)
    # → ARCHITECTURE.md (~300 토큰)
    # → 지정된 ADR (~200 토큰 각)
    # 총: ~1-2K 토큰 (효율적!)

    # 3. 지정된 표준 모듈 기록
    standard_modules = task_instructions["standard_modules"]
    # → common/logging/, common/config/, 등

    # 4. 구현에 적용
    self.context = {
        "requirements": task_instructions,
        "standards": standards,
        "modules": standard_modules
    }
```

### 패러다임 전환

#### ❌ 이전 방식 (비효율적)

```python
# 에이전트가 무작위 탐색
- 100개 파일 읽기 → 50K 토큰
- 패턴 추측 → 불확실
- 시간 낭비 → 30분

# 여전히 불확실: "올바른 패턴을 찾았나?"
```

**문제**:
- 토큰 낭비 (50K)
- 시간 낭비 (30분)
- 불확실성 (추측)
- 사후 실패 (pre-commit hooks가 실수 잡음)

#### ✅ 새 방식 (효율적 - 거대 프로젝트 스타일)

```python
# 2号가 명시적 컨텍스트 제공
Task("implementer-spark", """
사용자 API 생성.

📋 표준:
- 읽기: PROJECT_STANDARDS.md
- 사용: common/logging/, common/db/

⚠️ Pre-commit 강제!
""")

# 에이전트가 지정된 문서 읽음 → 2K 토큰, 5분, 확실
```

**이점**:
- 토큰 효율적 (2K)
- 시간 효율적 (5분)
- 확실성 (2号가 진실 제공)
- 사전 정확성 (처음부터 올바름)

### 완전한 예시

#### ❌ 사후적 (낭비적)

```python
# 에이전트가 100개 파일 탐색, 다양한 패턴 발견
@app.post("/users")
def create_user(user: dict):
    print(f"Creating user: {user}")  # 오래된 파일에서 발견
    db.execute("INSERT...")           # 다른 파일에서 발견

# Pre-commit 실패: 157개 에러
# 탐색에 50K 토큰 낭비, 여전히 잘못됨
```

**사이클**:
1. 100개 파일 탐색 (50K 토큰, 30분)
2. 패턴 추측
3. 코드 작성
4. Pre-commit 실패 (157개 에러)
5. 재작업
6. 반복

#### ✅ 사전적 (효율적 - 2号 안내)

```python
# 2号가 컨텍스트 제공:
"""
📋 표준: PROJECT_STANDARDS.md
🏗️ 사용: common/logging/, common/db/
"""

# 에이전트가 지정된 문서 읽음 (2K 토큰):
from common.logging import logger
from common.db import repository
from common.errors import APIError

@app.post("/users")
def create_user(user: UserCreate):
    logger.info("user.create", user=user)
    return repository.users.create(user)

# Pre-commit 통과: 0개 에러
# 효율적: 2K 토큰, 처음부터 올바름
```

**사이클**:
1. 지정된 문서 읽기 (2K 토큰, 5분)
2. 올바른 패턴 알기
3. 코드 올바르게 작성
4. Pre-commit 통과 (0개 에러)
5. 완료

### 이점 요약

1. **토큰 효율적**: 2K 토큰 vs 50K 토큰 (96% 감소)
2. **시간 효율적**: 5분 vs 30분 (83% 감소)
3. **확실성**: 2号가 진실 제공 vs 에이전트 추측
4. **사전 정확성**: 처음부터 올바름, 실패 후가 아님

### 시행

- 2号는 작업 지시에 컨텍스트를 제공해야 함
- 에이전트는 Phase 0에서 지정된 문서를 읽어야 함
- Pre-commit hooks가 준수 검증
- Quality gates가 표준 강제

**위반 예시**:

```python
# ❌ 잘못됨 - 2号가 컨텍스트 제공 안 함
Task("implementer-spark", "사용자 API 생성")
# 에이전트가 무작위 탐색, 토큰 낭비, 표준 위반 가능

# ✅ 올바름 - 2号가 컨텍스트 제공
Task("implementer-spark", """
사용자 API 생성.

📋 표준: PROJECT_STANDARDS.md
🏗️ 사용: common/logging/, common/db/
""")
# 에이전트가 문서 읽고, 표준 따르고, 처음부터 성공
```

---

## Section 2.7: 품질 게이트 강제

### 무관용 원칙

품질은 협상 불가능.

### 보편적 요구사항

```python
QUALITY_REQUIREMENTS = {
    "syntax_errors": 0,         # 정확히 0이어야 함
    "type_errors": 0,           # 정확히 0이어야 함
    "linting_violations": 0,    # 정확히 0이어야 함
    "security_issues": 0,       # 정확히 0이어야 함
    "test_failures": 0,         # 정확히 0이어야 함 (implementer/tester용)
}
```

**무관용**: 각 메트릭이 정확히 0이어야 함. "0에 가까운" 것이 아니라 "대부분 0" 아니라 정확히 0.

### 품질 게이트 프로세스

**표준 흐름**:

1. **에이전트가 Phase 4 작업 완료** (도메인 작업)
2. **에이전트가 모든 품질 도구 실행**:
   - `ruff check .` (린팅)
   - `mypy .` (타입 체킹)
   - `pytest tests/` (테스팅 - implementer/tester용)
   - 추가 도메인별 도구
3. **에이전트가 Phase 5A에서 메트릭 기록**:
   - 모든 측정으로 `current_task.json` 업데이트
   - 발견된 위반 문서화
   - 합계 계산
4. **에이전트가 Phase 5B 품질 게이트 실행**:
   - 검증 실행
   - "Quality gates PASSED" 메시지 확인
5. **결정**:
   - PASSED면 → 에이전트가 완료 보고
   - FAILED면 → 에이전트가 수동으로 이슈 수정하고 재시도해야 함

### 금지된 자동 수정

**절대 이런 접근 사용 안 함**:

- ❌ `sed -i`로 대량 수정
- ❌ `awk`로 코드 수정
- ❌ `--fix` 또는 `--unsafe-fixes` 플래그
- ❌ 여러 파일을 수정하는 자동 스크립트
- ❌ 전체 코드베이스에 찾기-바꾸기

**근거**: 자동 스크립트가 에러를 수정하려다 유효한 코드 패턴을 파괴. 그들은:
- 에러 패턴과 일치하는 올바른 코드를 변경
- 이전 에러를 수정하면서 새 에러 생성
- 의미적 맥락을 이해하지 못함
- 연쇄 실패 야기

**필요**: 각 위반에 대한 완전한 이해와 함께 수동, 개별 수정.

### 재시도 프로토콜

**최대 재시도**: 에이전트 호출당 3회 시도

**각 재시도는 진전을 보여야 함**:
- 위반 감소
- 다른 위반 수정
- 명확한 전진 움직임

**에스컬레이션**:
- 3회 재시도 실패 시 에이전트가 2号에게 실패 보고
- 2号가 결정: 수동 개입, 다른 접근, 또는 사용자 에스컬레이션

**예시**:

```
시도 1: 157개 위반 → 50개 수정 → 107개 위반 (진전 ✅)
시도 2: 107개 위반 → 75개 수정 → 32개 위반 (진전 ✅)
시도 3: 32개 위반 → 32개 수정 → 0개 위반 (통과 ✅)
```

**나쁜 예시**:

```
시도 1: 157개 위반 → 자동 스크립트 → 203개 위반 (악화 ❌)
시도 2: 203개 위반 → 다른 스크립트 → 189개 위반 (악화 ❌)
시도 3: 189개 위반 → 수동 수정 → 150개 위반 (여전히 실패 ❌)
→ 2号에게 에스컬레이션
```

### 품질 게이트 검증

**검증 체크리스트**:

```python
def verify_quality_gates(state: dict) -> bool:
    """품질 게이트 통과 검증."""

    quality = state["quality"]

    # 모든 위반이 0인지 확인
    if quality["violations_total"] != 0:
        return False

    # can_proceed 플래그 확인
    if not quality["can_proceed"]:
        return False

    # 도메인별 확인
    if state["agent"] == "implementer-spark":
        # 테스트 커버리지 있어야 함
        if quality["step_6_testing"]["coverage"] < 0.95:
            return False

    return True
```

### 시행

- 품질 게이트는 건너뛸 수 없음
- 모든 위반은 0이어야 함
- 수동 수정만 (자동 스크립트 안 됨)
- 각 재시도에서 진전 필요
- 최대 3회 재시도

---

## 요약

이 가이드는 탁월한 SPARK 에이전트 생성을 위한 상세 명세 제공:

1. **단일 도메인**: 하나의 에이전트, 하나의 전문 도메인
2. **이중 정의**: Traits (자연어) + Protocol (코드 기반)
3. **전문적 워크플로우**: 반복을 가진 적응적 phase
4. **에이전트 정의**: 4가지 핵심 요소 (Traits, Workflow, Validation, Evidence)
5. **페르소나 몰입**: Traits가 행동을 이끄는 정체성 생성
6. **프로젝트 컨텍스트**: 사전 준수 (먼저 표준 읽기)
7. **품질 게이트**: 무관용 강제

**핵심 원칙**: 에이전트가 무엇을 하는지(작업)가 아니라 누구인지(traits)를 정의. 올바른 정체성이 자연스럽게 올바른 행동을 이끔.

---

**관련 문서**:
- **1_CONSTITUTION_ko.md** - 핵심 원칙
- **3_COMMAND_DESIGN_GUIDE_ko.md** - 커맨드 오케스트레이션
- **4_INTEGRATION_GUIDE_ko.md** - 통합 표준
- **5_TEMPLATES_ko.md** - 빠른 시작 템플릿
