# 핵심정의 해설서 Part 1: 핵심 기능과 아키텍처 패밀리

> **목적**: 핵심정의 가이드의 상세 해설 - Part 0과 Layer 1
>
> **참고**:
> - 가이드: `01_CORE_DEFINITION_GUIDE.md`
> - Part 2: `01-1_CORE_DEFINITION_MANUAL_Part2.md` (Layer 2-3)
> - 사례집: `IMPLEMENTATION_CASES.md`

---

## 목차

1. [Part 0: 핵심 기능 파악](#1-part-0-핵심-기능-파악)
2. [Layer 1: 아키텍처 패밀리](#2-layer-1-아키텍처-패밀리)

---

## 1. Part 0: 핵심 기능 파악

### 1.1 왜 Part 0가 필요한가?

#### 실패 사례로부터의 교훈

**사례 1: BioNeX - 범위 폭발**
```
아이디어: "AI 챗봇 만들자"
    ↓
AI 챗봇 + 외부 메모리 + 지식 그래프 + RAG + ...
    ↓
300KB 문서, 구현 0줄
    ↓
결과: AI 할루시네이션 반복, 프로젝트 중단
```

**문제 분석**:
- "챗봇"과 "메모리"를 **별개의 핵심 기능**으로 봄
- 실제로는 "AI 외부 메모리" **1개**가 핵심
- 챗봇은 메모리를 **사용하는 방식** 중 하나일 뿐

**올바른 접근**:
```
핵심 기능: AI 외부 메모리 (CRUD)
├─ 사용 방식 A: 챗봇 인터페이스
├─ 사용 방식 B: API
└─ 사용 방식 C: CLI
```

---

**사례 2: Memory V3 - 목표 모호**
```
목표: "좋은 메모리 시스템" (추상적!)
    ↓
33개 필드 스키마 설계
    ↓
복잡도 폭발
    ↓
결과: 98% 완성, 0% 가치
```

**문제 분석**:
- "좋은"이 무엇인지 정의 안 됨
- 핵심 기능 자체가 명확하지 않음
- MVP 정의 없이 모든 기능 추가

---

**사례 3: Memory V5 - 환경만 100%**
```
계획: "이번엔 환경부터 완벽히!"
    ↓
DNA 시스템 100% 완성
    ↓
실제 메모리 기능 0%
    ↓
결과: 통합 불가능
```

**문제 분석**:
- 핵심 기능과 환경(인프라)을 구분 못 함
- "메모리 저장/조회"가 핵심인데 DNA 구축에 집중

---

#### Jason의 핵심 통찰 (2025-11-12)

**Phase 2 주식 거래 플랫폼 분석 중**:

2호의 초기 분석:
```
핵심 기능 2개:
1. 수동 거래
2. 자동 거래
```

Jason의 수정:
```
❌ "자동에 의미를 두면 안 되고"
✅ "거래가 핵심이다"

핵심 기능 1개:
- 거래
  ├─ 구현 방식 A: 수동
  └─ 구현 방식 B: 자동
```

**핵심 원칙**:
> **"구현 방식이 아닌 비즈니스 목적으로 구분한다"**

---

#### Part 0의 역할

**질문 순서**:
```
Part 0: 핵심 기능 파악 ← 먼저!
    ↓
Layer 1: 아키텍처 패밀리 식별
    ↓
Layer 2-3: NFR과 제약
```

**왜 먼저 필요한가?**:
1. Layer 1 질문들은 **"핵심 기능"** 기준으로 답변
2. 핵심 기능을 잘못 파악하면 → Layer 1 답변 혼란
3. 예: "수동 거래"와 "자동 거래" 중 어떤 걸로 답변?
   - 잘못된 질문임! "거래" 1개로 답변해야!

---

### 1.2 핵심 기능 판단 기준 ⭐⭐⭐

> **출처**: `docs/session-summaries/20251112_핵심기능_판단기준.md`

#### 잘못된 기준 vs 올바른 기준

**비교표**:

| 항목 | 잘못된 구분 ❌ | 올바른 구분 ✅ |
|------|----------------|----------------|
| **핵심 기능 개수** | 수동 거래 + 자동 거래 = 2개 | 거래 = 1개 |
| **수동/자동** | 2개의 다른 기능 | 1개 기능의 구현 방식 |
| **실패 영향** | 자동=A, 수동=B (다름) | 거래 실패=A (동일) |
| **Layer 1 답변** | 어떤 걸 핵심으로 볼지 혼란 | "거래"로 일관되게 답변 |
| **시스템 설계** | 기능별로 쪼개야 함 | 통합된 아키텍처 가능 |

---

#### 3단계 실전 적용 방법

**Step 1: 시스템의 존재 이유 파악**

**질문**: "이 시스템이 없으면 사용자는 무엇을 못 하는가?"

**주식 거래 플랫폼 예시**:
```
시스템 없으면 → 주식 거래를 못 함
→ 핵심 기능 = "거래" (1개)

❌ 잘못된 구분:
   핵심 기능 1: 수동 거래
   핵심 기능 2: 자동 거래

✅ 올바른 구분:
   핵심 기능: 거래
   ├─ 구현 방식 1: 수동
   └─ 구현 방식 2: 자동
```

**AI 외부 메모리 예시**:
```
시스템 없으면 → AI가 대화 내용을 기억 못 함
→ 핵심 기능 = "외부 메모리 (CRUD)" (1개)

❌ 잘못된 구분:
   핵심 기능 1: 챗봇
   핵심 기능 2: 메모리 저장
   핵심 기능 3: 메모리 검색

✅ 올바른 구분:
   핵심 기능: AI 외부 메모리
   ├─ 사용 방식 1: 챗봇 인터페이스
   ├─ 사용 방식 2: API
   └─ CRUD: 저장/조회/수정/삭제
```

---

**Step 2: 실패의 비즈니스 영향 평가**

**질문**: "핵심 기능이 실패하면 비즈니스 목적 달성에 어떤 영향을 주는가?"

**주식 거래 플랫폼 예시**:
```
거래 기능 실패:

방식 A (수동):
- 사용자 클릭 → 체결 안 됨
- 원하는 가격에 못 삼 → 금전 손실 ✅

방식 B (자동):
- 조건 충족 → 체결 안 됨
- 원하는 가격에 못 삼 → 금전 손실 ✅

→ 구현 방식과 무관하게 동일한 비즈니스 영향!
→ "거래" 1개가 핵심 기능 맞음! ✅
```

**검증 체크**:
- [ ] 실패 영향이 **구현 방식과 무관**하게 동일한가?
- [ ] 모든 방식의 실패가 **동일한 치명도**인가?
- [ ] "방식 A는 치명적, 방식 B는 괜찮다" → 잘못된 구분!

---

**Step 3: 구현 방식이 아닌 결과로 판단**

**질문**: "사용자 관점에서 결과가 무엇인가?"

**주식 거래 플랫폼 예시**:
```
사용자 관점:
- "주식을 사고 싶다" (목적)
- "어떻게 사느냐" (방식)는 중요하지 않음

결과:
- 수동으로 사든, 자동으로 사든
- 결과 = "주식 체결"

→ 핵심 기능 = "거래"
→ 수동/자동 = 구현 방식
```

**검색 시스템 예시**:
```
사용자 관점:
- "정보를 찾고 싶다" (목적)
- "일반 검색이냐 AI 검색이냐"는 중요하지 않음

결과:
- 일반 검색으로 찾든, AI 검색으로 찾든
- 결과 = "정보 검색"

→ 핵심 기능 = "검색"
→ 일반/AI = 구현 방식 (정확도 차이)
```

---

#### 경계 사례 처리

**Q: 실제로 다른 기능인 경우는?**

**예시: 이커머스 플랫폼**
```
핵심 기능 2개:
1. 상품 검색 (검색/추천 패밀리)
2. 주문/결제 (트랜잭션 패밀리)

→ 이건 정말 다른 기능!
   실패 영향: 검색 실패 = 불편 (C)
              주문 실패 = 금전 손실 (A)
```

**판단 기준**:
- [ ] 실패 영향이 **다른가**?
- [ ] 사용자 목적이 **다른가**?
- [ ] 하나 없어도 **나머지가 가치 있는가**?

모두 YES → 진짜 다른 기능! 분리 OK ✅

---

**Q: 복합 시스템은 어떻게?**

**예시: 주식 거래 플랫폼**
```
시스템 구성:
├─ 1. 실시간 호가 스트리밍 (부가 기능)
│  └─ 역할: 최신 가격 정보 제공
│
└─ 2. 거래 (핵심 기능) ⭐
   ├─ 수동 거래
   └─ 자동 거래
```

**판단**:
- "호가 스트리밍 없어도 거래는 가능?" → YES (API 직접 조회)
- "거래 없어도 호가만 보는 게 가치?" → NO (정보만 보고 거래 못 하면 의미 없음)

→ 핵심 기능 = "거래" 1개
→ 호가 스트리밍 = 부가 기능 (거래를 돕는 도구)

**Layer 1 답변 시**:
- "거래" 기준으로 답변 (A-C-A)
- 호가 스트리밍은 **기술 구현 세부사항**

---

#### 실전 체크리스트

**Q0-1: 핵심 기능 파악 시**

- [ ] **비즈니스 목적**으로 구분했는가?
- [ ] **구현 방식**을 별개 기능으로 보지 않았는가?
- [ ] "수동/자동", "일반/AI" 같은 키워드에 속지 않았는가?
- [ ] 사용자는 "방식"이 아니라 "결과"를 원한다는 걸 기억했는가?

**Q0-2: 실패 영향 검증 시**

- [ ] 모든 구현 방식의 실패 영향이 **동일한가**?
- [ ] 금전 손실 / 데이터 손실 / 불편함 중 무엇인가?
- [ ] "이 방식은 치명적, 저 방식은 괜찮다" → 잘못된 구분 의심!

---

### 1.3 실패 영향 평가 (Q0-2 상세)

#### 치명도 분류

**A (치명적)**:
- 금전 손실
- 데이터 손실 (복구 불가)
- 시스템 가치 완전 상실

**예시**:
- 거래 실패 → 금전 손실
- 결제 실패 → 매출 손실
- 백업 실패 → 데이터 영구 손실

---

**B (중단·재시도)**:
- 일시 중단
- 재연결/재시도하면 복구
- 부분 서비스 가능

**예시**:
- 스트리밍 끊김 → 재연결
- 푸시 알림 실패 → 나중에 확인
- 실시간 채팅 지연 → 몇 초 후 도착

---

**C (점진적 저하)**:
- 품질 저하
- 부분 동작
- 완전 중단은 아님

**예시**:
- 검색 결과 관련성 낮음 → 계속 검색 가능
- 추천 정확도 낮음 → 수동 선택 가능
- 분석 지연 → 나중에라도 결과 나옴

---

#### 경계 사례

**Q: 실시간 알림 실패는 B? C?**

**경우 1: 푸시 알림 (B)**
```
실패 시:
- 앱에서 나중에 확인 가능
- 재연결 시 알림 수신
→ 중단·재시도 (B)
```

**경우 2: 긴급 알림 (A)**
```
실패 시:
- 지진 경보 못 받음 → 생명 위험
- 주가 급락 알림 못 받음 → 금전 손실
→ 치명적 (A)
```

**판단 기준**: 실패 시 **대안이 있는가**?

---

**Q: 데이터 저장 실패는 A? B?**

**경우 1: 트랜잭션 (A)**
```
실패 시:
- 주문 기록 없음 → 고객 클레임
- 결제 기록 없음 → 매출 손실
→ 치명적 (A)
```

**경우 2: 캐시 (B)**
```
실패 시:
- 캐시 miss → 원본 DB 조회
- 성능 저하만 발생
→ 중단·재시도 (B)
```

**판단 기준**: 실패 시 **데이터 복구 가능한가**?

---

## 2. Layer 1: 아키텍처 패밀리

### 2.1 왜 스무고개 방식인가?

#### 고정 질문의 문제점 (v1.0)

**기존 방식**:
```
모든 프로젝트에 동일한 7가지 질문:
□ Q1. 핵심 목표는?
□ Q2. 사용자는?
□ Q3. MVP는?
...
□ Q7. 아키텍처 제약은?
```

**문제**:
1. 채팅 앱과 배치 시스템이 같은 질문? → 비효율
2. 중요한 질문 놓침 (패밀리별 특성 무시)
3. 불필요한 질문 강제 (배치 시스템에 "실시간성"?)

---

#### 스무고개 방식의 장점 (v2.0)

**원리**: 답변에 따라 다음 질문이 달라짐

**예시 1: 결정론적 시스템 (문서 생성)**
```
L1-Q1: 틀리면? → A (치명적)
L1-Q2: 정보 형태? → A (구조화)
L1-Q3: 응답 시점? → A (즉각)
→ 패밀리: CRUD/트랜잭션 (A-A-A)

다음 질문 (Layer 2):
→ 정확성, 트랜잭션 일관성 중심
→ "검색 관련성"은 묻지 않음 (불필요)
```

**예시 2: 확률론적 시스템 (AI 검색)**
```
L1-Q1: 틀리면? → C (점진적)
L1-Q2: 정보 형태? → B (비구조화)
L1-Q3: 응답 시점? → B (조회 후)
→ 패밀리: 검색/추천 (C-B-B)

다음 질문 (Layer 2):
→ 관련성, 지연시간 중심
→ "트랜잭션"은 묻지 않음 (불필요)
```

**효율성**:
- 필요한 질문만 → 10개 → 5-7개로 감소
- 패밀리별 최적화된 질문

---

#### Amazon/SEI 이론과의 연결

**Amazon 3단계 방법론**:
```
핵심정의 = Amazon Stage 1: Identify Use Cases
    ↓
구현방법 = Amazon Stage 2: Specify Concrete Requirements
    ↓
ADR      = Amazon Stage 3: Select Tools & Infrastructure
```

**Carnegie Mellon SEI 원칙**:
> **"품질 속성(Quality Attributes)이 아키텍처를 주도한다"**
>
> 아키텍처는 기능이 아닌, **비기능 요구사항(NFRs)**에 의해 결정됩니다.

**연결**:
- Layer 1 → 시스템 본질 파악 (USE CASE)
- Layer 2 → NFR 우선순위 (QUALITY ATTRIBUTES)
- Layer 3 → 기술 제약 (INFRASTRUCTURE)

---

### 2.2 6가지 아키텍처 패밀리 ⭐

#### 패밀리 1: CRUD/트랜잭션 (A-A-A)

**특징**:
- 실패 = 치명적 (A)
- 구조화된 데이터 (A)
- 즉각 응답 (A)

**핵심 품질**: 정확성 100%

**적용 사례**:
- 문서 생성 시스템
- 주문/결제
- 재고 관리
- 회원 가입

**NFR 프로파일 경향**:
- L2-Q1: A (정확성)
- L2-Q2: A or B (규모)
- L2-Q3: A or B (보안)
- L2-Q4: A or B (최신성)

**Martin Fowler 패턴**:
- Transaction Script
- Domain Model
- Unit of Work
- Repository

**충돌 패턴 (흔한 경우)**:
- 정확성 (A) + 규모 (C) → DB 샤딩 필요
- 정확성 (A) + 최신성 (A) → 분산 트랜잭션 복잡

---

#### 패밀리 2: 검색/추천 (C-B-B)

**특징**:
- 실패 = 점진적 저하 (C)
- 비구조화 데이터 (B)
- 조회 후 응답 (B)

**핵심 품질**: 관련성

**적용 사례**:
- AI 외부 메모리
- 문서 검색
- 상품 추천
- 콘텐츠 필터링

**NFR 프로파일 경향**:
- L2-Q1: C (관련성)
- L2-Q2: B or C (규모)
- L2-Q3: B or C (보안)
- L2-Q4: B or C (최신성)

**Martin Fowler 패턴**:
- Service Layer
- Data Mapper
- Query Object
- Optimistic Lock (읽기 많음)

**충돌 패턴**:
- 관련성 (C) + 즉시성 (A) → 캐싱 전략
- 규모 (C) + 정확성 (B) → Eventual Consistency

---

#### 패밀리 3: 실시간 스트리밍 (B-C-A)

**특징**:
- 실패 = 중단·재시도 (B)
- 숫자/센서 데이터 (C)
- 즉각 응답 (A)

**핵심 품질**: 지연시간 < 1초

**적용 사례**:
- IoT 센서 모니터링
- 실시간 대시보드
- 라이브 스트리밍
- 게임 서버

**NFR 프로파일 경향**:
- L2-Q1: B (속도)
- L2-Q2: B or C (규모)
- L2-Q3: C (보안 낮음)
- L2-Q4: A (즉시)

**Martin Fowler 패턴**:
- Gateway (WebSocket)
- Server Session State
- Event Sourcing

**충돌 패턴**:
- 속도 (B) + 규모 (C) → 메시지 큐 (Kafka)
- 즉시성 (A) + 정확성 (B) → Eventual Consistency

---

#### 패밀리 4: 협업/동기화 (B-A-A)

**특징**:
- 실패 = 중단·재시도 (B)
- 구조화 데이터 (A)
- 즉각 응답 (A)

**핵심 품질**: 일관성

**적용 사례**:
- Google Docs
- 실시간 협업 편집
- 화이트보드
- 멀티플레이어 게임

**NFR 프로파일 경향**:
- L2-Q1: A or B (정확성/속도)
- L2-Q2: B (중규모)
- L2-Q3: B (민감)
- L2-Q4: A (즉시)

**Martin Fowler 패턴**:
- Optimistic Lock
- Pessimistic Lock
- Unit of Work
- CQRS

**충돌 패턴**:
- 일관성 (A) + 즉시성 (A) → OT/CRDT 알고리즘
- 동시 편집 충돌 해결

---

#### 패밀리 5: 분석/배치 (C-C-C)

**특징**:
- 실패 = 점진적 저하 (C)
- 숫자/분석 데이터 (C)
- 배치 처리 (C)

**핵심 품질**: 처리량

**적용 사례**:
- ETL 파이프라인
- BI 리포트
- 데이터 웨어하우스
- 주기적 배치 작업

**NFR 프로파일 경향**:
- L2-Q1: B or C (속도/비용)
- L2-Q2: C (대규모)
- L2-Q3: B or C (보안)
- L2-Q4: C (배치)

**Martin Fowler 패턴**:
- Table Module
- ETL Gateway
- Batch Processing

**충돌 패턴**:
- 처리량 (C) + 비용 (B) → 스팟 인스턴스
- 대규모 (C) + 정확성 (B) → 샘플링

---

#### 패밀리 6: 실시간 트랜잭션 (A-C-A) ⭐ NEW!

> **발견 날짜**: 2025-11-12 (Phase 2 주식 거래 플랫폼 분석)

**특징**:
- 실패 = 치명적 (A) - 금전 손실
- 숫자/시계열 데이터 (C)
- 즉각 응답 (A) - 밀리초 단위

**핵심 품질**: 정확성 + 즉시성 (둘 다!)

**적용 사례**:
- **주식 거래 시스템** (발견 계기)
- 금융 트랜잭션
- 자동화 트레이딩
- IoT 제어 시스템 (공장 자동화, 자율주행)

**NFR 프로파일 경향**:
- L2-Q1: A (정확성 100%)
- L2-Q2: A or B (개인용~중규모)
- L2-Q3: A or B (금융 데이터)
- L2-Q4: A (즉시, < 100ms)

**Martin Fowler 패턴**:
- Event-driven Architecture
- CQRS (명령/조회 분리)
- Saga Pattern (분산 트랜잭션)

**충돌 패턴 (가장 어려움!)**:
- 정확성 (A) + 즉시성 (A) → 비용 극대화
- 예: 주식 거래 - 100% 정확 + 100ms 이내
  - 해결: WebSocket + Polling 하이브리드
  - Rate Limit 관리 필수

**기존 패밀리와의 차이**:
```
vs 패밀리 1 (CRUD, A-A-A):
- 패밀리 1: 정확성 중심, 즉시성은 "빠르면 좋음"
- 패밀리 6: 정확성 + 즉시성 둘 다 필수!

vs 패밀리 3 (스트리밍, B-C-A):
- 패밀리 3: 지연 허용 (재연결 가능)
- 패밀리 6: 지연 불허 (금전 손실)
```

**왜 새 패밀리인가?**:
- A-C-A 조합은 기존에 없었음
- 충돌 패턴이 독특 (정확+즉시 동시 요구)
- 해결 방법도 다름 (하이브리드 아키텍처)

---

### 2.3 L1-Q1: 실패 파급력 상세

#### A (치명적) 판단 기준

**조건**:
- 시스템 가치 완전 상실
- 금전적 손실 발생
- 데이터 영구 손실
- 법적 책임 발생

**예시**:
- 결제 실패 → 매출 손실
- 거래 실패 → 고객 클레임
- 백업 실패 → 데이터 복구 불가
- 의료 기록 손실 → 법적 문제

**질문**:
- [ ] 실패 시 돈을 잃는가?
- [ ] 실패 시 데이터가 영구 손실되는가?
- [ ] 실패 시 시스템을 쓸 이유가 없는가?

하나라도 YES → A (치명적)

---

#### B (중단·재시도) 판단 기준

**조건**:
- 일시 중단 가능
- 재연결/재시도로 복구
- 대안 경로 존재

**예시**:
- 스트리밍 끊김 → 재연결
- 실시간 알림 지연 → 나중에 확인
- WebSocket 끊김 → Polling으로 대체
- 푸시 알림 실패 → 앱 내에서 확인

**질문**:
- [ ] 재시도하면 복구되는가?
- [ ] 대안 방법이 있는가?
- [ ] 일시적 불편일 뿐 가치 상실은 아닌가?

모두 YES → B (중단·재시도)

---

#### C (점진적 저하) 판단 기준

**조건**:
- 품질만 저하
- 부분 동작 가능
- 완전 중단은 아님

**예시**:
- 검색 관련성 낮음 → 계속 검색 가능
- 추천 정확도 낮음 → 수동 탐색 가능
- 분석 지연 → 나중에라도 결과
- 캐시 miss → DB 조회 (느림)

**질문**:
- [ ] 품질은 낮지만 동작은 하는가?
- [ ] 사용자가 직접 대안을 찾을 수 있는가?
- [ ] 완전 중단보다는 나은가?

모두 YES → C (점진적 저하)

---

#### 경계 사례: A vs B

**사례: 실시간 알림**

**경우 1: 푸시 알림 (B)**
```
앱 내 알림 센터 있음
→ 나중에 확인 가능
→ B (중단·재시도)
```

**경우 2: 긴급 알림 (A)**
```
지진 경보, 주가 급락
→ 즉시 못 받으면 피해
→ A (치명적)
```

**판단 포인트**: "즉시 못 받으면 가치 상실인가?"

---

**사례: 데이터 저장 실패**

**경우 1: 트랜잭션 (A)**
```
주문 기록, 결제 기록
→ 복구 불가
→ A (치명적)
```

**경우 2: 로그 (B)**
```
액세스 로그
→ 다시 시도하면 기록됨
→ B (중단·재시도)
```

**판단 포인트**: "복구 가능한가?"

---

#### 경계 사례: B vs C

**사례: 검색 기능**

**경우 1: 검색 서버 다운 (B)**
```
완전 중단
→ 재시작 필요
→ B (중단·재시도)
```

**경우 2: 검색 품질 낮음 (C)**
```
관련성 낮은 결과
→ 계속 검색 가능
→ C (점진적 저하)
```

**판단 포인트**: "완전 중단인가 vs 품질 저하인가?"

---

### 2.4 L1-Q2: 정보 형태 상세

#### A (구조화) 판단 기준

**특징**:
- JSON, XML, 테이블
- 스키마 정의
- 타입 명확

**예시**:
```json
{
  "orderId": "ORD-123",
  "userId": 456,
  "amount": 50000,
  "status": "completed"
}
```

**적용**:
- 주문, 사용자, 상품
- 트랜잭션, 재고
- 회원 정보

---

#### B (비구조화) 판단 기준

**특징**:
- 텍스트, 문서, 이미지
- 자연어
- 가변 형식

**예시**:
```
사용자 리뷰:
"이 제품 정말 좋아요! 배송도 빠르고..."

문서:
# 제목
본문 내용...
```

**적용**:
- 문서 검색
- 챗봇 대화
- 리뷰, 댓글

---

#### C (숫자·분석) 판단 기준

**특징**:
- 시계열, 통계
- 수치 연산
- 집계, 분석

**예시**:
```
주가 데이터:
timestamp: 2025-11-12 10:30:00
price: 75000
volume: 1000000

센서 데이터:
temperature: 23.5
humidity: 65
```

**적용**:
- 주가, 거래량
- IoT 센서
- 매출, 지표

---

#### 혼합 데이터 처리

**Q: 주문 + 리뷰 시스템은?**

**분석**:
```
주문 데이터: A (구조화)
리뷰 데이터: B (비구조화)

핵심 기능은?
→ 주문이 핵심
→ 리뷰는 부가 기능

Layer 1 답변: A (구조화)
```

**원칙**: **핵심 기능**이 다루는 주된 정보 형태로 답변

---

### 2.5 L1-Q3: 응답 시점 상세

#### A (즉각) 판단 기준

**시간**: < 100ms ~ 1초

**특징**:
- 실시간 상호작용
- 사용자 대기 불가
- 동기식 응답

**예시**:
- 거래 체결
- 게임 입력
- 채팅 전송
- 결제 승인

---

#### B (조회 후) 판단 기준

**시간**: 1~3초

**특징**:
- 사용자 대기 가능
- 검색, 조회 후 결과
- 비동기 가능

**예시**:
- 검색 결과
- API 조회
- 리포트 생성 (간단)

---

#### C (배치) 판단 기준

**시간**: 분 ~ 시간 ~ 일

**특징**:
- 주기적 처리
- 백그라운드
- 사용자 대기 안 함

**예시**:
- ETL
- 일일 리포트
- 데이터 백업
- 통계 집계

---

## 참고 문서

- **가이드**: `01_CORE_DEFINITION_GUIDE.md`
- **Part 2**: `01-1_CORE_DEFINITION_MANUAL_Part2.md` (Layer 2-3)
- **사례집**: `IMPLEMENTATION_CASES.md`
- **오늘 발견**: `../session-summaries/20251112_핵심기능_판단기준.md`

---

**버전**: v2.1 Part 1 (2025-11-12)
