# Stage 1: 아키텍처 결정 해설서 (Architecture Decision Manual)

> **목적**: 아키텍처 결정 가이드의 상세 해설
>
> **버전**: v2.0 (2025-11-12)
> **연계 문서**: `02_ARCHITECTURE_DECISION_GUIDE.md`

---

## 📚 이 문서의 목적

**Guide에서 제공하는 것**:
- 질문 템플릿
- 간단한 체크 방법
- 간략한 예시

**Manual에서 제공하는 것** (이 문서):
- 왜 이 단계들이 필요한가?
- 어떻게 조사하고 분석하는가?
- 상세한 실전 예시와 경험담
- 발생 가능한 문제와 해결책

---

## Part 0 해설: 핵심 기능 재확인

### 1.1 왜 Part 0가 필요한가?

#### 발견 배경

**Phase 2 주식 거래 플랫폼 사례** (2025-11-12):
```
초기 분석 (잘못):
- 핵심 기능 1: 수동 거래
- 핵심 기능 2: 자동 거래
→ Layer 1 질문 답변 시 혼란
→ "어느 기능 기준으로 답해야 하나?"

수정 후 (올바름):
- 핵심 기능: 거래 (1개)
- 구현 방식: 수동, 자동
→ Layer 1 질문 답변 일관됨
→ 명확한 아키텍처 결정
```

**교훈**:
> "핵심 기능을 잘못 구분하면 모든 게 틀어진다"
>
> Part 0 실수 → Layer 1 혼란 → 전체 설계 실패

#### Part 0는 언제 하는가?

```
01_CORE_DEFINITION 완료 ✅
         ↓
Part 0 재확인 (Stage 1 시작 전) ← 이 단계!
         ↓
Layer 1-2-3 진행
```

**핵심 원칙**:
- Part 0는 **재확인**입니다 (새 분석 아님!)
- 01_CORE_DEFINITION에서 실수가 있었는지 점검
- 실수 발견 시 → 01로 돌아가서 재작성!

---

### 1.2 Q0-1: 비즈니스 목적 vs 구현 방식

#### 왜 이 구분이 중요한가?

**잘못된 구분의 영향**:
```
예시: 주식 거래 플랫폼

❌ 수동 거래 + 자동 거래 = 2개 핵심 기능으로 구분

L1-Q1: 실패 파급력은?
→ 수동 거래 실패? 자동 거래 실패?
→ 어느 걸 기준으로 답해야 하나?
→ 혼란!

L1-Q2: 정보 형태는?
→ 수동은 클릭 이벤트, 자동은 조건 데이터?
→ 어느 걸 선택하나?
→ 혼란!

결과:
→ 패밀리 결정 불가능
→ 아키텍처 설계 막힘
```

**올바른 구분의 효과**:
```
✅ 거래 = 1개 핵심 기능

L1-Q1: 실패 파급력은?
→ 거래 실패 = 금전 손실
→ 명확! (수동/자동 무관)

L1-Q2: 정보 형태는?
→ 거래 데이터 = 주가, 호가 (숫자)
→ 명확!

L1-Q3: 응답 시점은?
→ 거래 요청 = 즉시 체결 필요
→ 명확!

결과:
→ A-C-A 패턴 도출
→ 실시간 트랜잭션 패밀리
```

#### 어떻게 구분하는가?

**3단계 체크 방법**:

**Step 1: "자동"이나 "수동"을 제거해도 의미가 통하는가?**
```
❌ "수동 거래" → "수동" 제거 → "거래" (의미 통함!)
❌ "자동 거래" → "자동" 제거 → "거래" (의미 통함!)

→ "수동"과 "자동"은 부가 정보!
→ 핵심은 "거래"!
```

**Step 2: 실패의 비즈니스 영향이 동일한가?**
```
수동 거래 실패:
- 사용자가 클릭했는데 체결 안 됨
- 원하는 가격에 못 삼
- 금전 손실 💸

자동 거래 실패:
- 조건 충족했는데 체결 안 됨
- 원하는 가격에 못 삼
- 금전 손실 💸

→ 영향이 동일! (방식과 무관)
→ 하나의 핵심 기능!
```

**Step 3: 사용자가 원하는 결과가 무엇인가?**
```
사용자 관점:

❌ "자동으로 거래됐는지" → 중요 X
✅ "원하는 가격에 거래됐는지" → 중요 O

→ 구현 방식(자동/수동) 무관
→ 결과(거래 성공/실패)가 핵심
```

#### 다른 도메인 예시

**AI 검색 시스템**:
```
❌ 잘못된 구분:
- 핵심 기능 1: 키워드 검색
- 핵심 기능 2: AI 의미 검색

✅ 올바른 구분:
- 핵심 기능: 검색
- 구현 방식: 키워드, AI 의미론
```

**결제 시스템**:
```
❌ 잘못된 구분:
- 핵심 기능 1: 카드 결제
- 핵심 기능 2: 계좌이체 결제

✅ 올바른 구분:
- 핵심 기능: 결제
- 구현 방식: 카드, 계좌이체, 간편결제
```

**핵심 원칙**:
> "구현 방식에 의미를 두면 안 되고, 비즈니스 목적이 핵심이다"
>
> - Jason의 통찰 (2025-11-12)

---

### 1.3 Q0-2: 실패 영향의 일관성

#### 왜 실패 영향을 확인하는가?

**목적**:
```
여러 구현 방식이 동일한 비즈니스 영향을 가지면
→ 하나의 핵심 기능이다!

영향이 다르면
→ 별개의 핵심 기능일 수 있다
```

#### 실전 적용 방법

**주식 거래 플랫폼 예시**:
```
방식 A (수동 거래):
- 시나리오: 사용자가 "매수" 버튼 클릭
- 실패: API 호출 실패, 네트워크 오류
- 비즈니스 영향:
  ✅ 원하는 가격에 못 삼
  ✅ 금전 손실 (기회비용)
  ✅ 사용자 불만

방식 B (자동 거래):
- 시나리오: 조건 만족 (가격 70,000원 도달)
- 실패: 조건 감지 누락, API 호출 실패
- 비즈니스 영향:
  ✅ 원하는 가격에 못 삼
  ✅ 금전 손실 (기회비용)
  ✅ 사용자 불만

결론:
→ 비즈니스 영향 동일!
→ 하나의 핵심 기능!
```

**의료 기록 시스템 예시**:
```
방식 A (수기 입력):
- 실패: 입력 오류, 저장 실패
- 비즈니스 영향:
  ✅ 환자 정보 손실
  ✅ 진료 연속성 단절
  ✅ 법적 책임

방식 B (OCR 자동 인식):
- 실패: 인식 오류, 저장 실패
- 비즈니스 영향:
  ✅ 환자 정보 손실
  ✅ 진료 연속성 단절
  ✅ 법적 책임

결론:
→ 비즈니스 영향 동일!
→ 하나의 핵심 기능! (의료 기록)
```

**반례: 영향이 다른 경우**:
```
예시: 뉴스 플랫폼

기능 A: 뉴스 작성
- 실패: 기사 작성 불가
- 영향: 콘텐츠 생산 중단 (치명적)

기능 B: 뉴스 검색
- 실패: 검색 결과 부정확
- 영향: 사용자 불편 (경미)

결론:
→ 비즈니스 영향 다름!
→ 별개의 핵심 기능!
```

---

### 1.4 Q0-3: Layer 1 답변의 명확성

#### 왜 이 확인이 필요한가?

**목적**:
```
Part 0에서 핵심 기능을 정확히 파악했다면
→ Layer 1 질문에 명확히 답할 수 있다

답변이 애매하거나 혼란스럽다면
→ Part 0 재검토 필요!
```

#### 실전 체크 방법

**주식 거래 플랫폼 예시**:

**✅ 올바른 구분 시** (거래 = 1개 기능):
```
L1-Q1: 거래 실패하면?
→ 명확한 답: 금전 손실 (A)
→ 수동이든 자동이든 동일
→ 혼란 없음 ✅

L1-Q2: 거래가 다루는 정보는?
→ 명확한 답: 주가, 호가 (숫자 데이터, C)
→ 수동이든 자동이든 동일
→ 혼란 없음 ✅

L1-Q3: 거래 응답 시점은?
→ 명확한 답: 즉시 체결 필요 (A)
→ 수동이든 자동이든 동일
→ 혼란 없음 ✅
```

**❌ 잘못된 구분 시** (수동+자동 = 2개 기능):
```
L1-Q1: 실패하면?
→ 애매한 답: 수동? 자동? 어느 걸 기준으로?
→ 혼란 발생! ⚠️

L1-Q2: 정보 형태는?
→ 애매한 답: 수동은 클릭? 자동은 조건?
→ 혼란 발생! ⚠️

L1-Q3: 응답 시점은?
→ 애매한 답: 수동은 즉시? 자동은 주기적?
→ 혼란 발생! ⚠️
```

**진단 기준**:
```
✅ 명확함:
- 하나의 일관된 답변
- "어느 걸 기준으로?" 질문 없음
- 답변에 확신

⚠️ 애매함:
- "이것도 되고 저것도 되고..."
- "경우에 따라 다르다"
- 답변에 혼란
→ Part 0 재검토 필요!
```

---

## Part 1-2 해설: Layer 1-2 재확인

### 2.1 왜 재확인인가?

**핵심 이해**:
```
01_CORE_DEFINITION에서 이미 완료:
- Layer 1: L1-Q1, Q2, Q3 답변 완료
- Layer 2: L2-Q1, Q2, Q3, Q4 답변 완료
- 패밀리: A-C-A 등 결정 완료
- NFR 프로파일: A-B-B-A 등 결정 완료

Stage 1에서 하는 것:
- ❌ 새로운 질문에 답하기 (X)
- ✅ 기존 답변 재확인하기 (O)
```

**왜 재확인하는가?**:
```
1. Part 0 재확인 후 수정 발생 가능성
   → 핵심 기능 구분 변경 시
   → Layer 1-2 답변도 변경 필요

2. 일관성 검증
   → L1-Q1/Q2/Q3 답변이 서로 일치하는가?
   → NFR 프로파일이 합리적인가?

3. 패밀리 확정
   → A-C-A 패턴 확인
   → 6가지 패밀리 중 어디에 속하는가?
```

**재확인 프로세스**:
```
Step 1: Part 0 재확인 완료 확인
   ↓
Step 2: Layer 1 답변 읽기 (01_CORE_DEFINITION에서)
   ↓
Step 3: 일관성 검증
   - L1-Q1/Q2/Q3가 서로 일치?
   - 패밀리 패턴 도출 가능?
   ↓
Step 4: Layer 2 답변 읽기
   ↓
Step 5: NFR 프로파일 확정
   - A-B-B-A 등 패턴 확인
   ↓
완료: Part 3 (Layer 3 조사)로 진행
```

---

### 2.2 6가지 아키텍처 패밀리 상세

#### 패밀리 1: CRUD/트랜잭션 (A-A-A)

**특징**:
```
- 실패: 치명적 (A) → 데이터 손실, 불일치
- 정보: 구조화 (A) → JSON, 테이블
- 응답: 즉각 (A) → 사용자 대기 중
```

**대표 사례**:
- 문서 생성/수정
- 주문 처리
- 사용자 등록
- 결제 트랜잭션

**핵심 원칙**:
- ACID 보장 필수
- 동시성 제어
- 롤백 가능해야 함

---

#### 패밀리 2: 검색/추천 (C-B-B)

**특징**:
```
- 실패: 점진적 저하 (C) → 부분 결과 가능
- 정보: 비구조화 (B) → 텍스트, 자연어
- 응답: 조회 후 (B) → 1-3초
```

**대표 사례**:
- AI 검색
- 추천 시스템
- 콘텐츠 필터링

**핵심 원칙**:
- 관련성(Relevance) 중심
- 부분 실패 허용
- 점진적 개선

---

#### 패밀리 3: 실시간 스트리밍 (B-C-A)

**특징**:
```
- 실패: 중단·재시도 (B) → 재연결 가능
- 정보: 숫자·분석 (C) → 시계열
- 응답: 즉각 (A) → 실시간
```

**대표 사례**:
- IoT 센서 데이터
- 주가 호가 스트리밍 (부가 기능)
- 실시간 대시보드

**핵심 원칙**:
- 낮은 레이턴시
- 연결 안정성
- 데이터 버퍼링

---

#### 패밀리 4: 협업/동기화 (B-A-A)

**특징**:
```
- 실패: 중단·재시도 (B) → 동기화 재시도
- 정보: 구조화 (A) → 문서, 구조
- 응답: 즉각 (A) → 실시간 협업
```

**대표 사례**:
- Google Docs
- 실시간 채팅
- 협업 편집

**핵심 원칙**:
- 일관성 유지
- 충돌 해결(CRDT)
- 오프라인 지원

---

#### 패밀리 5: 분석/배치 (C-C-C)

**특징**:
```
- 실패: 점진적 저하 (C) → 재실행 가능
- 정보: 숫자·분석 (C) → 통계, 집계
- 응답: 배치 (C) → 분~시간
```

**대표 사례**:
- ETL 파이프라인
- BI 리포트
- 데이터 분석

**핵심 원칙**:
- 처리량(Throughput) 중심
- 재시도 가능
- 멱등성 보장

---

#### 패밐리 6: 실시간 트랜잭션 ⭐ (A-C-A)

**특징**:
```
- 실패: 치명적 (A) → 금전 손실
- 정보: 숫자·분석 (C) → 시계열, 조건
- 응답: 즉각 (A) → 실시간 체결
```

**대표 사례**:
- **주식 거래 플랫폼** ⭐
- 금융 거래
- 자동화 시스템
- IoT 제어 (치명적)

**핵심 원칙**:
- 정확성 + 즉시성 모두 필수
- 트레이드오프 발생 가능 (Part 4)
- 복잡도 높음

**발견 배경**:
```
Phase 2 (2025-11-12):
"주식 거래 플랫폼 분석 중 A-C-A 패턴 발견"

기존 5개 패밀리에 없음!
→ 6번째 패밀리로 추가
```

---

## Part 3 해설: Layer 3 - 환경 제약 조사

### 4.1 L3-Q1: 기술 스택 제약 조사 ⭐⭐⭐

#### 왜 Layer 3 조사가 중요한가?

**Phase 2에서의 핵심 발견**:
> "금융 거래는 일반 시스템과 완전히 다르다!"
>
> Layer 3 없이는 설계 불가능!

**구체적 사례**:
```
증권사 API 조사 전:
- Layer 2: 정확성 A + 즉시성 A
- 생각: "WebSocket으로 실시간 처리하면 되겠네"
- ✅ 충분히 가능할 것 같음

증권사 API 조사 후:
- 한투 API: 초당 20건 제한
- WebSocket: 41개 동시 구독 제한
- ⚠️ 100개 종목 실시간 감시 불가능!
- ⚠️ Layer 2 목표 달성 불가!

→ Layer 3 조사 없이는 설계 불가능했음!
```

#### 외부 제약 조사 실전 가이드

**Step 1: 조사 필요성 판단**

**체크 질문**:
```
□ 외부 API/서비스를 사용하는가?
  예: 증권사, 결제사, 클라우드, AI 모델

□ 규제 도메인인가?
  예: 금융, 의료, 정부, 교육

□ 여러 제공자 중 선택이 필요한가?
  예: 6개 증권사, 3개 결제사

□ 사용 제한 가능성이 있는가?
  예: Rate Limit, 비용, 승인 필요
```

**판정**:
```
✅ 하나라도 Yes
→ 외부 제약 조사 필수!
→ 최소 2-3일 소요 각오

❌ 모두 No
→ 일반 웹 개발
→ 내부 결정 사항만 정리
```

---

**Step 2: 무엇을 조사하는가?**

**주식 거래 플랫폼 사례**:

**2.1 증권사 API 비교 조사**

**조사 항목**:
```
1. API 제공 방식
   □ REST API
   □ WebSocket
   □ COM/DLL (Windows 전용)
   □ gRPC

2. Rate Limiting
   □ 초당 요청 수 (실전 투자)
   □ 초당 요청 수 (모의 투자)
   □ 일일 요청 수
   □ 동시 연결 수

3. 플랫폼 제약
   □ OS 제약 (Windows / Linux / macOS)
   □ 언어 제약 (Python / Java / C++)
   □ 네트워크 제약 (IP 화이트리스트)

4. 비용
   □ 무료 / 유료
   □ 거래당 수수료
   □ API 사용료

5. 인증 방식
   □ API 키
   □ OAuth
   □ 인증서
   □ 토큰 TTL (유효기간)

6. 데이터 제공 범위
   □ 제공 종목 (국내 / 해외)
   □ 실시간 vs 지연 데이터
   □ 과거 데이터 제공 기간
```

**실제 조사 결과** (2025-11-12):
```
| 증권사 | API 방식 | Rate Limit (실전) | OS | 비용 | 평가 |
|--------|----------|-------------------|-----|------|------|
| 한국투자증권 | REST+WS | 20건/초 | 크로스 | 무료 | ⭐⭐⭐ |
| 키움증권 | COM/DLL | 5건/초 | Windows | 무료 | ⭐⭐ |
| 이베스트투자증권 | REST+WS | 10건/초 | 크로스 | 무료 | ⭐⭐ |
| 대신증권 | COM/DLL | ? | Windows | 무료 | ⭐ |
| NH투자증권 | QV API | ? | ? | ? | ❓ |
| 삼성증권 | - | - | - | - | ❌ |

선택: 한국투자증권 ✅
이유:
- 크로스 플랫폼 (Docker 배포 가능)
- REST + WebSocket 지원
- 가장 높은 Rate Limit (20건/초)
- 무료
```

**조사 방법**:
```
1. 공식 API 문서 확인
   - 각 증권사 API 포털
   - 예: https://apiportal.koreainvestment.com

2. 개발자 커뮤니티 확인
   - GitHub 이슈
   - 블로그 후기
   - Reddit, 디스코드

3. 직접 테스트 (가능 시)
   - 모의투자 계좌 생성
   - Rate Limit 실제 측정
   - 응답 속도 측정
```

---

**2.2 법적 규제 조사**

**조사 항목**:
```
1. 개인 사용 규제
   □ 본인 계좌만 사용 가능?
   □ 거래 금액 제한?
   □ 신고/인허가 필요?
   □ 거래 기록 보관 의무?

2. 서비스 제공 규제
   □ 금융업 인허가 필요?
   □ 타인 자금 운용 금지?
   □ 개인정보보호법 적용?
   □ 금융보안 인증 필요?

3. 데이터 규제
   □ 데이터 저장 위치 제약?
   □ 데이터 보관 기간?
   □ 암호화 의무?
```

**실제 조사 결과** (2025-11-12):
```
✅ 개인 사용 (본인 투자):
- 5억원 미만 거래: 규제 없음
- 신고/인허가 불필요
- 거래 기록 보관 의무 없음
- 개인정보보호법 미적용 (본인 정보만 처리)

⚠️ 유일한 의무:
- 증권사 API 약관 준수
- 본인 계좌만 사용
- API 키 보안 관리

❌ 서비스 제공 시 (타인 투자):
- 금융투자업 인허가 필요
- 투자자문업 등록 필요
- 자본금 요구사항 (수억원)
- 금융보안원 인증
- 개인정보보호법 전면 적용
→ 완전히 다른 차원의 규제!
```

**조사 방법**:
```
1. 금융위원회 규정 확인
   - 금융투자업규정
   - 자본시장법

2. 증권사 API 약관 확인
   - 사용 가능 범위
   - 금지 사항

3. 전문가 자문 (필요 시)
   - 금융 변호사
   - 규제 컨설턴트
```

**핵심 발견**:
> **"증권회사의 의무" vs "개인 개발자의 의무"를 구분하라!**
>
> - 증권회사 의무: 거래 기록 10년 보관, KYC 관리
> - 개인 개발자 의무: API 약관 준수, 본인 계좌 사용
>
> → 개인 개발자가 모든 금융 규제를 지킬 필요는 없음!

---

**2.3 개인정보보호 조사**

**조사 항목**:
```
1. 처리하는 개인정보 범위
   □ 본인 정보만?
   □ 타인 정보도?

2. 개인정보 저장
   □ 어디에 저장?
   □ 암호화 필요?
   □ 보관 기간?

3. 개인정보보호법 적용 여부
   □ 5명 미만 사업자 예외?
   □ 본인 정보만 처리 시 예외?
```

**실제 조사 결과**:
```
본인 투자 앱:
✅ 본인 정보만 처리
✅ 개인정보보호법 미적용
✅ 별도 규제 없음

권장 사항 (선택):
- API 키 암호화 저장
- HTTPS 통신
- 환경 변수 사용
- Git에 API 키 노출 금지
```

---

**Step 3: 조사 결과 정리**

**정리 형식**:
```markdown
## L3-Q1: 기술 스택 제약

### 외부 제약 (확정)
✅ 증권사: 한국투자증권
✅ API 방식: REST + WebSocket
✅ Rate Limit: 초당 20건 (실전), 2건 (모의)
✅ WebSocket: 1세션 41건
✅ 인증: 토큰 기반 (TTL 1시간)
✅ OS: 크로스 플랫폼
✅ 비용: 무료

필수 구현 사항:
- 요청 큐잉 시스템 (Redis Queue)
- Throttling (초당 20건 제한)
- WebSocket 구독 관리 (최대 41건)
- 토큰 갱신 자동화

선택 가능 (제약 내):
- 백엔드: FastAPI / NestJS
- 프론트: Next.js + React
- 데이터: Redis, PostgreSQL
```

**참고 문서**:
- `docs/session-summaries/20251112_Layer3_외부제약조사.md` (680줄)
  - 증권사 6개 상세 비교
  - 법적 규제 조사 과정
  - 개인 vs 서비스 구분

---

### 4.2 L3-Q2: 팀 역량

#### 왜 팀 역량을 확인하는가?

**목적**:
```
아무리 좋은 기술이라도
팀이 구현할 수 없으면 무용지물

→ 팀 역량 내에서 선택해야 함
```

#### 확인 항목

**팀 구성**:
```
- 백엔드: 몇 명? 기술 스택?
- 프론트엔드: 몇 명? 기술 스택?
- 인프라: 전담 인력 있나?
- 도메인 경험: 있나? 없나?
```

**기술 역량**:
```
✅ 확실히 가능:
- 일반 웹 개발 (CRUD)
- REST API
- 데이터베이스 (SQL)

❓ 학습 필요:
- WebSocket (비동기 처리)
- Redis Queue
- 도메인 특수 사항 (금융 용어)

❌ 불가능:
- Kubernetes 운영
- 대규모 분산 시스템
- 복잡한 알고리즘 최적화
```

**주식 거래 플랫폼 예시**:
```
가정:
- 백엔드: 1-2명 (Python/Node.js 가능)
- 프론트엔드: 1명 (React 가능)
- 금융 도메인: 학습 필요

기술 선택:
✅ FastAPI (Python): 팀 역량 내
✅ WebSocket: 학습 가능
✅ Redis: 학습 가능
❌ Kafka, Kubernetes: 역량 초과
```

---

### 4.3 L3-Q3: 배포 환경

#### 확인 사항

**배포 위치**:
```
□ 클라우드 (AWS, Azure, GCP)
□ 온프레미스 (자체 서버)
□ 하이브리드
```

**환경 제약**:
```
□ OS 제약 (Linux, Windows)
□ 네트워크 제약 (내부망, 방화벽)
□ 데이터 저장 위치 제약 (국내, 해외)
□ 보안 인증 제약
```

**가용성 요구사항**:
```
□ 24/7 운영 필요?
□ 장애 허용 시간?
□ 백업/복구 전략?
```

**주식 거래 플랫폼 예시**:
```
배포 환경:
✅ 클라우드 (AWS/GCP) 가능
✅ 로컬 서버 가능
✅ Docker 컨테이너 가능

제약 사항:
✅ 한투 API = 크로스 플랫폼 OK
❌ 데이터 저장 위치 제약 없음 (개인 사용)
⚠️ 한국 리전 권장 (레이턴시)

가용성:
- 거래 시간 (9:00-15:30) 필수
- 24/7 필수 아님
- 고가용성 중요도: 중간
```

---

## Part 4 해설: 충돌 패턴 발견 및 해결

### 5.1 Q4-1: NFR 달성 가능성 분석

#### 왜 충돌이 발생하는가?

**근본 원인**:
```
Layer 2: 이상적 목표 설정
- "100% 정확하게!"
- "즉시 처리!"
- "무제한 확장!"

Layer 3: 현실적 제약 발견
- API 초당 20건 제한
- WebSocket 41개 제한
- 비용 제약

→ 이상 vs 현실 충돌!
```

**핵심 원칙**:
> **"충돌은 정상이다!"**
>
> - Layer 2에서 이상적 목표 설정
> - Layer 3에서 현실적 제약 발견
> - 충돌 발생 = 당연함!
>
> 중요한 것:
> - ✅ 충돌을 발견하는 것
> - ✅ 의식적으로 트레이드오프 결정
> - ✅ ADR로 결정 근거 문서화

#### 달성 가능성 분석 방법

**주식 거래 플랫폼 예시**:

**Step 1: Layer 2 목표 검토**
```
NFR 프로파일: A-B-B-A

L2-Q1: 정확성 A (100% 정확)
→ 조건 감지 오류 = 금전 손실
→ "70,000원 도달" 놓치면 안 됨

L2-Q4: 최신성 A (초 단위 즉시)
→ 호가 변동 즉시 반영
→ 조건 감지 즉시 체결
```

**Step 2: Layer 3 제약 확인**
```
외부 API 제약:
- Rate Limit: 초당 20건 (실전)
- Rate Limit: 초당 2건 (모의)
- WebSocket: 41개 동시 구독
```

**Step 3: 달성 가능성 판단**
```
✅ 달성 가능:
- 개별 거래 정확성 100%
  → API 자체가 보장
  → 문제 없음

- 체결 즉시성
  → WebSocket 즉시 알림
  → 문제 없음

⚠️ 제약 있음:
- 조건 감지 빈도 제한
  → 100개 종목 × 1초마다 확인 = 100건/초
  → API 20건/초 제한 초과!
  → 불가능!

- 동시 감시 종목 수 제한
  → 100개 종목 실시간 감시
  → WebSocket 41개 제한 초과!
  → 불가능!
```

**결론**:
```
⚠️ 부분적 달성 가능

✅ 가능한 것:
- 핵심 기능 자체는 달성 가능
- 개별 거래의 정확성·즉시성 OK

⚠️ 제약이 있는 것:
- 대규모 감시는 제약 존재
- 트레이드오프 필요!
```

---

### 5.2 Q4-2: 충돌 매트릭스 작성

#### 충돌 식별 방법

**주식 거래 플랫폼 사례**:

**충돌 #1: 정확성 A vs API Rate Limit**

```
목표 (L2-Q1):
- 정확성 A → 모든 조건을 100% 정확히 감지

현실 (L3):
- 초당 20건 제한 (실전)
- 초당 2건 제한 (모의)

충돌:
❌ 100개 조건을 초당 체크하려면?
   → 100건/초 필요 vs 20건/초 제한
   → 불가능!

영향:
- 조건 체크 주기가 길어짐 (5초마다)
- 조건 만족 시점 감지 지연 가능
- 빠른 시장 변동 시 놓칠 위험

심각도: 🔴 높음
```

**충돌 #2: 즉시성 A vs WebSocket 구독 제한**

```
목표 (L2-Q4):
- 최신성 A → 호가 변동 즉시 반영

현실 (L3):
- WebSocket 41개 동시 구독 제한

충돌:
❌ 100개 종목을 실시간 감시하려면?
   → 100개 구독 필요 vs 41개 제한
   → 불가능!

영향:
- 전체 종목 실시간 감시 불가
- 우선순위 높은 41개만 WebSocket
- 나머지는 Polling (정확성·즉시성 하락)

심각도: 🔴 높음
```

**충돌 #3: 모의투자 vs 실전 투자 성능 차이**

```
목표:
- 모의투자로 전략 검증 후 실전 투자

현실:
- 모의투자: 초당 2건 제한 ⚠️
- 실전투자: 초당 20건 제한
- 10배 차이!

충돌:
❌ 모의투자 검증 결과를 실전에 적용 가능한가?
   → 제약이 달라서 동작이 다를 수 있음!

영향:
- 모의에서 성공한 전략이 실전에서 실패 가능
- 모의에서 충분한 테스트 불가능
- 전략 검증의 신뢰도 하락

심각도: 🟡 중간
```

---

#### 충돌 매트릭스 정리

| 충돌 ID | Layer 2 목표 | Layer 3 제약 | 충돌 여부 | 영향 | 심각도 |
|---------|-------------|-------------|-----------|------|--------|
| #1 | 정확성 A (100%) | API 20건/초 | ✅ | 조건 감지 지연 | 🔴 높음 |
| #2 | 즉시성 A (초 단위) | WebSocket 41개 | ✅ | 감시 범위 제한 | 🔴 높음 |
| #3 | 전략 검증 신뢰 | 모의 2건/초 | ✅ | 검증 신뢰도 하락 | 🟡 중간 |
| #4 | 보안 B (암호화) | HTTPS 기본 | ❌ | 충돌 없음 | - |
| #5 | 규모 B (1만 명) | WebSocket 41개 | ✅ | 서비스화 시 부족 | 🟡 낮음 (개인 사용) |

---

### 5.3 Q4-3: 트레이드오프 결정

#### 트레이드오프란?

**정의**:
```
충돌 발생 시:
→ A를 얻으려면 B를 포기
→ B를 얻으려면 A를 포기
→ 또는 둘 다 일부만 달성

의식적으로 선택하는 것 = 트레이드오프
```

#### 주식 거래 플랫폼 사례

**트레이드오프 #1: 정확성 vs 감시 범위**

```
Option A: 정확성 우선
- WebSocket 41개 + Polling 최소화
- 감시 범위: 41개 종목만 100% 정확
- 나머지는 포기
- 장점: 핵심 종목 완벽 감시
- 단점: 감시 범위 제한

Option B: 범위 우선
- 100개 종목 모두 감시
- Polling (5초 주기) → 정확성 하락
- 빠른 변동 놓칠 위험
- 장점: 많은 종목 감시
- 단점: 정확성 하락

Option C: 균형 (권장) ⭐
- 핵심 20개: WebSocket (1초)
- 일반 30개: Polling (5초)
- 저우선순위: 미감시
- 장점: 정확성 + 범위 균형
- 단점: 복잡도 증가

→ ADR #1 작성 필요!
```

**트레이드오프 #2: 즉시성 vs 비용**

```
Option A: 즉시성 최대화
- 조건 체크 주기 짧게 (1초)
- API 호출 많음 → Rate Limit 도달
- 추가 비용 발생 가능 (유료 플랜)
- 장점: 빠른 감지
- 단점: 비용 증가

Option B: 비용 최소화
- 조건 체크 주기 길게 (5초)
- API 호출 적음 → 무료 플랜
- 즉시성 하락 (5초 지연)
- 장점: 비용 절감
- 단점: 감지 지연

Option C: 하이브리드 (권장) ⭐
- 중요 조건: 1초 주기
- 일반 조건: 5초 주기
- 우선순위 동적 조정
- 장점: 비용 + 즉시성 균형
- 단점: 복잡도 증가

→ ADR #2 작성 필요!
```

**트레이드오프 #3: 복잡도 vs 성능**

```
Option A: 단순 구조
- Queue 없이 직접 API 호출
- 구현 간단
- Rate Limit 초과 시 실패
- 장점: 빠른 개발
- 단점: 안정성 낮음

Option B: 복잡한 구조 (권장) ⭐
- Redis Queue + Throttling
- 구현 복잡
- Rate Limit 보장, 안정성 향상
- 장점: 안정성 높음
- 단점: 개발 시간 증가

→ ADR #3 작성 필요!
```

---

#### ADR 작성 대상

**3개 ADR 필요**:
```
ADR #1: WebSocket + Polling 하이브리드 전략
- 문제: 정확성 A + 즉시성 A vs API 제한
- 옵션: 정확성 우선 / 범위 우선 / 균형
- 결정: 균형 (핵심 20개 WebSocket + 나머지 Polling)
- 근거: 핵심 기능 정확성 유지 + 확장성

ADR #2: 우선순위 기반 조건 감시
- 문제: 즉시성 vs 비용
- 옵션: 즉시성 우선 / 비용 우선 / 하이브리드
- 결정: 하이브리드 (중요도 기반 주기 조정)
- 근거: 비용 효율 + 핵심 기능 보장

ADR #3: Redis Queue 기반 Rate Limiting
- 문제: 복잡도 vs 안정성
- 옵션: 단순 / 복잡
- 결정: 복잡 (Redis Queue + Throttling)
- 근거: 금융 거래 = 안정성 최우선
```

---

## 🎁 핵심 교훈

### 1. 핵심 기능 구분이 출발점

```
잘못 구분하면:
→ Layer 1 답변 혼란
→ 아키텍처 패밀리 선택 혼란
→ 전체 설계 틀어짐

올바르게 구분하면:
→ Layer 1 일관된 답변
→ 명확한 아키텍처 결정
→ 통합된 설계 가능
```

### 2. Layer 3 조사가 필수

```
특히 이런 도메인:
- 금융 (API 제한, 규제)
- 의료 (규제, 인증)
- 정부 (보안, 규제)
- 외부 API 의존

→ Layer 3 없이는 설계 불가능!
→ 외부 제약이 아키텍처를 결정!
```

### 3. 충돌은 정상이다

```
Layer 2: 이상적 목표
Layer 3: 현실적 제약
→ 충돌은 당연함!

중요한 것:
✅ 충돌을 발견하는 것
✅ 트레이드오프를 의식적으로 결정하는 것
✅ ADR로 결정 근거를 남기는 것
```

### 4. ADR은 모든 중요 결정에 대해

```
ADR 작성 대상:
✅ 트레이드오프 결정
✅ 기술 스택 선택
✅ 아키텍처 패턴 선택
✅ **제약도 ADR이다!** ⭐

예시:
- "한국투자증권을 선택한 이유"
- "WebSocket + Polling 하이브리드를 선택한 이유"
- "Redis Queue를 도입한 이유"
```

---

## 참고 문서

- **가이드**: `02_ARCHITECTURE_DECISION_GUIDE.md`
- **실전 사례**: `02-2_IMPLEMENTATION_CASES.md`
- **Phase 2 기록**: `docs/session-summaries/20251112_Phase2_복합시스템_도전.md` (1,770줄)
- **핵심 기능 판단**: `docs/session-summaries/20251112_핵심기능_판단기준.md` (240줄)
- **Layer 3 조사**: `docs/session-summaries/20251112_Layer3_외부제약조사.md` (680줄)

---

**버전 이력**:
- v2.0 (2025-11-12): Part 0 추가, Part 4 충돌 패턴 추가
- v1.0 (2025-11-11): 초기 작성
