# 구조설계 가이드 (Structure Design Guide)

> **목적**: Stage 2 - 환경 제약 조사와 구현 결정 요소 목록 만들기
>
> **버전**: v1.0 (2025-11-12)
> - v1.0: Stage 2 신규 작성 (Layer 3 + 충돌 + 5단계)

---

## 📚 이 가이드의 구성

- **이 문서** (Guide): 질문 템플릿 + 작업 체크리스트 (간결)
- **해설서** (Manual): 왜? 어떻게? 상세 설명 → `02-1_STRUCTURE_DESIGN_MANUAL.md`
- **사례집** (Cases): 전체 흐름 실전 예시 → `IMPLEMENTATION_CASES.md`

---

## 📍 전체 프로세스에서의 위치

```
전체 프로세스:
Stage 0: 아이디어
Stage 1: 패밀리 구분 (01_CORE_DEFINITION_GUIDE.md) ✅
Stage 2: 구조설계 ← 이 가이드 ⭐
Stage 3: ADR 문서화 (03_ADR_GUIDE.md)
Stage 4-9: Bootstrap → Blueprint → 분해 → 구현
```

---

## Stage 1에서 받은 입력

Stage 1 완료 후 확정된 것:
- ✅ **패밀리** (예: A-C-A) → 필수 기술 방향
- ✅ **핵심 기능** (예: 거래) → 구현 후보군
- ✅ **NFR 프로파일** (예: A-B-B-A) → 품질 우선순위

Stage 2의 목표:
- 🔄 **Layer 3 조사** → 외부 제약 파악
- 🔄 **충돌 패턴 발견** → NFR vs 제약
- 🔄 **5단계 구현방법** → 기술 스택 확정
- 🔄 **결정 요소 목록** → ADR 준비

---

## Part 1: Layer 3 - 환경 제약 조사 ⭐⭐⭐

### 🎯 목표

**외부 제약 조건 파악** (실제 조사 필요!):
- 외부 API/서비스 제약
- 보안/컴플라이언스 요구사항
- 배포 환경 제약

### ⚠️ 핵심 원칙: Layer 3가 아키텍처를 결정한다!

```
Phase 2 주식 거래 플랫폼에서 발견:
"금융 거래는 일반 시스템과 완전히 다르다!"

→ 증권사 API 사용 조건 조사 필요
→ 법적 규제 조사 필요
→ 제공자마다 조건이 다름!

→ Layer 3 없이는 설계 불가능!
```

---

### L3-Q1: 외부 API/서비스 제약은? (외부 조사!)

#### Step 1: 외부 제약이 있는 도메인인가?

**체크 질문**:
```
□ 외부 API/서비스를 사용하는가?
□ 금융, 의료, 정부 등 규제 도메인인가?
□ 여러 제공자(증권사, 결제사 등) 중 선택이 필요한가?
□ 사용 제한(Rate Limit, 비용, 조건)이 있을 가능성이 있는가?
```

**하나라도 Yes → 외부 제약 조사 필수!**

#### Step 2: 무엇을 조사해야 하는가?

**주식 거래 플랫폼 예시**:
```
1. 증권사 API 비교
   □ 한국투자증권, 키움증권, 이베스트증권 등
   □ API 방식 (REST vs COM/DLL)
   □ Rate Limit (초당 몇 건?)
   □ OS 제약 (Windows vs 크로스플랫폼)
   □ 비용

2. 법적 규제
   □ 개인 사용 규제
   □ 서비스 제공 시 인허가
   □ 데이터 보관 의무

3. 개인정보보호
   □ 본인 정보만 처리 시
   □ 타인 정보 처리 시
```

**상세 설명 및 조사 방법**: Manual 1.1절 참고

#### Step 3: 제약 사항 정리

**비교표 작성 예시** (증권사 6개 비교):
```
| 증권사 | Rate Limit | API 방식 | OS 제약 | 평가 |
|--------|------------|----------|---------|------|
| 한투 | 20건/초 | REST | 크로스 | ⭐⭐⭐ |
| 키움 | 5건/초 | COM/DLL | Windows | ⭐⭐ |
| 이베스트 | 10건/초 | REST | 크로스 | ⭐⭐ |

→ 증권사 선택이 아키텍처를 결정!
```

**상세 사례**: `docs/session-summaries/20251112_Layer3_외부제약조사.md` 참고

---

### L3-Q2: 보안/컴플라이언스 요구사항은?

#### 개인 개발자 vs 서비스 제공자 구분 ⭐

**올바른 구분**:

**서비스 제공자의 의무** (우리와 무관):
- 금융사: 거래 기록 10년 보관
- 병원: 환자 KYC 정보 관리
- 정부: 금융위원회 규제 준수

**개인 개발자/내부 시스템의 의무** (우리가 해야 함):
- [x] API 키 안전 저장 (환경변수, Secret Manager)
- [x] HTTPS 통신 (필수)
- [x] 거래/감사 로그 (자체 감사용)
- [x] 접근 제어 (필요시)

**상세 설명**: Manual 1.2절 참고

---

### L3-Q3: 배포 환경 제약은?

**확인 사항**:
```
개인 사용 프로젝트:
✅ 클라우드 (AWS, Azure, GCP) 가능
✅ 로컬 서버 가능
✅ Docker 컨테이너 가능

⚠️ 도메인별 제약 확인 필요:
- 금융: 증권사별 OS 제약
- 의료: 데이터 저장 위치 제약
- 정부: 보안 인증 제약
```

**선택지**:
- **온프레미스**: 완전한 제어, 보안 (금융, 의료, 정부)
- **클라우드**: 확장성, 관리 편의 (스타트업, SaaS)
- **하이브리드**: 유연성 (엔터프라이즈)

**상세 설명**: Manual 1.3절 참고

---

### 📋 Part 1 체크리스트

Layer 3 조사 완료 확인:

- [ ] 외부 API/서비스를 최소 3개 이상 비교했는가?
- [ ] Rate Limit, 비용, 플랫폼 제약을 확인했는가?
- [ ] 보안/규제 요구사항을 구분했는가? (우리 vs 외부)
- [ ] 배포 환경 제약을 확인했는가? (OS, 네트워크)
- [ ] 비교표를 작성했는가?

---

## Part 2: 충돌 패턴 발견 및 해결 ⭐⭐⭐

### 🎯 목표

**Layer 2 NFR vs Layer 3 제약 충돌 발견**:
- 충돌이 있는가?
- 트레이드오프가 필요한가?
- ADR 작성이 필요한가?

### ⚠️ 핵심 원칙: 충돌은 정상이다!

```
Layer 2: 이상적 목표 설정
Layer 3: 현실적 제약 발견
→ 대부분 충돌 발생!

→ 충돌을 발견하고 해결하는 게 아키텍처 결정의 핵심!
```

---

### Q2-1: Layer 2 NFR을 Layer 3 제약 내에서 달성 가능한가?

**주식 거래 플랫폼 예시**:
```
Layer 2 NFR:
- L2-Q1: 정확성 A (100% 정확)
- L2-Q4: 즉시성 A (초 단위)

Layer 3 제약:
- API 초당 20건

질문:
→ 초당 20건으로 100% 정확 + 즉시 감지 가능한가?
→ 관심 종목 50개 × 1초마다 확인 = 50건?
→ 불가능! 충돌 발생! ⚠️
```

**상세 설명**: Manual 2.1절 참고

---

### Q2-2: 어떤 NFR과 어떤 제약이 충돌하는가?

**충돌 매트릭스 작성**:
```
| Layer 2 NFR | Layer 3 제약 | 충돌? | 영향 |
|-------------|--------------|-------|------|
| 정확성 A | API 20건/초 | ✅ | 모든 조건 실시간 감지 불가 |
| 즉시성 A | API 20건/초 | ✅ | 모든 종목 동시 모니터링 not가 |
| 보안 B | HTTPS 기본 | ❌ | 충돌 없음 |
| 규모 B | WebSocket 41건 | ✅ | 서비스화 시 부족 |
```

**상세 설명**: Manual 2.2절 참고

---

### Q2-3: 트레이드오프가 필요한가?

**의사결정 필요**:
```
정확성 A vs API 20건/초:

옵션 1: 정확성 우선
- 우선순위 종목만 실시간 (20개)
- 나머지는 주기적 폴링 (느림)

옵션 2: 즉시성 우선
- 모든 종목 폴링 (50개)
- 2.5초마다 1회 확인

옵션 3: 균형
- 핵심 20개 실시간 (1초)
- 나머지 30개 주기적 (5초)

→ ADR 작성 필요!
```

**상세 설명**: Manual 2.3절 참고

---

### 📋 Part 2 체크리스트

- [ ] Layer 2 NFR 목표를 Layer 3 제약 내에서 달성 가능한가?
- [ ] 충돌하는 NFR과 제약을 모두 식별했는가?
- [ ] 충돌 매트릭스를 작성했는가?
- [ ] 각 충돌에 대한 트레이드오프 옵션을 정리했는가?
- [ ] ADR 작성이 필요한 중요한 결정이 있는가?

---

## Part 3: 5단계 구현방법 (Implementation Approach) ⭐

### 🎯 목표

**기술 스택 확정 및 아키텍처 설계**:
- 5단계 프로세스: 기능 → 속성 → 제약 → 기술 → 설계
- 속성 질문 (SEI ADD 원칙)
- 구체적 수치 도출

### ⚠️ 핵심 원칙: 속성 질문이 기술을 결정한다!

> **SEI ADD (Attribute-Driven Design)**:
>
> "얼마나 빨라야?" "몇 명?" "실패하면?"
>
> → 구체적 수치 → 기술 선택

---

### Step 1: 핵심 기능 → 속성 질문

**프로세스**:
```
핵심 기능 파악 (Stage 1에서)
    ↓
각 기능별 속성 질문
    ↓
구체적 수치 도출
```

**속성 질문 템플릿**:
```
성능:
- 얼마나 빨라야? (응답 시간)
- 몇 건 처리? (처리량, TPS)
- 몇 명 동시? (동시 사용자)

가용성:
- 다운타임 허용? (99.9%? 99.99%?)
- 실패 시 영향? (치명적? 복구 가능?)

확장성:
- 데이터 증가율? (일 100건? 1만 건?)
- 사용자 증가 예상? (월 10%? 100%?)

보안:
- 어떤 데이터? (극비? 민감? 공개?)
- 어떤 위협? (내부? 외부?)
```

**상세 설명**: Manual 3.1절 참고

---

### Step 2: 속성 → NFR 프로파일 재검증

**NFR 프로파일과 속성 질문 매핑**:
```
L2-Q1: 정확성 A
→ 속성: 100% 정확성 필요
→ 수치: 오류율 < 0.01%

L2-Q2: 규모 B (중규모)
→ 속성: 동시 사용자 수
→ 수치: 100-1,000명

L2-Q4: 즉시성 A
→ 속성: 응답 시간, 업데이트 주기
→ 수치: < 100ms, 1초마다
```

**상세 설명**: Manual 3.2절 참고

---

### Step 3: 제약 반영 (Layer 3)

**제약 통합**:
```
속성 목표:
- 응답 시간 < 100ms
- 100개 종목 실시간

Layer 3 제약:
- API Rate Limit: 20건/초
- OS: 크로스 플랫폼

현실적 목표:
- 우선순위 20개: < 100ms (WebSocket)
- 나머지 80개: 5초 주기 (Polling)
```

**상세 설명**: Manual 3.3절 참고

---

### Step 4: 기술 스택 선택

**패밀리별 기술 가이드라인**:

**A-A-A (CRUD/트랜잭션)**:
```
필수:
- RDBMS (PostgreSQL, MySQL)
- ACID 트랜잭션
- ORM (TypeORM, SQLAlchemy)

선택:
- 캐시: Redis
- 큐: RabbitMQ (비동기 작업)
```

**C-B-B (검색/추천)**:
```
필수:
- Vector DB (Milvus, Pinecone)
- 검색 엔진 (Elasticsearch)
- 임베딩 (OpenAI, HuggingFace)

선택:
- Feature Store
- A/B Testing
```

**A-C-A (실시간 트랜잭션)** ⭐:
```
필수:
- RDBMS (트랜잭션)
- WebSocket (실시간)
- 메시지 큐 (이벤트)
- 캐시 (성능)

선택:
- CQRS (읽기/쓰기 분리)
- Event Sourcing
```

**상세 설명**: Manual 3.4절 참고

---

### Step 5: 아키텍처 설계

**설계 요소**:
```
1. 시스템 구조
   - 모놀리식 vs MSA
   - 레이어 구조 (3-tier, Hexagonal)

2. 데이터 흐름
   - 동기 vs 비동기
   - 이벤트 기반 vs 요청/응답

3. 통신 패턴
   - REST vs GraphQL vs gRPC
   - WebSocket vs Polling

4. 상태 관리
   - Stateless vs Stateful
   - 세션 관리

5. 배포 전략
   - 단일 서버 vs 분산
   - 컨테이너화 (Docker)
```

**상세 설명**: Manual 3.5절 참고

---

### 📋 Part 3 체크리스트

- [ ] 핵심 기능별로 속성 질문을 작성했는가?
- [ ] 구체적 수치를 도출했는가? (응답 시간, TPS, 동시 사용자 등)
- [ ] Layer 3 제약을 반영하여 현실적 목표를 수정했는가?
- [ ] 패밀리에 맞는 기술 스택을 선택했는가?
- [ ] 아키텍처 다이어그램을 작성했는가?

---

## 📊 전체 프로세스 요약

```
Part 1: Layer 3 조사 ⭐⭐⭐
├─ L3-Q1: 외부 API/서비스 (비교 필수!)
├─ L3-Q2: 보안/컴플라이언스
└─ L3-Q3: 배포 환경
   ↓
Part 2: 충돌 패턴 발견 ⭐⭐⭐
├─ Q2-1: NFR 달성 가능한가?
├─ Q2-2: 어떤 충돌이 있는가?
└─ Q2-3: 트레이드오프 필요한가?
   ↓
Part 3: 5단계 구현방법 ⭐
├─ Step 1: 기능 → 속성 질문
├─ Step 2: 속성 → NFR 재검증
├─ Step 3: 제약 반영
├─ Step 4: 기술 스택 선택
└─ Step 5: 아키텍처 설계
   ↓
결과: 결정 요소 목록 + 기술 스택 + 아키텍처
```

---

## 🎁 핵심 교훈

### 1. Layer 3 조사가 필수

```
특히 이런 도메인:
- 금융 (API 제한, 규제)
- 의료 (규제, 인증)
- 정부 (보안, 규제)
- 외부 API 의존

→ Layer 3 없이는 설계 불가능!
→ 외부 제약이 아키텍처를 결정!
```

### 2. 충돌은 정상이다

```
Layer 2: 이상적 목표
Layer 3: 현실적 제약
→ 충돌은 당연함!

중요한 것:
✅ 충돌을 발견하는 것
✅ 트레이드오프를 의식적으로 결정하는 것
✅ ADR로 결정 근거를 남기는 것
```

### 3. 속성 질문이 기술을 결정

```
SEI ADD 원칙:
"얼마나?" "몇 명?" "언제?"

→ 구체적 수치
→ 기술 선택 가능
→ 아키텍처 확정
```

---

## 템플릿

### Part 1: Layer 3
```markdown
## Layer 3: 환경 제약

### L3-Q1: 외부 API/서비스
**비교표**:
| 제공자 | Rate Limit | API 방식 | OS 제약 | 비용 | 평가 |
|--------|------------|----------|---------|------|------|
| ... | ... | ... | ... | ... | ... |

**선택**: [제공자명]
**이유**: [...]

### L3-Q2: 보안/컴플라이언스
**우리의 의무**:
- [ ] API 키 안전 저장
- [ ] HTTPS 통신
- [ ] 감사 로그

**제외** (서비스 제공자 책임):
- 데이터 보관 의무
- KYC 인증
- 규제 준수

### L3-Q3: 배포 환경
**선택**: [온프레미스 / 클라우드 / 하이브리드]
**OS**: [Linux / Windows / 크로스]
**제약**: [...]
```

### Part 2: 충돌 패턴
```markdown
## 충돌 패턴

### 충돌 매트릭스
| Layer 2 NFR | Layer 3 제약 | 충돌? | 영향 |
|-------------|--------------|-------|------|
| ... | ... | ✅/❌ | ... |

### 트레이드오프 결정
**충돌 1**: [NFR] vs [제약]
- 옵션 1: [...]
- 옵션 2: [...]
- 선택: [...]
- 이유: [...]
- ADR 필요: ✅/❌
```

### Part 3: 5단계 구현
```markdown
## 5단계 구현방법

### Step 1: 속성 질문
**기능 1**: [기능명]
- 성능: 응답 시간 < [?]ms, TPS [?]
- 가용성: [?]%
- 확장성: 사용자 [?]명

### Step 4: 기술 스택
**백엔드**:
- 언어/프레임워크: [...]
- 데이터베이스: [...]
- 캐시: [...]
- 메시지 큐: [...]

**프론트엔드**:
- 프레임워크: [...]

### Step 5: 아키텍처
**시스템 구조**: [모놀리식 / MSA]
**통신 패턴**: [REST / WebSocket / ...]
**배포 전략**: [...]
```

---

## 다음 단계

**Stage 2 완료 후 → Stage 3: ADR 문서화**

Stage 2에서 결정된 내용:
- ✅ 외부 제약 파악 (API, 규제, 배포)
- ✅ 충돌 패턴 발견 (NFR vs 제약)
- ✅ 기술 스택 확정 (언어, DB, 프레임워크)
- ✅ 아키텍처 설계 (구조, 통신, 배포)

Stage 3에서 할 일:
- 🔄 모든 중요 결정에 대한 ADR 작성
- 🔄 제약도 ADR이다! (선택지가 1개여도 기록)
- 🔄 Bootstrap ADR vs 도메인 ADR 구분

**다음 문서**: `03_ADR_GUIDE.md`

---

## 참고 문서

- **상세 해설**: `02-1_STRUCTURE_DESIGN_MANUAL.md`
  - 왜 이 단계들인가?
  - 어떻게 조사하는가?
  - 충돌 패턴 상세 분석
  - 5단계 프로세스 상세

- **실전 사례**: `IMPLEMENTATION_CASES.md`
  - Case 1: Memory (CRUD/트랜잭션)
  - Case 2: BioNeX (검색/추천)
  - Case 3: BlueprintAI (협업/동기화)
  - Case 4: Stock Trading (실시간 트랜잭션) ⭐

- **이론적 근거**: `../ARCHITECTURE_THEORY_MAPPING.md`
  - SEI Attribute-Driven Design (ADD)
  - Quality Attributes
  - CAP Theorem

- **오늘 발견**:
  - `../session-summaries/20251112_Phase2_복합시스템_도전.md`
  - `../session-summaries/20251112_Layer3_외부제약조사.md`

---

**버전 이력**:
- v1.0 (2025-11-12): Stage 2 신규 작성 (Layer 3 + 충돌 + 5단계)
