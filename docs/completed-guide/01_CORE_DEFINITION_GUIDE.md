# 핵심정의 가이드 (Core Definition Guide)

> **목적**: Stage 1 - 패밀리 구분과 핵심기능 파악 (큰 방향과 큰 틀만 잡기)
>
> **버전**: v3.0 (2025-11-12)
> - v3.0: Stage 구조 재정립 (Layer 3 → Stage 2로 이동)
> - v2.1: Part 0 추가, A-C-A 패밀리 추가
> - v2.0: 3-Layer Decision Tree 도입

---

## 📚 이 가이드의 구성

- **이 문서** (Guide): 질문 템플릿 + 작성 원칙 (간결)
- **해설서** (Manual): 왜? 어떻게? 상세 설명 → `01-1_CORE_DEFINITION_MANUAL.md`
- **사례집** (Cases): 전체 흐름 실전 예시 → `IMPLEMENTATION_CASES.md`

---

## Part 0: 핵심 기능 파악 ⭐

### Q0-1. 이 시스템의 존재 이유는 무엇인가?

**작성 원칙**:
- 가장 **원자적인 기능**만 파악하세요
- **구현 방식**을 별개의 기능으로 보면 안 됩니다
- **비즈니스 목적**으로 구분하세요

**예시**:
```
❌ 잘못된 구분:
   - 수동 거래 (핵심 기능 1)
   - 자동 거래 (핵심 기능 2)

✅ 올바른 구분:
   - 거래 (핵심 기능)
     ├─ 구현 방식 A: 수동
     └─ 구현 방식 B: 자동
```

**다른 예시**:
- AI 챗봇 + 외부메모리 (X) → AI 외부메모리 (CRUD) (O)
- 일반 검색 + AI 검색 (X) → 검색 (O)

**상세 설명**: Manual 1.2절 참고

---

### Q0-2. 핵심 기능이 실패하면 비즈니스에 어떤 영향을 주나?

**작성 원칙**:
- **구현 방식과 무관**하게 동일한 영향인지 확인
- 실패 = 금전 손실? 불편함? 데이터 손실?

**예시** (주식 거래):
```
수동 거래 실패: 클릭했는데 안 됨 → 금전 손실
자동 거래 실패: 조건 충족했는데 안 됨 → 금전 손실
→ 구현 방식 무관, 동일한 치명도! ✅
→ "거래" 1개가 핵심 기능 맞음
```

**상세 설명**: Manual 1.3절 참고

---

## Layer 1: 아키텍처 패밀리 식별

> **목표**: 시스템의 본질을 파악하여 6가지 패밀리 중 하나로 분류

---

### L1-Q1. 핵심 기능이 실패하면 얼마나 치명적인가?

**선택지**:
- **A (치명적)**: 시스템 가치 상실, 금전 손실, 데이터 손실
  - 예: 결제, 거래, 트랜잭션
- **B (중단·재시도)**: 일시 중단, 재연결하면 복구
  - 예: 스트리밍, 실시간 알림
- **C (점진적 저하)**: 부분 동작 가능, 품질만 저하
  - 예: 추천, 검색 순위

**상세 설명**: Manual 2.1절 참고

---

### L1-Q2. 핵심 기능이 다루는 정보는 어떤 형태인가?

**선택지**:
- **A (구조화)**: JSON, 테이블, 스키마
  - 예: 주문, 사용자, 상품
- **B (비구조화)**: 텍스트, 이미지, 자연어
  - 예: 문서, 채팅, 리뷰
- **C (숫자·분석)**: 시계열, 통계, 지표
  - 예: 주가, 센서 데이터, 매출

**상세 설명**: Manual 2.2절 참고

---

### L1-Q3. 핵심 기능은 언제 응답해야 하는가?

**선택지**:
- **A (즉각)**: 100ms 이내, 실시간 상호작용
  - 예: 체결, 게임, 채팅
- **B (조회 후)**: 1~3초, 검색 후 결과
  - 예: 검색, API 조회
- **C (배치)**: 분~시간, 주기적 처리
  - 예: 리포트, ETL, 분석

**상세 설명**: Manual 2.3절 참고

---

### 패밀리 결정

**6가지 아키텍처 패밀리**:

| 패밀리 | 패턴 | 특징 | 예시 |
|--------|------|------|------|
| 1. CRUD/트랜잭션 | A-A-A | 정확성 중심 | 문서 생성, 주문 |
| 2. 검색/추천 | C-B-B | 관련성 중심 | AI 검색, 추천 |
| 3. 실시간 스트리밍 | B-C-A | 지연시간 중심 | IoT, 센서 |
| 4. 협업/동기화 | B-A-A | 일관성 중심 | Google Docs |
| 5. 분석/배치 | C-C-C | 처리량 중심 | ETL, BI |
| 6. 실시간 트랜잭션 ⭐ | A-C-A | 정확성+즉시성 | 주식 거래, 금융 |

**상세 설명**: Manual 2.4절 참고

---

## Layer 2: NFR 우선순위

> **목표**: 품질 속성(Quality Attributes) 우선순위 결정

---

### L2-Q1. 핵심 품질은 무엇인가? (북극성)

**선택지**:
- **A (정확성)**: 100% 정확, 오류 불허
- **B (속도)**: 빠른 응답, 처리량
- **C (관련성)**: 맥락 이해, 품질

**상세 설명**: Manual 3.1절 참고

---

### L2-Q2. 예상 사용자 규모는?

**선택지**:
- **A (소규모)**: < 100명
- **B (중규모)**: 100 ~ 10,000명
- **C (대규모)**: > 10,000명

**상세 설명**: Manual 3.2절 참고

---

### L2-Q3. 데이터 노출 수준은?

**선택지**:
- **A (극비)**: 개인 금융, 의료
- **B (민감)**: 사용자 정보
- **C (공개)**: 공개 콘텐츠

**상세 설명**: Manual 3.3절 참고

---

### L2-Q4. 데이터 최신성은?

**선택지**:
- **A (즉시)**: 실시간 (ms~초)
- **B (준실시간)**: 분~시간
- **C (배치)**: 일~주

**상세 설명**: Manual 3.4절 참고

---

### NFR 프로파일 생성

**출력 형식**: `L2-Q1: A, L2-Q2: B, L2-Q3: B, L2-Q4: A` → **A-B-B-A**

**충돌 감지**:
- A (정확성) + A (즉시) → 가능하지만 비용 높음
- B (속도) + A (정확성) → 트레이드오프 필요

**상세 설명**: Manual 3.5절 참고

---

## 템플릿

### Part 0: 핵심 기능
```markdown
## 핵심 기능

### Q0-1: 존재 이유
- 핵심 기능: [기능명]
- 구현 방식: [A, B, C...]

### Q0-2: 실패 영향
- 영향: [금전 손실 / 불편함 / 데이터 손실]
- 치명도: [A / B / C]
```

### Layer 1: 패밀리
```markdown
## Layer 1: 아키텍처 패밀리

### L1-Q1: 실패 파급력
- 선택: [A / B / C]
- 이유: [...]

### L1-Q2: 정보 형태
- 선택: [A / B / C]
- 이유: [...]

### L1-Q3: 응답 시점
- 선택: [A / B / C]
- 이유: [...]

### 패밀리: [패밀리명] ([패턴])
```

### Layer 2: NFR
```markdown
## Layer 2: NFR 우선순위

### L2-Q1: 핵심 품질
- 선택: [A / B / C]

### L2-Q2: 규모
- 선택: [A / B / C]

### L2-Q3: 데이터 노출
- 선택: [A / B / C]

### L2-Q4: 최신성
- 선택: [A / B / C]

### NFR 프로파일: [A-B-B-A]
```

---

## 다음 단계

**Stage 1 완료 후 → Stage 2: 구조설계**

Stage 1에서 결정된 내용:
- ✅ 패밀리 (예: A-C-A) → 필수 기술 방향
- ✅ 핵심 기능 (예: 거래) → 구현 후보군
- ✅ NFR 프로파일 (예: A-B-B-A) → 품질 우선순위

Stage 2에서 할 일:
- 🔄 Layer 3 조사 (외부 제약, 내부 자원)
- 🔄 충돌 패턴 발견 (NFR vs 제약)
- 🔄 5단계 구현방법 (기능→속성→제약→기술→설계)
- 🔄 결정 요소 목록 작성

**다음 문서**: `02_STRUCTURE_DESIGN_GUIDE.md`

---

## 참고 문서

- **상세 해설**: `01-1_CORE_DEFINITION_MANUAL.md`
  - 왜 이 질문들인가?
  - 어떻게 답변하는가?
  - 6가지 패밀리 상세 설명

- **실전 사례**: `IMPLEMENTATION_CASES.md`
  - Case 1: Memory (CRUD/트랜잭션)
  - Case 2: BioNeX (검색/추천)
  - Case 3: BlueprintAI (협업/동기화)
  - Case 4: Stock Trading (실시간 트랜잭션) ⭐

- **이론적 근거**: `../ARCHITECTURE_THEORY_MAPPING.md`
  - SEI Quality Attributes
  - Martin Fowler Patterns
  - CAP Theorem

---

**버전 이력**:
- v3.0 (2025-11-12): Stage 구조 재정립 (Layer 3 → Stage 2로 이동)
- v2.1 (2025-11-12): Part 0 추가, A-C-A 패밀리 추가
- v2.0 (2025-11-11): 3-Layer Decision Tree 도입
- v1.0 (2025-11-10): 7가지 고정 질문
