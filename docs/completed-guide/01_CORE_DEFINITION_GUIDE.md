# 핵심정의 가이드 (Core Definition Guide)

> **목적**: 프로젝트의 "무엇을"과 "왜"를 3-Layer 질문으로 명확히 정의
>
> **버전**: v2.1 (2025-11-12)
> - v2.0: 3-Layer Decision Tree 도입
> - v2.1: Part 0 추가 (핵심 기능 판단 기준), A-C-A 패밀리 추가

---

## 📚 이 가이드의 구성

- **이 문서** (Guide): 질문 템플릿 + 작성 원칙 (간결)
- **해설서** (Manual): 왜? 어떻게? 상세 설명 → `01-1_CORE_DEFINITION_MANUAL.md`
- **사례집** (Cases): 전체 흐름 실전 예시 → `IMPLEMENTATION_CASES.md`

---

## Part 0: 핵심 기능 파악 ⭐

### Q0-1. 이 시스템의 존재 이유는 무엇인가?

**작성 원칙**:
- 가장 **원자적인 기능**만 파악하세요
- **구현 방식**을 별개의 기능으로 보면 안 됩니다
- **비즈니스 목적**으로 구분하세요

**예시**:
```
❌ 잘못된 구분:
   - 수동 거래 (핵심 기능 1)
   - 자동 거래 (핵심 기능 2)

✅ 올바른 구분:
   - 거래 (핵심 기능)
     ├─ 구현 방식 A: 수동
     └─ 구현 방식 B: 자동
```

**다른 예시**:
- AI 챗봇 + 외부메모리 (X) → AI 외부메모리 (CRUD) (O)
- 일반 검색 + AI 검색 (X) → 검색 (O)

**상세 설명**: Manual 1.2절 참고

---

### Q0-2. 핵심 기능이 실패하면 비즈니스에 어떤 영향을 주나?

**작성 원칙**:
- **구현 방식과 무관**하게 동일한 영향인지 확인
- 실패 = 금전 손실? 불편함? 데이터 손실?

**예시** (주식 거래):
```
수동 거래 실패: 클릭했는데 안 됨 → 금전 손실
자동 거래 실패: 조건 충족했는데 안 됨 → 금전 손실
→ 구현 방식 무관, 동일한 치명도! ✅
→ "거래" 1개가 핵심 기능 맞음
```

**상세 설명**: Manual 1.3절 참고

---

## Layer 1: 아키텍처 패밀리 식별

> **목표**: 시스템의 본질을 파악하여 6가지 패밀리 중 하나로 분류

---

### L1-Q1. 핵심 기능이 실패하면 얼마나 치명적인가?

**선택지**:
- **A (치명적)**: 시스템 가치 상실, 금전 손실, 데이터 손실
  - 예: 결제, 거래, 트랜잭션
- **B (중단·재시도)**: 일시 중단, 재연결하면 복구
  - 예: 스트리밍, 실시간 알림
- **C (점진적 저하)**: 부분 동작 가능, 품질만 저하
  - 예: 추천, 검색 순위

**상세 설명**: Manual 2.1절 참고

---

### L1-Q2. 핵심 기능이 다루는 정보는 어떤 형태인가?

**선택지**:
- **A (구조화)**: JSON, 테이블, 스키마
  - 예: 주문, 사용자, 상품
- **B (비구조화)**: 텍스트, 이미지, 자연어
  - 예: 문서, 채팅, 리뷰
- **C (숫자·분석)**: 시계열, 통계, 지표
  - 예: 주가, 센서 데이터, 매출

**상세 설명**: Manual 2.2절 참고

---

### L1-Q3. 핵심 기능은 언제 응답해야 하는가?

**선택지**:
- **A (즉각)**: 100ms 이내, 실시간 상호작용
  - 예: 체결, 게임, 채팅
- **B (조회 후)**: 1~3초, 검색 후 결과
  - 예: 검색, API 조회
- **C (배치)**: 분~시간, 주기적 처리
  - 예: 리포트, ETL, 분석

**상세 설명**: Manual 2.3절 참고

---

### 패밀리 결정

**6가지 아키텍처 패밀리**:

| 패밀리 | 패턴 | 특징 | 예시 |
|--------|------|------|------|
| 1. CRUD/트랜잭션 | A-A-A | 정확성 중심 | 문서 생성, 주문 |
| 2. 검색/추천 | C-B-B | 관련성 중심 | AI 검색, 추천 |
| 3. 실시간 스트리밍 | B-C-A | 지연시간 중심 | IoT, 센서 |
| 4. 협업/동기화 | B-A-A | 일관성 중심 | Google Docs |
| 5. 분석/배치 | C-C-C | 처리량 중심 | ETL, BI |
| 6. 실시간 트랜잭션 ⭐ | A-C-A | 정확성+즉시성 | 주식 거래, 금융 |

**상세 설명**: Manual 2.4절 참고

---

## Layer 2: NFR 우선순위

> **목표**: 품질 속성(Quality Attributes) 우선순위 결정

---

### L2-Q1. 핵심 품질은 무엇인가? (북극성)

**선택지**:
- **A (정확성)**: 100% 정확, 오류 불허
- **B (속도)**: 빠른 응답, 처리량
- **C (관련성)**: 맥락 이해, 품질

**상세 설명**: Manual 3.1절 참고

---

### L2-Q2. 예상 사용자 규모는?

**선택지**:
- **A (소규모)**: < 100명
- **B (중규모)**: 100 ~ 10,000명
- **C (대규모)**: > 10,000명

**상세 설명**: Manual 3.2절 참고

---

### L2-Q3. 데이터 노출 수준은?

**선택지**:
- **A (극비)**: 개인 금융, 의료
- **B (민감)**: 사용자 정보
- **C (공개)**: 공개 콘텐츠

**상세 설명**: Manual 3.3절 참고

---

### L2-Q4. 데이터 최신성은?

**선택지**:
- **A (즉시)**: 실시간 (ms~초)
- **B (준실시간)**: 분~시간
- **C (배치)**: 일~주

**상세 설명**: Manual 3.4절 참고

---

### NFR 프로파일 생성

**출력 형식**: `L2-Q1: A, L2-Q2: B, L2-Q3: B, L2-Q4: A` → **A-B-B-A**

**충돌 감지**:
- A (정확성) + A (즉시) → 가능하지만 비용 높음
- B (속도) + A (정확성) → 트레이드오프 필요

**상세 설명**: Manual 3.5절 참고

---

## Layer 3: 환경 제약사항

> **목표**: 기술 선택을 좁히는 외부 제약 파악

---

### L3-Q1. 필수 외부 API/서비스가 있는가?

**작성 원칙**:
- 증권사 API, 결제 게이트웨이 등
- **여러 옵션 비교** (Rate Limit, 비용, 플랫폼)

**예시** (주식 거래):
```
증권사 API 6개 비교:
- 한국투자증권: 20건/초, REST, 무료 ✅
- 키움증권: 5건/초, COM/DLL, Windows 전용
→ 선택: 한국투자증권 (크로스 플랫폼)
```

**상세 설명**: Manual 4.1절 참고

---

### L3-Q2. 보안/컴플라이언스 요구사항은?

**작성 원칙**:
- **개인 개발자 의무** vs 서비스 제공자 의무 구분
- API 키 관리, HTTPS, 로깅

**상세 설명**: Manual 4.2절 참고

---

### L3-Q3. 배포 환경 제약은?

**선택지**:
- 온프레미스 / 클라우드
- OS 제약 (Linux, Windows)
- 네트워크 제약

**상세 설명**: Manual 4.3절 참고

---

## 템플릿

### Part 0: 핵심 기능
```markdown
## 핵심 기능

### Q0-1: 존재 이유
- 핵심 기능: [기능명]
- 구현 방식: [A, B, C...]

### Q0-2: 실패 영향
- 영향: [금전 손실 / 불편함 / 데이터 손실]
- 치명도: [A / B / C]
```

### Layer 1: 패밀리
```markdown
## Layer 1: 아키텍처 패밀리

### L1-Q1: 실패 파급력
- 선택: [A / B / C]
- 이유: [...]

### L1-Q2: 정보 형태
- 선택: [A / B / C]
- 이유: [...]

### L1-Q3: 응답 시점
- 선택: [A / B / C]
- 이유: [...]

### 패밀리: [패밀리명] ([패턴])
```

### Layer 2: NFR
```markdown
## Layer 2: NFR 우선순위

### L2-Q1: 핵심 품질
- 선택: [A / B / C]

### L2-Q2: 규모
- 선택: [A / B / C]

### L2-Q3: 데이터 노출
- 선택: [A / B / C]

### L2-Q4: 최신성
- 선택: [A / B / C]

### NFR 프로파일: [A-B-B-A]

### 충돌 감지
- 충돌 1: [...]
- 충돌 2: [...]
```

### Layer 3: 제약
```markdown
## Layer 3: 환경 제약

### L3-Q1: 외부 API/서비스
- 선택: [API명]
- 이유: [...]

### L3-Q2: 보안/컴플라이언스
- 요구사항: [...]

### L3-Q3: 배포 환경
- 환경: [...]
- 제약: [...]
```

---

## 다음 단계

**핵심정의 완료 후**:
1. **구현방법** (Implementation Approach)
   - 5단계 프로세스
   - 속성 질문 → 구체적 수치

2. **ADR** (Architecture Decision Records)
   - 모든 결정에 대한 "왜?"
   - 제약도 ADR이다!

---

## 참고 문서

- **상세 해설**: `01-1_CORE_DEFINITION_MANUAL.md`
  - 왜 이 질문들인가?
  - 어떻게 답변하는가?
  - 6가지 패밀리 상세 설명

- **실전 사례**: `IMPLEMENTATION_CASES.md`
  - Case 1: Memory (CRUD/트랜잭션)
  - Case 2: BioNeX (검색/추천)
  - Case 3: BlueprintAI (협업/동기화)
  - Case 4: Stock Trading (실시간 트랜잭션) ⭐

- **이론적 근거**: `../ARCHITECTURE_THEORY_MAPPING.md`
  - SEI Quality Attributes
  - Martin Fowler Patterns
  - CAP Theorem

---

**버전 이력**:
- v2.1 (2025-11-12): Part 0 추가, A-C-A 패밀리 추가
- v2.0 (2025-11-11): 3-Layer Decision Tree 도입
- v1.0 (2025-11-10): 7가지 고정 질문
