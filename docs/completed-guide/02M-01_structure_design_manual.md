# 구조설계 해설서 (Structure Design Manual)

> **목적**: Stage 2 가이드의 상세 해설 - Layer 3, 충돌 패턴, 5단계 구현방법
>
> **버전**: v1.0 (2025-11-12)
> - v1.0: Stage 2 Manual 신규 작성 (Layer 3 내용 통합)

---

## 📚 참고

- **가이드**: `02_STRUCTURE_DESIGN_GUIDE.md`
- **사례집**: `IMPLEMENTATION_CASES.md`
- **이론적 근거**: `../ARCHITECTURE_THEORY_MAPPING.md`

---

## 목차

1. [Part 1: Layer 3 - 환경 제약 조사](#1-part-1-layer-3---환경-제약-조사)
2. [Part 2: 충돌 패턴 발견](#2-part-2-충돌-패턴-발견)
3. [Part 3: 5단계 구현방법](#3-part-3-5단계-구현방법)

---

## 1. Part 1: Layer 3 - 환경 제약 조사

### 1.1 왜 Layer 3가 필요한가?

#### 외부 제약이 아키텍처를 80% 결정

> **발견** (2025-11-12): Phase 2 주식 거래 플랫폼 분석

**핵심 통찰**:
```
증권사 선택 = 아키텍처 결정!

한국투자증권 선택 시:
- Rate Limit: 20건/초
- API: REST + WebSocket
- OS: Linux/Windows/Mac (크로스 플랫폼)
- 배포: Docker, Cloud 가능
→ Python, Node.js, Java 선택 가능

키움증권 선택 시:
- Rate Limit: 5건/초 (4배 느림!)
- API: COM/DLL (Windows 전용)
- OS: Windows Server 필수
- 배포: 온프레미스
→ C++, C# 전용, 클라우드 불가
```

**결론**:
- 외부 API 1개 선택 = 기술 스택 80% 결정
- Layer 3 조사 = 가장 중요한 실전 작업!

---

#### Layer 3의 역할

**위치**:
```
Stage 1: 패밀리 구분
├─ Layer 1: 패밀리 (이상적 목표)
└─ Layer 2: NFR (품질 우선순위)
    ↓
Stage 2: 구조설계
├─ Layer 3: 환경 제약 (현실적 제약) ← 여기!
├─ 충돌 패턴 발견
└─ 5단계 구현방법 (기술 선택)
```

**목표**:
1. **외부 제약 파악**: API, 규제, 인프라
2. **기술 후보 좁히기**: 불가능한 선택지 제거
3. **충돌 조기 발견**: Layer 2 vs Layer 3

---

### 1.2 L3-Q1: 외부 API/서비스 상세

#### 왜 비교가 필요한가?

**문제**:
- "이 API 쓰면 되겠지" → 나중에 문제 발견
- Rate Limit, 비용, 플랫폼 제약 간과

**해결**:
- **최소 3개 이상 비교**
- 체계적 비교 (표로 정리)

---

#### 비교 방법

> **출처**: `docs/session-summaries/20251112_Layer3_외부제약조사.md`

**주식 거래 플랫폼 사례**:

**비교표**:
| 증권사 | Rate Limit | API 방식 | 개인 사용 | 플랫폼 | 추천도 |
|--------|-----------|---------|----------|--------|--------|
| 한국투자증권 | 20건/초 | REST + WS | ✅ 무료 | 크로스 | ⭐⭐⭐ |
| 키움증권 | 5건/초 | COM/DLL | ✅ 무료 | Windows | ⭐⭐ |
| 이베스트 | 10건/초 | REST + WS | ✅ 무료 | 크로스 | ⭐⭐ |
| 삼성증권 | - | - | ❌ 불가 | - | ❌ |

**비교 항목**:
1. **Rate Limit**: 초당 요청 수
2. **API 방식**: REST, WebSocket, gRPC 등
3. **비용**: 무료, 유료, 종량제
4. **플랫폼**: OS 제약 (Linux, Windows, Mac)
5. **문서화**: 품질, 예제 코드
6. **SDK**: 언어별 지원
7. **SLA**: 가용성 보장

**선택 과정**:
```
1차 필터: 개인 사용 가능? (3개 남음)
2차 필터: 플랫폼 제약? (크로스 플랫폼 2개)
3차 비교: Rate Limit (한투 20 > 이베스트 10)
→ 선택: 한국투자증권 ✅
```

---

#### 외부 API가 결정하는 것

**아키텍처**:
```
REST API → 동기식 설계 가능
WebSocket → 실시간 스트리밍 필요
gRPC → 고성능 통신
GraphQL → 유연한 쿼리
```

**기술 스택**:
```
Python SDK → Python 선택
Java Only → Java 필수
COM/DLL → Windows + C++/C#
```

**배포 환경**:
```
Cloud API → Docker, K8s 가능
On-Premise → 서버 직접 운영
Windows Only → Linux 배포 불가
```

**확장 전략**:
```
Rate Limit 높음 → 단순 구조
Rate Limit 낮음 → 큐, 캐싱 필수
```

---

### 1.3 L3-Q2: 보안/컴플라이언스 상세

#### 개인 개발자 vs 서비스 제공자 구분 ⭐

> **발견** (2025-11-12): Jason의 중요한 지적

**Jason의 지적**:
```
❌ 2호의 착각:
"개인 개발자가 거래 기록 10년 보관?"

✅ Jason의 수정:
"그건 증권회사가 지켜야 하는 규제!"
```

**올바른 구분**:

**서비스 제공자의 의무** (우리와 무관):
- 거래 기록 10년 보관 (증권사)
- 투자자 KYC 정보 관리 (증권사)
- 금융위원회 규제 준수 (증권사)
- 개인정보 암호화 저장 (증권사)
- 자금세탁방지 AML (증권사)

**개인 개발자/내부 시스템의 의무** (우리가 해야 함):
- ✅ API 키 안전 저장
  - 환경변수 (.env)
  - Secret Manager (AWS Secrets Manager, Vault)
- ✅ HTTPS 통신 (필수)
  - 증권사 API 자체 암호화 제공
- ✅ 거래 로그 (자체 감사용)
  - 내 거래 이력 보관
  - 버그 추적, 세금 신고 용도

---

#### 규제별 요구사항

**금융 규제 (개인용)**:
```
적용: 자본시장법
- API 키 유출 방지 (본인 책임)
- 무단 거래 방지
- 개인 정보 보호

미적용 (증권사 책임):
- 거래 기록 보관
- KYC 인증
- 자금세탁방지
```

**의료 규제 (HIPAA)**:
```
적용:
- 환자 데이터 암호화
- 접근 제어 (RBAC)
- 감사 로그

규제 수준:
- L2-Q3: A (극비)
```

**개인정보 보호 (GDPR)**:
```
적용:
- 동의 관리
- 데이터 삭제권
- 데이터 이동권

영향:
- DB 설계 (soft delete)
- API 엔드포인트 추가
```

---

### 1.4 L3-Q3: 배포 환경 상세

#### 선택지

**온프레미스**:
- **장점**: 완전한 제어, 보안
- **단점**: 운영 부담, 확장 어려움
- **적용**: 금융, 의료, 정부

**클라우드 (Public)**:
- **장점**: 확장성, 관리 편의
- **단점**: 비용, 벤더 종속
- **적용**: 스타트업, SaaS

**하이브리드**:
- **장점**: 유연성
- **단점**: 복잡도
- **적용**: 엔터프라이즈

---

#### OS 제약

**Linux 선호**:
```
장점:
- 클라우드 기본 OS
- 오픈소스 생태계
- 비용 (라이선스 무료)

제약:
- Windows API 의존 시 불가
- COM/DLL 사용 시 불가
```

**Windows 필수**:
```
케이스:
- .NET Framework (레거시)
- COM/DLL API (키움증권)
- Active Directory 연동

영향:
- 클라우드: Windows Server (비용 2배)
- Docker: Windows Container (복잡)
```

**크로스 플랫폼** (이상적):
```
기술:
- Python, Node.js, Java
- REST API
- Docker

장점:
- CI/CD 간소화
- 개발 환경 유연
```

---

#### 네트워크 제약

**방화벽**:
```
제약:
- 아웃바운드 차단
- 특정 포트만 허용

영향:
- VPN 필요
- Proxy 설정
```

**대역폭**:
```
제약:
- 저속 (< 10Mbps)
- 불안정

영향:
- 실시간 스트리밍 불가
- Polling 방식 선택
```

---

## 2. Part 2: 충돌 패턴 발견

### 2.1 충돌 패턴이란?

**정의**:
```
Layer 2 NFR (이상적 목표)
    vs
Layer 3 제약 (현실적 한계)

→ 두 레이어가 충돌!
```

**예시**: 주식 거래 플랫폼
```
Layer 2 NFR:
- 정확성 A (100% 정확)
- 즉시성 A (초 단위)

Layer 3 제약:
- API Rate Limit: 20건/초

충돌:
- 50개 종목 × 1초마다 = 50건
- Rate Limit 20건/초
→ 불가능! ⚠️
```

---

### 2.2 충돌 매트릭스 작성

**템플릿**:
```
| Layer 2 NFR | Layer 3 제약 | 충돌? | 영향 |
|-------------|--------------|-------|------|
| ... | ... | ✅/❌ | ... |
```

**주식 거래 플랫폼 예시**:
```
| Layer 2 NFR | Layer 3 제약 | 충돌? | 영향 |
|-------------|--------------|-------|------|
| 정확성 A | API 20건/초 | ✅ | 모든 조건 실시간 감지 불가 |
| 즉시성 A | API 20건/초 | ✅ | 50개 종목 동시 모니터링 불가 |
| 보안 B | HTTPS 기본 | ❌ | 충돌 없음 |
| 규모 B | WebSocket 41건 | ⚠️ | 서비스화 시 재검토 |
```

---

### 2.3 트레이드오프 결정

**충돌 발견 시 옵션**:

**옵션 1: NFR 완화**
```
정확성 A → B (99.9%)
즉시성 A → B (5초)

장점: 구현 단순
단점: 품질 저하
```

**옵션 2: 아키텍처 복잡화**
```
하이브리드 전략:
- 우선순위 종목 20개: WebSocket (1초)
- 나머지 30개: Polling (5초)

장점: NFR 유지
단점: 복잡도 증가, 비용 증가
```

**옵션 3: 범위 축소**
```
MVP: 20개 종목만 지원
추후: 확장

장점: 빠른 출시
단점: 기능 제한
```

**주식 거래 플랫폼 선택**:
```
선택: 옵션 2 (하이브리드)
이유:
- 정확성 A는 타협 불가 (금전 손실)
- 즉시성 A는 핵심 종목만 필수
- 사용자 우선순위 설정 기능 제공

→ ADR-102로 기록!
```

---

## 3. Part 3: 5단계 구현방법

### 3.1 Step 1: 기능 → 속성 질문

> **출처**: SEI Attribute-Driven Design (ADD)

**프로세스**:
```
핵심 기능 파악 (Stage 1에서)
    ↓
각 기능별 속성 질문
    ↓
구체적 수치 도출
```

**속성 질문 템플릿**:
```
성능:
- 얼마나 빨라야? (응답 시간)
- 몇 건 처리? (처리량, TPS)
- 몇 명 동시? (동시 사용자)

가용성:
- 다운타임 허용? (99.9%? 99.99%?)
- 실패 시 영향? (치명적? 복구 가능?)

확장성:
- 데이터 증가율? (일 100건? 1만 건?)
- 사용자 증가 예상? (월 10%? 100%?)

보안:
- 어떤 데이터? (극비? 민감? 공개?)
- 어떤 위협? (내부? 외부?)
```

**주식 거래 플랫폼 예시**:
```
성능:
- 거래 요청 응답: < 100ms
- 조건 감지 주기: 1초 (우선순위) / 5초 (일반)
- 동시 모니터링: 50개 종목

가용성:
- 다운타임: < 0.1% (99.9%)
- 자동 재연결: 필수

확장성:
- 사용자: 1명 → 100명 (단계적)
- 종목: 50개 → 200개
```

---

### 3.2 Step 2: 속성 → NFR 재검증

**NFR 프로파일과 속성 질문 매핑**:
```
L2-Q1: 정확성 A
→ 속성: 100% 정확성 필요
→ 수치: 오류율 < 0.01%

L2-Q2: 규모 B (중규모)
→ 속성: 동시 사용자 수
→ 수치: 100-1,000명

L2-Q4: 즉시성 A
→ 속성: 응답 시간, 업데이트 주기
→ 수치: < 100ms, 1초마다
```

**검증**:
- NFR 프로파일 (A-B-B-A)이 구체적 수치와 일치하는가?
- 모순 없는가?

---

### 3.3 Step 3: 제약 반영 (Layer 3)

**제약 통합**:
```
속성 목표:
- 응답 시간 < 100ms
- 100개 종목 실시간

Layer 3 제약:
- API Rate Limit: 20건/초
- OS: 크로스 플랫폼

현실적 목표 수정:
- 우선순위 20개: < 100ms (WebSocket)
- 나머지 80개: 5초 주기 (Polling)
```

**중요**: 속성 목표를 제약 내로 조정!

---

### 3.4 Step 4: 기술 스택 선택

**패밀리별 기술 가이드라인**:

**A-A-A (CRUD/트랜잭션)**:
```
필수:
- RDBMS (PostgreSQL, MySQL)
- ACID 트랜잭션
- ORM (TypeORM, SQLAlchemy)

선택:
- 캐시: Redis
- 큐: RabbitMQ (비동기 작업)
```

**C-B-B (검색/추천)**:
```
필수:
- Vector DB (Milvus, Pinecone)
- 검색 엔진 (Elasticsearch)
- 임베딩 (OpenAI, HuggingFace)

선택:
- Feature Store
- A/B Testing
```

**A-C-A (실시간 트랜잭션)** ⭐:
```
필수:
- RDBMS (트랜잭션)
- WebSocket (실시간)
- 메시지 큐 (이벤트)
- 캐시 (성능)

선택:
- CQRS (읽기/쓰기 분리)
- Event Sourcing
```

**상세 기술 매트릭스**:
- 패밀리별 상세 옵션은 `docs/family-tech-matrix/` 참고
- 예: `05_real_time_streaming_tech_options.md`

---

### 3.5 Step 5: 아키텍처 설계

**설계 요소**:

**1. 시스템 구조**:
```
- 모놀리식 vs MSA
- 레이어 구조 (3-tier, Hexagonal, Clean)
```

**2. 데이터 흐름**:
```
- 동기 vs 비동기
- 이벤트 기반 vs 요청/응답
```

**3. 통신 패턴**:
```
- REST vs GraphQL vs gRPC
- WebSocket vs Polling
```

**4. 상태 관리**:
```
- Stateless vs Stateful
- 세션 관리
```

**5. 배포 전략**:
```
- 단일 서버 vs 분산
- 컨테이너화 (Docker)
- 오케스트레이션 (K8s, ECS)
```

**주식 거래 플랫폼 아키텍처**:
```
시스템 구조: 하이브리드

통신 패턴:
- WebSocket: 실시간 호가 (우선순위 종목)
- Polling: 주기적 확인 (일반 종목)
- REST: 거래 요청 (Rate Limit 관리)

상태 관리:
- Stateful: WebSocket 연결 유지
- Redis Queue: 거래 요청 순서 보장

배포 전략:
- 컨테이너: Docker
- 오케스트레이션: ECS
- 스케일링: 수평 확장 대비
```

---

## 4. Layer 2-3 통합 예시

### 사례: 주식 거래 플랫폼 (A-C-A)

#### Layer 2: NFR 프로파일

```
L2-Q1: A (정확성 100%)
- 조건 감지 오류 불허
- 체결 실패 = 금전 손실

L2-Q2: B (중규모)
- 개인용 (1-2명)
- 100개 종목 모니터링

L2-Q3: B (민감)
- API 키, 거래 내역
- 암호화 권장

L2-Q4: A (즉시)
- 호가 업데이트 < 100ms
- 체결 즉시 알림

→ NFR 프로파일: A-B-B-A
```

#### 충돌 감지

```
충돌 1: 정확성 A + 즉시성 A
- 100% 정확 + 100ms 응답
- 해결: 하이브리드 아키텍처

충돌 2: 즉시성 A vs Rate Limit 20건/초
- 100개 종목 > 20건 제한
- 해결: WebSocket + 우선순위 큐
```

#### Layer 3: 환경 제약

```
L3-Q1: 외부 API
- 한국투자증권 (20건/초, REST+WS)
- 선택 이유: 크로스 플랫폼, 무료

L3-Q2: 보안/규제
- API 키 환경변수
- HTTPS 통신 (API 자체)
- 거래 로그 (자체)

L3-Q3: 배포 환경
- Docker + AWS ECS
- Linux (크로스 플랫폼)
```

#### 최종 결정

```
기술 스택:
- Python 3.11+ (FastAPI)
- PostgreSQL (거래 기록)
- Redis (캐시 + 큐)
- WebSocket (실시간 호가)
- REST (거래 요청)

아키텍처:
- 하이브리드 (WebSocket + Polling)
- Rate Limiting (우선순위 큐)
- Human-in-the-loop (주문 검증)
```

---

## 참고 문서

- **가이드**: `02_STRUCTURE_DESIGN_GUIDE.md`
- **사례집**: `IMPLEMENTATION_CASES.md`
- **이론적 근거**: `../ARCHITECTURE_THEORY_MAPPING.md`
- **실전 발견**:
  - `../session-summaries/20251112_Phase2_복합시스템_도전.md`
  - `../session-summaries/20251112_Layer3_외부제약조사.md`

---

**버전**: v1.0 (2025-11-12)
- v1.0: Stage 2 Manual 신규 작성 (Layer 3 내용 통합)
