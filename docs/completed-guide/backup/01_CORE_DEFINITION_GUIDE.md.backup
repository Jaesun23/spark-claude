# 핵심정의 작성 가이드 (Core Definition Guide)

> **목적**: 프로젝트 시작 전, "무엇을" 만들 것인지 명확히 정의하는 방법
>
> **기반**:
> - [CORE_METHODOLOGY.md](./00_CORE_METHODOLOGY.md) 핵심정의 단계
> - Gemini 엔터프라이즈 리서치 (Amazon, Google 방법론)
> - 실제 사례 검증 (문서 생성, AI 외부메모리)
>
> **버전**: v2.0 (2025-11-11)
>
> **주요 변경**:
> - v1.0: 7가지 고정 질문
> - **v2.0**: 3-Layer Decision Tree (스무고개 방식) ⭐

---

## 목차

1. [개요](#1-개요)
2. [왜 필요한가?](#2-왜-필요한가)
3. [스무고개 방식 질문 구조](#3-스무고개-방식-질문-구조)
4. [Layer 1: 아키텍처 패밀리 식별](#4-layer-1-아키텍처-패밀리-식별)
5. [Layer 2: NFR 우선순위 + 충돌 감지](#5-layer-2-nfr-우선순위--충돌-감지)
6. [Layer 3: 환경 제약사항](#6-layer-3-환경-제약사항)
7. [실전 예시: 두 사례 비교](#7-실전-예시-두-사례-비교)
8. [작성 프로세스](#8-작성-프로세스)
9. [템플릿](#9-템플릿)
10. [다음 단계](#10-다음-단계)

---

## 1. 개요

### 1-1. 핵심정의란?

**핵심정의 (Core Definition)**는 프로젝트의 "무엇을"과 "왜"를 명확히 정의하는 단계입니다.

```
프로젝트 아이디어
    ↓
핵심정의 (Core Definition): What & Why ← 여기!
    ↓
구현방법 (Implementation Approach): How
    ↓
ADR: 기술 결정 (Which & Why)
    ↓
Blueprint: 구체적 설계
```

**v2.0의 핵심 변화**: 고정된 질문 → **스무고개 방식**

```
기존 v1.0:
□ Q1. 핵심 목표는?
□ Q2. 사용자는?
□ Q3. MVP는?
...
□ Q7. 아키텍처 제약은?

새로운 v2.0:
Layer 1 → 답변에 따라 분기
    ↓
Layer 2 → 충돌 감지 → 트레이드오프 질문
    ↓
Layer 3 → 기술 스택 좁히기
```

### 1-2. 왜 스무고개 방식인가?

**문제**: 모든 프로젝트에 동일한 7가지 질문?

```
채팅 앱과 배치 시스템이 같은 질문?
→ 비효율적
→ 중요한 질문 놓침
```

**해결**: 답변에 따라 다음 질문이 달라지는 구조

```
예시 1: 결정론적 시스템 (문서 생성)
L1-Q1: 틀리면? → A (치명적)
L1-Q2: 정보 형태? → A (구조화)
→ 다음: 정확성, 트랜잭션 중심 질문

예시 2: 확률론적 시스템 (AI 검색)
L1-Q1: 틀리면? → C (점진적)
L1-Q2: 정보 형태? → B (비구조화)
→ 다음: 관련성, 지연시간 중심 질문
```

### 1-3. 방법론에서의 위치

**Amazon 3단계 방법론과의 연결**:

```
핵심정의 = Amazon Stage 1: Identify Use Cases
    ↓
구현방법 = Amazon Stage 2: Specify Concrete Requirements
    ↓
ADR      = Amazon Stage 3: Select Tools & Infrastructure
```

**Carnegie Mellon SEI 원칙**:
> **"품질 속성(Quality Attributes)이 아키텍처를 주도한다"**
>
> 아키텍처는 기능이 아닌, **비기능 요구사항(NFRs)**에 의해 결정됩니다.

---

## 2. 왜 필요한가?

### 2-1. 실패 사례 분석

#### 사례 1: V3 - 목표 모호함
```
목표: "좋은 메모리 시스템" (추상적!)
    ↓
33개 필드 스키마 설계
    ↓
복잡도 폭발
    ↓
결과: 98% 완성, 0% 가치
```

**문제**: "좋은"이 무엇인지 정의 안 됨
**해결**: Layer 1에서 시스템 본질부터 파악

#### 사례 2: V5 - 환경만 100%
```
계획: "이번엔 환경부터 완벽히!"
    ↓
DNA 시스템 100% 완성
    ↓
실제 기능 0%
    ↓
결과: 통합 불가능
```

**문제**: MVP 정의 없음
**해결**: Layer 2에서 우선순위 명확화

#### 사례 3: BioNeX - 범위 폭발
```
아이디어: "AI 챗봇"
    ↓
챗봇 + 메모리 + 지식그래프 + ...
    ↓
300KB 문서, 코드 0줄
    ↓
결과: 할루시네이션 반복
```

**문제**: 범위 제한 없음
**해결**: Layer 2에서 트레이드오프 강제

### 2-2. v2.0이 해결하는 핵심 문제

**Gemini 리서치의 핵심 발견**:

> "누가, 언제, 어디서?"라는 질문은 **기능(Function)**에 초점을 맞추지만,
> 아키텍처는 **품질(Quality)**에 의해 결정된다.

**v2.0의 접근**:

```
1. 시스템 본질 파악 (Layer 1)
   - 결정론적 vs 확률론적
   - 구조화 vs 비구조화
   → 5가지 아키텍처 패밀리 분류

2. NFR 우선순위 (Layer 2)
   - 정확성 vs 속도 vs 보안 vs 비용
   - 충돌 감지 → 트레이드오프 질문
   → NFR 프로파일 생성

3. 기술 제약 (Layer 3)
   - 온프레미스 vs 클라우드
   - 레거시 연동 여부
   → 기술 스택 후보 좁히기
```

---

## 3. 스무고개 방식 질문 구조

### 3-1. 전체 구조 개요

```
┌─────────────────────────────────────────┐
│ Layer 1: 아키텍처 패밀리 식별 (3개 질문)   │
│ - 시스템의 본질 파악                      │
│ - 5가지 패밀리 중 하나로 분류             │
└─────────────────┬───────────────────────┘
                  ↓
┌─────────────────────────────────────────┐
│ Layer 2: NFR 우선순위 + 충돌 감지 (4개)   │
│ - 트레이드오프 결정                       │
│ - 불가능한 조합 감지 → 협상              │
└─────────────────┬───────────────────────┘
                  ↓
┌─────────────────────────────────────────┐
│ Layer 3: 환경 제약사항 (3개 질문)         │
│ - 기술 스택 후보 좁히기                   │
│ - Stage 2로 전달                         │
└─────────────────────────────────────────┘
```

### 3-2. 왜 Layer 구조인가?

**핵심 원리**: 각 Layer의 답변이 다음 Layer의 질문을 결정

**예시: AI 외부메모리 프로젝트**

```
Layer 1 답변:
L1-Q1: C (점진적 실패) → 확률론적
L1-Q2: B (비구조화) → 벡터 검색
L1-Q3: A (즉시) → 실시간
→ 패밀리: 검색/추천 시스템

Layer 2 질문 (패밀리에 따라 달라짐):
L2-Q1: 핵심 품질? → B (가장 빠름)
L2-Q4: 즉시 반영? → A (즉시)

충돌 감지!
L2-Q1(빠름) + L2-Q4(즉시) = 동기식 불가능!

트레이드오프 질문:
"최종일관성(수 초 지연)을 수용할 수 있나?"
→ Yes → Kafka + 비동기 Workers

Layer 3:
L3-Q2: 배포 제약? → D (제약 없음)
→ 기술 후보: Kafka, Milvus, Pinecone
```

### 3-3. 5가지 아키텍처 패밀리

Layer 1의 목표는 시스템을 다음 5가지 중 하나로 분류하는 것입니다:

| 패밀리 | 특징 | 예시 | 핵심 NFR |
|--------|------|------|----------|
| **CRUD/트랜잭션** | 결정론적, 구조화, 치명적 실패 | 문서 생성, 금융, ERP | 정확성(ACID), 무결성 |
| **검색/추천** | 확률론적, 비구조화, 점진적 실패 | AI 외부메모리, 검색엔진 | 관련성, 지연시간, 최신성 |
| **실시간 스트리밍** | 연속적, 시계열, 지연 민감 | 주식 거래, IoT, 모니터링 | 처리량, 순서 보장 |
| **분석/배치** | 비실시간, 대용량, 집계 | DW, BI, 리포팅 | 처리량, 비용 효율 |
| **협업/동기화** | 다중 사용자, 동시성, 충돌 해결 | Google Docs, Figma | 동시성, 충돌 해결 |

**패밀리가 결정하는 것**:
- Layer 2에서 어떤 NFR 질문을 할지
- Layer 3에서 어떤 기술을 고려할지
- Stage 2에서 어떤 속성 질문을 할지

---

## 4. Layer 1: 아키텍처 패밀리 식별

**목표**: 시스템의 본질을 파악해서 5가지 패밀리 중 하나로 분류

### 4-1. L1-Q1: 실패의 파급력

**질문**:
> **"이 시스템의 결과가 '틀리면' 무슨 일이 벌어지나?"**

**선택지**:
- **A: 치명적 피해** (법적 문제, 금전적 손실, 안전 문제)
  - 예: 법률 문서 오류, 금융 거래 오류, 의료 진단 오류
  - → **결정론적** 시스템 방향

- **B: 업무 중단/재시도 필요** (사용자 불만, 시간 낭비)
  - 예: 로그인 실패, 파일 업로드 실패
  - → **가용성** 중심 시스템

- **C: 차선의 결과 제공** (덜 유용한 답, 정확도 낮음)
  - 예: 검색 결과 관련성 낮음, 추천이 부정확함
  - → **확률론적** 시스템 방향

**왜 이 질문이 첫 번째인가?**

이 답변이 시스템의 **"본질"**을 결정합니다:
- A 선택 → 100% 정확성 필수 → CRUD/트랜잭션 패밀리
- C 선택 → "최선의 답" 찾기 → 검색/추천 패밀리

**예시**:

```
문서 생성 프로젝트:
Q: 계약서가 틀리면?
A: 치명적 (법적 문제) → A 선택

AI 외부메모리 프로젝트:
Q: 검색 결과가 틀리면?
A: 덜 유용한 답 (차선) → C 선택
```

---

### 4-2. L1-Q2: 정보의 형태

**질문**:
> **"시스템이 처리하는 '핵심 정보'는?"**

**선택지**:
- **A: 구조화됨** (숫자, 날짜, 고정 필드, JSON, XML)
  - 예: 주문 데이터, 사용자 프로필, 거래 내역
  - → CRUD/트랜잭션 처리

- **B: 비구조화됨** (자연어 텍스트, 문서, 이미지)
  - 예: 이메일, 보고서, 채팅 로그, PDF
  - → 검색/추천, 시맨틱 처리

- **C: 시계열 스트림** (연속적 이벤트, 센서 데이터)
  - 예: 클릭 스트림, IoT 센서, 로그 스트림
  - → 실시간 스트리밍 처리

- **D: 집계/분석용** (대용량, 히스토리컬 데이터)
  - 예: 매출 데이터, 사용자 행동 로그
  - → 배치/분석 처리

**L1-Q1 + L1-Q2 조합 예시**:

```
A (치명적) + A (구조화) = CRUD/트랜잭션 시스템
A (치명적) + C (시계열) = 실시간 트랜잭션 (주식 거래)
C (점진적) + B (비구조화) = 검색/추천 시스템
```

---

### 4-3. L1-Q3: 응답 시점

**질문**:
> **"시스템이 응답하는 '시점'은?"**

**선택지**:
- **A: 즉시** (사용자가 대기 중, 실시간 필요)
  - 예: 웹 검색, 챗봇, 대시보드
  - → 실시간 처리, 저지연 아키텍처

- **B: 수 초~수 분** (백그라운드 작업, 사용자는 다른 일)
  - 예: 파일 변환, 이메일 발송, 리포트 생성
  - → 비동기 처리, 작업 큐

- **C: 수 시간~일 단위** (정기 배치, 오프라인)
  - 예: 일일 정산, 월별 리포트, 데이터 마이그레이션
  - → 배치 처리, ETL

**중요한 통찰**:

"즉시"의 정의가 패밀리마다 다릅니다:
- CRUD 시스템의 "즉시": 50-100ms (트랜잭션)
- 검색 시스템의 "즉시": 500ms (p99)
- 스트리밍 시스템의 "즉시": 10ms 이하

---

### 4-4. Layer 1 출력: 아키텍처 패밀리

**3개 질문 조합 → 패밀리 분류**

```
예시 1: 문서 생성
L1-Q1: A (치명적)
L1-Q2: A (구조화)
L1-Q3: B (수 분)
→ 패밀리: 비동기 CRUD/트랜잭션

예시 2: AI 외부메모리
L1-Q1: C (점진적)
L1-Q2: B (비구조화)
L1-Q3: A (즉시)
→ 패밀리: 실시간 검색/추천

예시 3: 주식 거래 시스템
L1-Q1: A (치명적)
L1-Q2: C (시계열)
L1-Q3: A (즉시)
→ 패밀리: 실시간 스트리밍
```

**패밀리가 결정하는 것**:

```
CRUD/트랜잭션 → Layer 2에서 묻기:
- 정확성(ACID) 레벨?
- 트랜잭션 범위?

검색/추천 → Layer 2에서 묻기:
- 관련성 측정 방법?
- 지연시간 목표?

실시간 스트리밍 → Layer 2에서 묻기:
- 처리량(TPS)?
- 순서 보장 필요?
```

---

## 5. Layer 2: NFR 우선순위 + 충돌 감지

**목표**: 트레이드오프 결정 + "불가능한 조합" 감지

### 5-1. L2-Q1: 핵심 품질 (북극성)

**질문**:
> **"이 시스템의 '단 하나의' 핵심 품질은?"**

**Gemini 인사이트**:
> "모든 것을 잘할 수는 없다. 아키텍처의 '북극성'을 결정하라."

**선택지**:
- **A: 가장 정확함** (Correctness, Accuracy)
  - 예: 100% 정확한 계산, 오류 허용 0%
  - 트레이드오프: 속도 느려질 수 있음

- **B: 가장 빠름** (Speed, Low Latency)
  - 예: p99 < 500ms, 실시간 응답
  - 트레이드오프: 정확도 떨어질 수 있음

- **C: 가장 안전함** (Security, Privacy)
  - 예: 데이터 격리, 완벽한 암호화
  - 트레이드오프: 복잡성, 비용 증가

- **D: 가장 저렴함** (Cost Efficiency)
  - 예: 최소 인프라, 오픈소스 우선
  - 트레이드오프: 운영 복잡성 증가

**중요**: 하나만 선택!

```
❌ "정확하면서도 빠르게"
✅ "빠름 우선. 정확도 80%면 충분"
```

**예시**:

```
문서 생성:
A (가장 정확함) → 법률 문서는 100% 정확성 필수

AI 외부메모리:
B (가장 빠름) → p99 < 500ms 목표
```

---

### 5-2. L2-Q2: 규모의 특성

**질문**:
> **"사용자 규모의 '특성'은?"**

**중요**: "몇 명?"이 아니라 "어떤 패턴?"

**선택지**:
- **A: B2B (소수 대기업)**
  - 특징: 10-100개 조직, 조직당 100-1000명
  - 요구사항: 격리(isolation), 커스터마이징, 높은 SLA
  - 아키텍처: 모놀리식 또는 단일 테넌트

- **B: B2C (다수 개인)**
  - 특징: 수천~수백만 개인 사용자, 트래픽 급증
  - 요구사항: 수평 확장, 표준화, 비용 효율
  - 아키텍처: 분산형, 클라우드 네이티브

- **C: API (수천 개발자/테넌트)**
  - 특징: 수천 개 독립 테넌트, API 호출 패턴
  - 요구사항: 멀티테넌시, 미터링, 격리
  - 아키텍처: 논리적 분리, API 게이트웨이

**Gemini 발견**:

"중규모" vs "500명"이 아니라:
- B2B vs B2C → 구조(Structure) 결정
- 트래픽 패턴 → 확장성(Scalability) 설계

**예시**:

```
문서 생성:
A (B2B) → 10개사, 완벽한 격리, 온프레미스

AI 외부메모리:
C (API) → 수천 테넌트, 논리적 분리 (메타데이터)
```

---

### 5-3. L2-Q3: 데이터 외부 유출

**질문**:
> **"데이터가 조직 '외부'로 나갈 수 있나?"**

**선택지**:
- **A: 절대 안 됨** (민감한 내부 데이터)
  - 예: 계약서, 환자 기록, 금융 거래
  - → **온프레미스/VPC 필수**
  - → Pinecone 같은 SaaS 제외

- **B: 암호화되면 가능** (민감하지만 클라우드 가능)
  - 예: 고객 데이터, 내부 문서
  - → 프라이빗 클라우드
  - → 엔드투엔드 암호화

- **C: 공개 가능** (비민감 데이터)
  - 예: 블로그, 제품 정보, 공개 API
  - → 퍼블릭 클라우드 OK
  - → 비용 최적화 가능

**Gemini ADR-001 사례**:

```
문서 생성:
L2-Q3: A (절대 안 됨)
→ 배포: 온프레미스/VPC
→ 기술: Milvus (self-hosted) ✅
→ 제외: Pinecone (SaaS) ❌
```

---

### 5-4. L2-Q4: 데이터 최신성

**질문**:
> **"새 데이터가 즉시 반영되어야 하나?"**

**선택지**:
- **A: 즉시** (수 초 이내, 실시간)
  - 예: 채팅 메시지, 검색 인덱스
  - → 실시간 파이프라인, CDC

- **B: 곧바로** (수 분 이내, 준실시간)
  - 예: 뉴스 피드, 대시보드
  - → 최종일관성, 비동기 처리

- **C: 주기적으로** (일 단위, 배치)
  - 예: 리포트, 통계, 집계
  - → 배치 ETL, Airflow

---

### 5-5. 🔥 충돌 감지 메커니즘

**핵심**: Layer 2 답변 조합이 "불가능"하면 트레이드오프 협상

**충돌 패턴 1: 속도 + 즉시성**

```
L2-Q1: B (가장 빠름 - p99 < 500ms)
L2-Q4: A (즉시 반영 - 수 초 이내)

문제:
동기식으로는 불가능!
- 데이터 수집 → 임베딩 (외부 API, 수백 ms)
- 임베딩 → 벡터 DB 저장 (수십 ms)
- API 응답 시간 목표 초과 💥

트레이드오프 질문:
"최종일관성(수 초 지연)을 수용할 수 있나?"

Yes → Kafka + 비동기 Workers (ADR-002)
No → 요구사항 재협상 필요
```

**충돌 패턴 2: 규모 + 보안**

```
L2-Q2: C (API - 수천 테넌트)
L2-Q3: A (완벽한 격리)

문제:
테넌트별 물리적 분리 = 확장성 위배!
- 수천 개 DB/컬렉션 생성
- 메모리 오버헤드 폭발
- 관리 복잡성 증가 💥

트레이드오프 질문:
"논리적 분리(메타데이터 필터링)를 수용할 수 있나?"

Yes → tenant_id 필터링 (ADR-003)
    → 대가: 보안 위험이 애플리케이션 로직으로 이동
    → 조치: 엄격한 코드 리뷰, QA 필수

No → 물리적 분리
    → 대가: 확장성 제한, 비용 증가
```

**충돌 감지 프로세스**:

```python
def detect_conflict(layer2_answers):
    if (answers[Q1] == "빠름" and answers[Q4] == "즉시"):
        ask_tradeoff("최종일관성 수용 가능?")

    if (answers[Q2] == "수천 테넌트" and answers[Q3] == "완벽 격리"):
        ask_tradeoff("논리적 분리 수용 가능?")

    # ... 더 많은 패턴
```

---

### 5-6. Layer 2 출력: NFR 프로파일

**예시 1: 문서 생성**

```
NFR 프로파일: 보안-정확성 중심

L2-Q1: A (가장 정확함) → 100% 정확성
L2-Q2: A (B2B) → 10개사, 격리
L2-Q3: A (절대 안 됨) → 온프레미스
L2-Q4: C (일 배치) → 실시간 불필요

충돌 없음 ✅

→ Stage 2에서 다룰 NFR:
  - 정확성: 100% 데이터 매핑
  - 처리량: 일 1만 건 문서
  - 보안: VPC, 전송 암호화
```

**예시 2: AI 외부메모리**

```
NFR 프로파일: 확장성-비동기 중심

L2-Q1: B (가장 빠름) → p99 < 500ms
L2-Q2: C (API) → 수천 테넌트
L2-Q3: C (공개 가능) → 클라우드 OK
L2-Q4: A (즉시)

충돌 감지! L2-Q1 + L2-Q4 💥
→ 트레이드오프: 최종일관성 수용 ✅

→ Stage 2에서 다룰 NFR:
  - 지연시간: p99 < 500ms (검색 API)
  - 처리량: 초당 1000 검색
  - 최신성: 수 초 지연 (비동기)
  - 격리: tenant_id 메타데이터
```

---

## 6. Layer 3: 환경 제약사항

**목표**: 기술 스택 후보를 좁히기

### 6-1. L3-Q1: 기존 시스템 연동

**질문**:
> **"절대 연동해야 하는(또는 하면 안 되는) 기존 시스템?"**

**선택지**:
- **A: 레거시 시스템 필수**
  - 예: 오래된 ERP, 메인프레임, SOAP API
  - → 통합 복잡성 증가
  - → 기술 스택 제약 (호환성)

- **B: 기존 클라우드 인프라 활용**
  - 예: AWS 이미 사용 중, 팀 전문성
  - → 빠른 구축, 벤더 종속

- **C: 완전히 새로운 시스템**
  - → 자유도 최대, 최적 기술 선택 가능

---

### 6-2. L3-Q2: 배포 환경 제약

**질문**:
> **"배포 환경에 대한 '결정적' 제약?"**

**선택지**:
- **A: 특정 국가/리전만**
  - 예: GDPR (EU만), 중국 (로컬 서버)
  - → 지리적 제약, CDN 설계

- **B: 온프레미스만**
  - 예: 정부, 금융, 의료
  - → 클라우드 서비스 제외
  - → Pinecone (SaaS) ❌
  - → Milvus (self-hosted) ✅

- **C: 특정 클라우드만**
  - 예: AWS Only, Azure Only
  - → 해당 클라우드 네이티브 서비스

- **D: 제약 없음**
  - → 최적 기술 선택 가능

**Gemini ADR 사례**:

```
문서 생성:
L2-Q3: A (데이터 외부 유출 절대 안 됨)
L3-Q2: B (온프레미스만)
→ Pinecone 제외 ❌ (SaaS)
→ Milvus 선택 ✅ (self-hosted)
```

---

### 6-3. L3-Q3: 배포 주기

**질문**:
> **"기능 변경/배포 주기는?"**

**선택지**:
- **A: 매일/매주** (애자일, 빠른 반복)
  - → 마이크로서비스, CI/CD
  - → 컨테이너, Kubernetes

- **B: 월 1회** (안정적 릴리스)
  - → 모놀리식 가능
  - → 간단한 배포 파이프라인

- **C: 분기 1회** (엔터프라이즈)
  - → 안정성 최우선
  - → 엄격한 테스트

**아키텍처 영향**:

```
매주 배포:
→ 마이크로서비스 (독립 배포)
→ Feature Flag
→ Blue-Green 배포

분기 배포:
→ 모놀리식 OK
→ 통합 테스트 강화
```

---

### 6-4. Layer 3 출력: 기술 스택 후보

**예시 1: 문서 생성**

```
환경 제약:
L3-Q1: C (새로운 시스템)
L3-Q2: B (온프레미스만)
L3-Q3: C (분기 1회)

기술 스택 후보:
✅ Kubernetes (on-prem)
✅ Milvus (self-hosted, VPC 내)
✅ FastAPI (Python 생태계)
✅ PostgreSQL (ACID)

제외된 기술:
❌ Pinecone (SaaS, 온프레미스 불가)
❌ Serverless (클라우드 전용)
```

**예시 2: AI 외부메모리**

```
환경 제약:
L3-Q1: C (새로운)
L3-Q2: D (제약 없음)
L3-Q3: A (주간 배포)

기술 스택 후보:
✅ Kafka (비동기)
✅ Milvus 또는 Pinecone (둘 다 고려)
✅ Kubernetes (빠른 배포)
✅ Redis (캐싱)

→ Stage 2에서 상세 비교:
  - Milvus vs Pinecone (속성 질문 기반)
```

---

## 7. 실전 예시: 두 사례 비교

### 7-1. 사례 A: 문서 자동 생성 서비스

**배경**: 엔터프라이즈 법률팀을 위한 계약서 초안 생성 (RAG)

#### Layer 1: 패밀리 식별

```
L1-Q1 (틀리면?): A - 치명적
  → 법률 문서 오류 = 법적 문제

L1-Q2 (정보 형태?): A - 구조화
  → JSON 데이터, 고정 필드, 템플릿

L1-Q3 (응답 시점?): B - 수 분
  → 1시간 → 5분으로 단축 (백그라운드)

→ 패밀리: 비동기 CRUD/트랜잭션
```

#### Layer 2: NFR 우선순위

```
L2-Q1 (핵심 품질?): A - 가장 정확함
  → 법률 문서 = 100% 정확성 필수

L2-Q2 (규모 특성?): A - B2B
  → 10개사, 각 100명

L2-Q3 (외부 유출?): A - 절대 안 됨
  → 민감한 계약서 데이터

L2-Q4 (즉시 반영?): C - 일 배치
  → 매일 업데이트, 실시간 불필요

충돌 없음 ✅

→ NFR 프로파일: 보안-정확성 중심, 배치 처리
```

#### Layer 3: 환경 제약

```
L3-Q1 (기존 시스템?): C - 새로운
L3-Q2 (배포 제약?): B - 온프레미스/VPC 필수
L3-Q3 (배포 주기?): C - 분기 1회

→ 기술 후보:
  ✅ Kubernetes (on-prem)
  ✅ Milvus (self-hosted)
  ✅ FastAPI
  ✅ Azure AI Document Intelligence
  ❌ Pinecone (SaaS 불가)
```

#### Stage 2로 전달

```
→ 구현방법 단계에서 구체화:
  - 정확성: 100% 데이터 매핑 검증
  - 처리량: 일 10만 문서, 1시간 이내
  - 보안: VPC, PrivateLink, 전송 암호화
  - 인덱싱: 일 1회 배치, 5분 내 검색 가능
```

---

### 7-2. 사례 B: AI 외부 메모리 시스템

**배경**: AI 에이전트용 장기 메모리, 대화 연속성 제공 (RAG)

#### Layer 1: 패밀리 식별

```
L1-Q1 (틀리면?): C - 점진적
  → 덜 관련된 정보 = 차선의 답

L1-Q2 (정보 형태?): B - 비구조화
  → 대화 로그, 텍스트, 문서

L1-Q3 (응답 시점?): A - 즉시
  → p99 < 500ms 목표

→ 패밀리: 실시간 검색/추천
```

#### Layer 2: NFR 우선순위 + 충돌

```
L2-Q1 (핵심 품질?): B - 가장 빠름
  → p99 < 500ms

L2-Q2 (규모 특성?): C - API
  → 수천 개발자/테넌트

L2-Q3 (외부 유출?): C - 공개 가능
  → 클라우드 OK, 테넌트별 격리만

L2-Q4 (즉시 반영?): A - 즉시
  → 수 초 이내 검색 가능

🔥 충돌 감지!
L2-Q1 (빠름) + L2-Q4 (즉시) = 동기식 불가능!

트레이드오프 질문:
"최종일관성(수 초 지연)을 수용할 수 있나?"
→ Yes ✅

→ NFR 프로파일: 확장성-관련성 중심, 비동기+최종일관성
```

#### Layer 3: 환경 제약

```
L3-Q1 (기존 시스템?): C - 새로운
L3-Q2 (배포 제약?): D - 제약 없음
L3-Q3 (배포 주기?): A - 주간 배포

→ 기술 후보:
  ✅ Kafka (비동기 수집)
  ✅ Milvus 또는 Pinecone (둘 다 고려)
  ✅ Kubernetes (빠른 배포)
  ✅ Redis (캐싱)
  ✅ FastAPI (비동기)
```

#### Stage 2로 전달

```
→ 구현방법 단계에서 구체화:
  - 지연시간: p99 < 500ms (검색 API)
  - 처리량: 초당 1000 검색, 100 수집
  - 최신성: 수 초 지연 (Kafka 큐)
  - 관련성: 하이브리드 검색 (Vector + BM25)
  - 격리: tenant_id 메타데이터 필터링
  - 확장성: 10억 벡터까지 수평 확장
```

---

### 7-3. 두 사례 비교 테이블

| 차원 | 문서 생성 (결정론적) | AI 외부메모리 (확률론적) |
|------|---------------------|-------------------------|
| **L1 패밀리** | 비동기 CRUD/트랜잭션 | 실시간 검색/추천 |
| **실패 모드** | 치명적 (0 or 1) | 점진적 (0~100%) |
| **데이터** | 구조화 (JSON) | 비구조화 (벡터) |
| **핵심 NFR** | 100% 정확성 | 관련성, 지연시간 |
| **규모** | B2B (10개사) | API (수천 테넌트) |
| **보안** | 온프레미스 (절대 격리) | 클라우드 (논리적 격리) |
| **최신성** | 일 배치 | 최종일관성 (수 초) |
| **충돌** | 없음 ✅ | Q1+Q4 💥 → 비동기 |
| **배포** | 온프레미스/VPC | 클라우드 |
| **기술** | Milvus (self-hosted) | Kafka + Milvus/Pinecone |

**핵심 통찰**:

```
같은 RAG 아키텍처, 완전히 다른 시스템!

공통점:
- 둘 다 벡터 DB 필요
- 둘 다 임베딩 파이프라인
- 둘 다 검색 기능

차이점 (Layer 1-3에서 도출):
- 문서 생성: 정확성 > 속도, 동기식 가능, 온프레미스
- AI 메모리: 속도 > 정확성, 비동기 필수, 클라우드

→ 같은 질문(7개 고정)으로는 이런 차이를 포착 불가!
→ 스무고개 방식(답변에 따라 분기)이 필수!
```

---

## 8. 작성 프로세스

### 8-1. 시작 전 준비

**1단계: 실패 사례 분석 (선택적)**

```
목적: 같은 실수 반복 방지

방법:
□ 과거 프로젝트 나열
□ 실패/성공 분류
□ 패턴 분석
  - 왜 실패? (목표 모호, 범위 폭발 등)
  - 왜 성공? (명확한 목표, MVP 등)
□ 교훈 추출
```

**2단계: 프로젝트 맥락 수집**

```
□ 비즈니스 목표 (왜 만드나?)
□ 주요 이해관계자
□ 예산/일정 제약
□ 기존 시스템/기술 스택
```

---

### 8-2. Layer 1: 아키텍처 패밀리 식별

**진행 방법**:

```
AI: "L1-Q1. 이 시스템의 결과가 틀리면 무슨 일이 벌어지나요?"

Jason: "법률 문서가 틀리면 소송 위험이 있어요"

AI: "치명적인 법적 문제네요. A (치명적) 선택합니다."
    "L1-Q2. 시스템이 처리하는 핵심 정보는 어떤 형태인가요?"

Jason: "계약서 템플릿에 JSON 데이터를 매핑해요"

AI: "구조화된 데이터네요. A (구조화) 선택합니다."
    "L1-Q3. 사용자가 결과를 받는 시점은?"

Jason: "업로드하면 5분 정도 걸려요. 기다리진 않아요"

AI: "B (수 분) 선택합니다."

    "L1 결과: 비동기 CRUD/트랜잭션 시스템으로 분류되었습니다.
     이제 이 패밀리에 맞는 NFR 질문을 드리겠습니다."
```

---

### 8-3. Layer 2: NFR 우선순위

**진행 방법**:

```
AI: "L2-Q1. 이 시스템의 '단 하나의' 핵심 품질은?"
    (CRUD 패밀리이므로 정확성 vs 처리량 중심 질문)

Jason: "무조건 정확해야 해요"

AI: "A (가장 정확함) 선택. 속도는 다소 느려질 수 있습니다."
    "L2-Q2. 사용자 규모의 특성은?"

Jason: "10개 법무팀, 각 팀당 100명 정도"

AI: "A (B2B) 선택. 격리와 커스터마이징이 중요하겠네요."
    "L2-Q3. 계약서 데이터가 조직 외부로 나갈 수 있나요?"

Jason: "절대 안 돼요!"

AI: "A (절대 안 됨) 선택. 온프레미스 또는 VPC 배포 필요합니다."
    "L2-Q4. 새 계약서 템플릿이 즉시 반영되어야 하나요?"

Jason: "매일 밤 업데이트하면 돼요"

AI: "C (일 배치) 선택."

    "충돌 검사 중... 충돌 없음 ✅
     NFR 프로파일: 보안-정확성 중심, 배치 처리"
```

---

### 8-4. Layer 2-B: 충돌 감지 시

**충돌 발생 예시** (AI 외부메모리):

```
AI: "L2-Q1. 핵심 품질은?"
Jason: "빨라야 해요. p99가 500ms 이내"
AI: "B (가장 빠름) 선택."

AI: "L2-Q4. 새 대화 내용이 즉시 반영되어야 하나요?"
Jason: "네, 바로 다음 검색에 나와야 해요"
AI: "A (즉시) 선택."

AI: "🔥 충돌 감지!
     L2-Q1 (빠름: 500ms) + L2-Q4 (즉시 반영)

     문제: 동기식으로는 불가능합니다.
     - 데이터 수집 시
     - 임베딩 API 호출 (수백 ms)
     - 벡터 DB 저장 (수십 ms)
     - API 응답 시간 초과 💥

     해결책: 비동기 처리 (Kafka + Workers)
     대가: 최종일관성 (수 초 지연 발생)

     질문: 수 초 지연을 수용할 수 있나요?"

Jason: "네, 5초 정도는 괜찮아요"

AI: "트레이드오프 수용 ✅
     NFR 프로파일 업데이트:
     - 지연시간: p99 < 500ms (검색 API만)
     - 최신성: 최종일관성 (수 초)
     - 아키텍처: 비동기 (Kafka)"
```

---

### 8-5. Layer 3: 환경 제약

**진행 방법**:

```
AI: "L3-Q1. 연동해야 하는 기존 시스템이 있나요?"
Jason: "완전히 새로운 시스템이에요"
AI: "C (새로운) 선택."

AI: "L3-Q2. 배포 환경 제약은?"
Jason: "고객사 내부망에 설치해야 해요"
AI: "B (온프레미스) 선택.
     → Pinecone 같은 SaaS는 사용 불가 ❌"

AI: "L3-Q3. 배포 주기는?"
Jason: "분기마다 한 번 정도"
AI: "C (분기 1회) 선택.
     → 안정성 최우선, 모놀리식 가능"

AI: "Layer 3 완료!
     기술 스택 후보:
     ✅ Kubernetes (on-prem)
     ✅ Milvus (self-hosted)
     ✅ FastAPI
     ❌ Pinecone (SaaS 불가)

     이제 Stage 2 (구현방법)에서 상세 비교합니다."
```

---

### 8-6. 완료 및 검증

**체크리스트**:

```
Layer 1:
□ 3개 질문 모두 답변
□ 아키텍처 패밀리 분류 완료
□ 패밀리가 합리적인가?

Layer 2:
□ 4개 질문 모두 답변
□ 핵심 품질 하나만 선택
□ 충돌 감지 수행
□ 트레이드오프 협상 (필요시)
□ NFR 프로파일 생성

Layer 3:
□ 3개 질문 모두 답변
□ 기술 스택 후보 리스트
□ 제외된 기술과 이유 명확

최종:
□ 방향 명확한가?
□ Stage 2 진입 조건 충족?
```

---

## 9. 템플릿

### 9-1. 핵심정의 문서 템플릿 (v2.0)

```markdown
# [프로젝트명] - 핵심정의 (Core Definition)

**작성일**: YYYY-MM-DD
**작성자**: Jason + [AI 이름]
**방법론**: 3-Layer Decision Tree (v2.0)

---

## Layer 1: 아키텍처 패밀리 식별

### L1-Q1. 잘못된 결과의 파급력
**답변**: [A/B/C]
**설명**: [구체적 상황]

### L1-Q2. 핵심 정보의 형태
**답변**: [A/B/C/D]
**설명**: [데이터 예시]

### L1-Q3. 응답 시점
**답변**: [A/B/C]
**설명**: [사용 시나리오]

### ✅ 패밀리 분류
**결과**: [CRUD/검색/스트리밍/배치/협업]

---

## Layer 2: NFR 우선순위 + 충돌 감지

### L2-Q1. 핵심 품질 (하나만!)
**답변**: [A/B/C/D]
**트레이드오프**: [무엇을 포기?]

### L2-Q2. 규모 특성
**답변**: [A/B/C]
**설명**: [사용자 패턴]

### L2-Q3. 데이터 외부 유출
**답변**: [A/B/C]
**영향**: [배포 환경 제약]

### L2-Q4. 데이터 최신성
**답변**: [A/B/C]
**요구사항**: [구체적 시간]

### 🔥 충돌 감지
**충돌 여부**: [Yes/No]

[Yes인 경우]
**충돌 패턴**: [어떤 조합?]
**트레이드오프 질문**: [무엇을 물었나?]
**선택**: [어떻게 결정?]
**대가**: [무엇을 포기?]

### ✅ NFR 프로파일
**프로파일**: [예: 보안-정확성 중심, 비동기]
**핵심 NFR**:
- [NFR 1]: [목표값]
- [NFR 2]: [목표값]
- [NFR 3]: [목표값]

---

## Layer 3: 환경 제약사항

### L3-Q1. 기존 시스템 연동
**답변**: [A/B/C]
**영향**: [통합 복잡성]

### L3-Q2. 배포 환경 제약
**답변**: [A/B/C/D]
**제약**: [구체적 제약사항]

### L3-Q3. 배포 주기
**답변**: [A/B/C]
**영향**: [아키텍처 스타일]

### ✅ 기술 스택 후보
**포함**:
- [기술 1]: [이유]
- [기술 2]: [이유]

**제외**:
- [기술 X]: [이유]

---

## Stage 2로 전달

**구현방법 단계에서 구체화할 NFR**:

1. **[NFR 항목 1]**
   - 속성 질문: [무엇을 물어볼 것인가?]
   - 목표: [구체적 수치]

2. **[NFR 항목 2]**
   - 속성 질문: [무엇을 물어볼 것인가?]
   - 목표: [구체적 수치]

3. **[NFR 항목 3]**
   - 속성 질문: [무엇을 물어볼 것인가?]
   - 목표: [구체적 수치]

---

## 핵심정의 완료 체크리스트

Layer 1:
□ 3개 질문 답변 완료
□ 패밀리 분류 완료

Layer 2:
□ 4개 질문 답변 완료
□ 충돌 감지 수행
□ NFR 프로파일 생성

Layer 3:
□ 3개 질문 답변 완료
□ 기술 스택 후보 정리

최종:
□ 방향 명확
□ Stage 2 진입 준비 완료

---

## 다음 단계

→ **구현방법 (Implementation Approach)** 진입
```

---

## 10. 다음 단계

### 10-1. Stage 2 진입 조건

```
✅ Layer 1: 아키텍처 패밀리 분류
✅ Layer 2: NFR 프로파일 생성
✅ Layer 3: 기술 스택 후보 리스트
✅ 충돌 해결 (있는 경우)
✅ 방향 명확
```

### 10-2. Stage 2에서 할 일

**구현방법 (Implementation Approach)**: 5단계 프로세스

```
1단계: 기능 분해
- 핵심정의의 목표 → 필요한 기능 식별

2단계: 속성 질문 ⭐ (가장 중요!)
- 성능 속성: 얼마나 빨라야? 몇 명?
- 품질 속성: 실패하면? 얼마나 정확?
- 환경 속성: 어디서? 플랫폼 제약?
→ Layer 2 NFR을 구체적 수치로 변환

3단계: 제약조건 파악
- 팀 역량, 비용/시간
- 기존 시스템, 규제/정책

4단계: 기술 옵션 탐색
- Layer 3 후보 중 3개 비교
- 장단점 분석 (NFR 충족도)
- 권장안 선정 (근거 명확)

5단계: 통합 설계
- 시스템 아키텍처
- 데이터 스키마 v1.0
- API 설계 v1.0
```

**핵심정의 → 구현방법 연결**:

```
Layer 1 (패밀리) → 2단계 속성 질문 유형 결정
  예: 검색/추천 → 관련성, 지연시간 중심

Layer 2 (NFR 프로파일) → 2단계 속성 질문에 구체적 수치
  예: "가장 빠름" → "p99 < 500ms?"

Layer 3 (기술 후보) → 4단계 기술 옵션 탐색
  예: Milvus vs Pinecone vs PGvector 비교
```

### 10-3. Amazon 방법론 연결

```
핵심정의 = Amazon Stage 1: Identify Use Cases ✅
    ↓
구현방법 = Amazon Stage 2: Specify Concrete Requirements ← 다음
    ↓
ADR      = Amazon Stage 3: Select Tools & Infrastructure
```

**Carnegie Mellon SEI 원칙**:
> **"속성(Quality Attributes)이 기술 선택을 주도한다"**

```
잘못된 접근:
"채팅 기능 필요" → "WebSocket 쓰자" (왜?)

올바른 접근:
"채팅 기능 필요" (핵심정의)
→ 속성 질문: "500ms 이내, 1000명 동시" (구현방법)
→ 옵션 비교: WebSocket vs Long Polling (구현방법)
→ 권장안: WebSocket (근거 명확) (구현방법)
→ ADR 작성 (ADR)
```

---

## 참고 문서

### 관련 가이드
- [00_CORE_METHODOLOGY.md](./00_CORE_METHODOLOGY.md) - 전체 방법론
- [02_IMPLEMENTATION_APPROACH_GUIDE.md](./02_IMPLEMENTATION_APPROACH_GUIDE.md) - 다음 단계
- [03_ADR_GUIDE.md](./03_ADR_GUIDE.md) - 기술 결정 문서화

### 실전 사례
- `Gemini_아키텍처_정의_질문_구조화_리서치.md` - 10가지 ADQs 제안
- `Gemini_AI외부메모리_아키텍처_설계_프로세스.md` - RAG 시스템 3단계 분석
- `Gemini_엔터프라이즈_소프트웨어개발_프로세스_리서치.md` - Amazon, Google 방법론

### 배경 연구
- Amazon Working Backwards (PR/FAQ)
- Google PRD + CUJ
- Carnegie Mellon SEI: Attribute-Driven Design
- BABOK: Requirements Classification

---

**핵심정의 작성 가이드 (Core Definition Guide) v2.0** - 2025-11-11

다음: [구현방법 작성 가이드 (Implementation Approach Guide)](./02_IMPLEMENTATION_APPROACH_GUIDE.md)
