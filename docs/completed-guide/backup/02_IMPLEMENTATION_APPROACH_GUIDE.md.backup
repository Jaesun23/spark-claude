# 구현방법 작성 가이드 (Implementation Approach Guide)

> **목적**: 핵심정의의 "무엇을"을 "어떻게" 구현할 것인지 구체화하는 방법
>
> **기반**: [CORE_METHODOLOGY.md](./00_CORE_METHODOLOGY.md) 구현방법 단계
>
> **버전**: v2.0 (2025-11-11)
>
> **발견**: memory 프로젝트 재구성 세션 (2025-11-10) + Gemini 엔터프라이즈 리서치

---

## 목차

1. [개요](#1-개요)
2. [왜 필요한가?](#2-왜-필요한가)
3. [질문 방식의 전환](#3-질문-방식의-전환)
4. [5단계 프로세스 (기능 → 속성 → 기술)](#4-5단계-프로세스-기능--속성--기술)
5. [작성 프로세스](#5-작성-프로세스)
6. [템플릿](#6-템플릿)
7. [다음 단계](#7-다음-단계)

---

## 1. 개요

### 1-1. 구현방법이란?

**구현방법 (Implementation Approach)**은 핵심정의의 "무엇을"을 "어떻게" 만들 것인지 구체화하는 단계입니다.

```
핵심정의 (Core Definition): What & Why
    ↓
구현방법 (Implementation Approach): How ← 여기!
    ↓
ADR: 기술 결정 (Which & Why)
    ↓
Blueprint: 구체적 설계
```

**Amazon 방법론과의 연결**:
```
Amazon 1단계: Identify Use Cases
    = 핵심정의 (3-Layer 질문 구조)
    ↓
Amazon 2단계: Specify Concrete Requirements ⭐
    = 구현방법 (5단계 프로세스)
    ↓
Amazon 3단계: Select Tools & Infrastructure
    = ADR (기술 결정 기록)
```

**구현방법의 핵심**:
- **"어떻게"에 집중**: 실제 구현 방법 구체화
- **사용 시나리오 기반**: 기술 스펙이 아닌 사용 경험
- **속성 질문 중심**: 성능, 품질, 환경 요구사항 도출
- **5단계 프로세스**: 기능 → 속성 → 제약 → 기술 → 통합
- **점진적 구체화**: 초기부터 완벽하지 않아도 OK

### 1-2. 핵심정의와의 차이

| 구분 | 핵심정의 | 구현방법 |
|------|---------|---------|
| **목적** | 무엇을 (What) | 어떻게 (How) |
| **질문** | "왜 필요?" | "어떻게 쓰나?" |
| **결과** | 방향, 목표 | 구현 방법 |
| **예시** | "대화 연속성" | "6가지 사용 시나리오" |
| **기술** | 방향만 (Redis) | 구체화 (스키마 v1.0) |
| **소요** | 1-2시간 | 3-5시간 |

**핵심 차이**:
```
핵심정의: "유용함이 목표" (방향)
    ↓
구현방법: "하이브리드 검색 = 키워드 + 벡터" (방법)
         + 6가지 사용 시나리오로 검증
```

### 1-3. 구현방법의 목표

**입력**:
- 핵심정의 완료 문서 (3-Layer 질문 결과)
- 핵심 목표, MVP, Trade-off
- Layer 2 NFR 프로파일 (속성 우선순위)

**출력** (5단계 프로세스):
1. **기능 분해**: 핵심정의의 문제 → 필요한 기능들
2. **속성 질문** ⭐: 각 기능의 구체적 요구사항 (NFR)
   - Layer 2 NFR 프로파일 → 속성 질문 매핑
   - 성능: 얼마나 빨라야? 몇 명이 사용?
   - 품질: 실패하면? 얼마나 정확?
   - 환경: 어디서? 플랫폼 제약?
3. **제약조건**: 팀 역량, 비용, 기존 시스템, 규제
4. **기술 옵션**: 속성과 제약 하에서 옵션 3개 비교 → 권장안
5. **통합 설계**: 아키텍처, Schema v1.0, API 설계

**핵심 원칙** (Carnegie Mellon SEI):
> **"속성(Quality Attributes)이 기술 선택을 주도한다"**
>
> 기능만으로는 기술을 선택할 수 없다.
> 성능/품질/환경 요구사항을 먼저 구체화해야
> 올바른 기술을 선택할 수 있다.

**특징**:
- **완벽하지 않아도 OK**: v1.0, 진화 가능
- **속성 질문이 핵심**: "500ms 이내", "1000명 동시 접속" 같은 구체적 수치
- **시나리오 검증**: "이 경우엔 어떻게?"
- **제약 반영**: 팀 역량, 비용, 기존 시스템
- **옵션 비교**: 여러 기술 옵션의 장단점 분석

---

## 2. 왜 필요한가?

### 2-1. 핵심정의만으로는 부족

```
핵심정의 완료:
✅ 목표: "대화 연속성"
✅ MVP: "저장 → 키워드 → 의미 검색"
✅ Trade-off: "유용함 > 정확도"

하지만:
❓ 어떤 정보를 저장?
❓ 어떻게 검색?
❓ 언제 저장/검색?
❓ 어떤 인터페이스?
```

**구현방법 없이 구현하면**:
```
개발자: "저장? 모든 대화 저장하면 되죠!"
    ↓
실제: Jason은 "중요한 것만" 원함
    ↓
결과: 쓸모없는 기능
```

### 2-2. "방향"에서 "방법"으로

#### 사례: "유용함" 정의

**핵심정의** (방향):
```
Q: 성공 기준?
A: "유용함 = 하이브리드 검색"
```

**구현방법** (방법):
```
Q: "하이브리드 검색"이란?
A: "키워드 필터 + 의미 유사도"

Q: 구체적으로?
A: 6가지 사용 사례:
   1. "어제 하던 작업" = 시간 + 타입 필터
   2. "예전에 그런 일" = 의미 유사도만
   3. "2호 세션 → 1호 이어가기" = 프로젝트 + 시간
   4. "1호 ↔ 2호 작업 공유" = 프로젝트 + 의미
   5. "문서에서 정보 찾기" = RAG
   6. "공감했던 내용" = 타입 + 의미
```

**차이**:
- 핵심정의: 추상적 목표
- 구현방법: 구체적 시나리오

**Amazon 방법론과의 연결**:
```
Amazon 1단계 (Identify Use Cases)
  = "대화 연속성 필요" (방향)

Amazon 2단계 (Specify Concrete Requirements)
  = "6가지 사용 시나리오"
  + "키워드 필터 + 의미 유사도"
  + "시간/타입/프로젝트 필터" (구체적 요구사항)
```

> "어떻게 사용할지(구체적 요구사항)를 먼저 정의해야만
> 무엇을 사용할지(기술)를 올바르게 선택할 수 있다"
> — Amazon Use-Case Driven Architecture

---

## 3. 질문 방식의 전환

### 3-1. 잘못된 질문 vs 올바른 질문 (속성 질문의 발견)

이것이 **구현방법의 가장 중요한 발견**입니다!

#### ❌ 잘못된 질문 (기술 중심)

```
AI: "스키마 33개 필드 vs 7개 필드?"
사용자: "..." (답변 불가)

AI: "RediSearch 인덱스 파라미터는?"
사용자: "..." (모름)

AI: "Hash vs JSON 저장 방식?"
사용자: "..." (관심 없음)
```

**문제**: 사용자는 기술 전문가가 아님

#### ✅ 올바른 질문 (사용 경험 중심)

**기능 질문**:
```
AI: "어떤 정보를 저장하고 싶으세요?"
사용자: "작업 내용, 공감한 내용, 문서..."

AI: "어떻게 찾고 싶으세요?"
사용자: "어제 작업, 비슷한 경험, 프로젝트별..."
```

**속성 질문** ⭐ (더 중요!):
```
AI: "검색 결과가 얼마나 빨라야 하나요?"
사용자: "1초 이내면 좋겠어요"

AI: "동시에 몇 명이 사용하나요?"
사용자: "저 혼자요. 1-2명 정도"

AI: "검색 결과 몇 개가 필요한가요?"
사용자: "5개 정도면 충분해요"

AI: "검색이 실패하면 어떻게 되나요?"
사용자: "괜찮아요. 다시 검색하면 되니까"
```

**해결**: 사용자의 경험 + **구체적 수치 요구사항** 파악

**핵심 발견**:
- 기능 질문만으로는 부족 → "저장"이라는 기능만 알면 뭘 선택?
- **속성 질문이 기술 선택을 주도** → "1초 이내, 1-2명"이면 SQLite도 충분!
- 이것이 Carnegie Mellon SEI의 **Attribute-Driven Design (ADD)** 원칙

### 3-2. 기술 중심 → 사용 경험 중심

#### 변환 과정

**1단계: 사용 사례 수집**
```
AI: "메모리를 언제 사용하나요?"
Jason: 6가지 시나리오 제시
```

**2단계: 패턴 추출**
```
AI: 6가지 사례 분석
→ 공통 정보: content, type, project, speaker
→ 검색 패턴: 시간, 타입, 의미 유사도
```

**3단계: 기술 요구사항 도출**
```
사용 사례 → 기술 요구사항
- "어제 작업" → 시간 필터 필요
- "비슷한 경험" → 벡터 검색 필요
- "프로젝트별" → 태그 필터 필요
```

**4단계: 스키마 설계**
```
기술 요구사항 → 스키마
- 시간 필터 → created_at (timestamp)
- 벡터 검색 → embedding (vector)
- 태그 필터 → type, project (tag)
```

#### 핵심 원칙

```
사용자 경험 → 기술 요구사항 → 설계
(Jason이 답변) (AI가 변환) (AI가 설계)
```

**절대 하지 말 것**:
```
기술 설계 → 사용자에게 강요
(AI가 먼저 설계) (Jason이 맞춰야 함)
```

### 3-3. 사용자 재정의의 중요성

#### 결정적 발견

**초기 가정**:
```
사용자: Jason
목적: Jason이 정보 저장/검색
```

**Jason의 지적**:
> "이 메모리 도구의 사용 주체는 제가 아니에요.
> 어떤 검색결과를 얻어야 저와 함께 대화하는게 편해질 것인가를 생각해야 해요."

**올바른 이해**:
```
사용자: 1호, 2호 (AI agents)
목적: Jason과의 대화를 이어가기 위해
Jason: 메모리 시스템의 "주제"
```

#### 영향

```
사용자 = Jason이라고 가정:
→ UI 필요? 웹 인터페이스?
→ 사람이 검색하기 편한 방식?

사용자 = 1호, 2호 (AI):
→ API 필요! MCP!
→ AI가 검색하기 편한 방식?
→ ms 단위 응답!
→ 자동 RAG 통합!
```

**교훈**: 사용자를 다시 정의하면 모든 것이 바뀝니다.

---

## 4. 5단계 프로세스 (기능 → 속성 → 기술)

### 4-1. 전체 흐름: Amazon 방법론과의 연결

구현방법 작성은 **기능**에서 출발해 **속성**을 구체화하고 **기술**을 선택하는 과정입니다.

```
핵심정의 (Amazon 1단계)
   ↓
━━━━━━━━━━━━━━━━━━━━━━━━━━━
구현방법 (Amazon 2단계)
━━━━━━━━━━━━━━━━━━━━━━━━━━━
   ↓
1️⃣ 기능 분해
   문제 → 필요한 기능들

   ↓
2️⃣ 속성 질문 ⭐ (핵심!)
   각 기능의 구체적 요구사항
   - Layer 2 NFR → 속성 질문 매핑
   - 성능: 얼마나 빨라야?
   - 품질: 얼마나 정확해야?
   - 환경: 어디서 실행?

   ↓
3️⃣ 제약조건 파악
   무엇이 제한하나?
   - 팀 역량
   - 비용/시간
   - 기존 시스템

   ↓
4️⃣ 기술 옵션 탐색
   속성과 제약 하에서
   - 옵션 1, 2, 3 비교
   - 장단점 분석
   - 권장안 도출

   ↓
5️⃣ 통합 설계
   전체 시스템
   - 아키텍처
   - Schema v1.0
   - API 설계
━━━━━━━━━━━━━━━━━━━━━━━━━━━
   ↓
ADR (Amazon 3단계)
```

**핵심 원칙** (Carnegie Mellon SEI):
- 기능(Functional Requirements)만으로는 기술을 선택할 수 없다
- **속성(Quality Attributes)**이 기술 선택을 주도한다
- 속성을 먼저 구체화해야 올바른 기술을 선택할 수 있다

### 4-2. 1단계: 기능 분해

#### 목적
핵심정의의 문제들을 해결하기 위해 필요한 **기능**을 식별

#### 프로세스

**핵심정의 → 기능 매핑**
```
문제 1, 2 → 기능 A
문제 3, 4 → 기능 B
문제 5    → 기능 C
```

#### 템플릿

```markdown
## 1단계: 기능 분해

### 핵심정의 → 기능 매핑

| 문제 (핵심정의에서) | 필요한 기능 |
|-------------------|-----------|
| 문제 1, 2         | 기능 A    |
| 문제 3, 4         | 기능 B    |
| 문제 5            | 기능 C    |

### 기능 목록

#### 기능 A: [이름]
**설명**: [무엇을 하는가]
**해결하는 문제**: [핵심정의의 어떤 문제]

#### 기능 B: [이름]
**설명**: [무엇을 하는가]
**해결하는 문제**: [핵심정의의 어떤 문제]
```

### 4-3. 2단계: 속성 질문 ⭐ (핵심!)

#### 목적
각 기능의 **구체적인 요구사항**을 도출 (Amazon 2단계의 핵심)

#### 중요성
> "어떻게 사용할지(구체적 요구사항)를 먼저 정의해야만
> 무엇을 사용할지(기술)를 올바르게 선택할 수 있다"
> — Amazon Use-Case Driven Architecture

**질문 없이 선택하면**: "Redis가 유행이니까 Redis 쓰자" ❌
**질문 후 선택하면**: "1000명 동시 접속, 500ms 이내 → WebSocket이 적합" ✅

#### Layer 2 NFR 프로파일 → 속성 질문 매핑

**핵심정의 (01_CORE_DEFINITION_GUIDE)의 Layer 2에서 도출된 NFR 프로파일**을 구현방법의 속성 질문으로 변환합니다.

```
┌────────────────────────────────────────┐
│ Layer 2: NFR 프로파일 (핵심정의에서)     │
├────────────────────────────────────────┤
│ L2-Q1: 핵심 품질 (정확성/속도/보안/비용) │
│ L2-Q2: 규모 특성 (B2B/B2C/API)         │
│ L2-Q3: 데이터 외부 노출 (never/암호/공개)│
│ L2-Q4: 데이터 최신성 (즉시/준실시간/배치)│
└────────────────────────────────────────┘
              ↓ 매핑 (Mapping)
┌────────────────────────────────────────┐
│ 2단계: 속성 질문 (구현방법에서)          │
├────────────────────────────────────────┤
│ 성능 속성: 얼마나 빨라야? 몇 명?        │
│ 품질 속성: 실패하면? 얼마나 정확?       │
│ 환경 속성: 어디서? 플랫폼 제약?         │
└────────────────────────────────────────┘
```

**매핑 규칙**:

| Layer 2 NFR | 구현방법 속성 질문 | 예시 |
|------------|------------------|------|
| **L2-Q1: 핵심 품질** | 품질 속성 | A(정확성) → "실패하면?" "얼마나 정확?" |
| | | B(속도) → "얼마나 빨라야?" |
| **L2-Q2: 규모 특성** | 성능 속성 | B2B(10개사) → "동시 10개사" |
| | | B2C(천명) → "동시 1000명" |
| | | API(수천) → "QPS 1000" |
| **L2-Q3: 데이터 노출** | 환경 속성 | A(never) → "온프레미스? VPC?" |
| | | B(암호) → "암호화 방식?" |
| | | C(공개) → "API 공개?" |
| **L2-Q4: 데이터 최신성** | 성능 속성 | A(즉시) → "지연 시간?" |
| | | B(준실시간) → "수 초 허용?" |
| | | C(배치) → "일 배치?" |

#### 3가지 속성 질문

##### 1) 성능 속성 (Performance)

**핵심 질문**:
- 얼마나 **빨라야** 하나?
- 얼마나 **많은** 사용자를 지원해야 하나?
- 얼마나 **많은** 데이터를 처리해야 하나?

**Layer 2 매핑**:
- L2-Q1 = B(속도) → "p99 < 500ms"
- L2-Q2 = B2C → "동시 접속 1000명"
- L2-Q4 = A(즉시) → "실시간 반영"

##### 2) 품질 속성 (Quality)

**핵심 질문**:
- **실패**하면 어떻게 되나?
- 얼마나 **정확**해야 하나?
- 얼마나 **가용**해야 하나?

**Layer 2 매핑**:
- L2-Q1 = A(정확성) → "100% 정확, 실패 치명적"
- L2-Q1 = B(속도) → "가용성 > 정확성"

##### 3) 환경 속성 (Environment)

**핵심 질문**:
- **어디서** 실행되나?
- **플랫폼** 제약은?
- **보안** 요구사항은?

**Layer 2 매핑**:
- L2-Q3 = A(never) → "온프레미스, VPC, 물리적 격리"
- L2-Q3 = B(암호) → "클라우드, 논리적 격리, 암호화"

#### 속성 질문 체크리스트

각 주요 기능별로 다음 질문에 답하세요:

**성능 (Performance)**
- [ ] 응답 시간은? (ms? 초?)
- [ ] 동시 사용자 수는?
- [ ] 데이터 처리량은? (QPS, TPS)
- [ ] 데이터 크기는?

**품질 (Quality)**
- [ ] 실패 시 영향은? (치명적? 괜찮음?)
- [ ] 정확도 vs 유용성? (어느 것 우선?)
- [ ] 가용성은? (99%? 99.9%? 99.99%?)
- [ ] 일관성은? (즉시? 최종?)

**환경 (Environment)**
- [ ] 실행 환경은? (클라우드? 로컬? 브라우저?)
- [ ] 플랫폼 제약은? (OS? 네트워크?)
- [ ] 보안 요구사항은?
- [ ] 규제 준수는? (GDPR? HIPAA?)

#### 템플릿

```markdown
## 2단계: 속성 질문

### Layer 2 NFR 프로파일 (핵심정의에서)
- L2-Q1: [핵심 품질]
- L2-Q2: [규모 특성]
- L2-Q3: [데이터 노출]
- L2-Q4: [데이터 최신성]

### 기능 A: [이름]

#### 성능 속성
**Q1**: 얼마나 빨라야 하나? (← L2-Q1, L2-Q4)
**A1**: [구체적 수치]

**Q2**: 동시에 몇 명? (← L2-Q2)
**A2**: [구체적 수치]

**Q3**: 데이터 양은?
**A3**: [구체적 수치]

**→ NFR**:
- [요구사항 1]
- [요구사항 2]

#### 품질 속성
**Q1**: 실패하면? (← L2-Q1)
**A1**: [영향도]

**Q2**: 얼마나 정확? (← L2-Q1)
**A2**: [정확도 vs 유용성]

**Q3**: 가용성은?
**A3**: [SLA]

**→ NFR**:
- [요구사항 1]
- [요구사항 2]

#### 환경 속성
**Q1**: 어디서 실행? (← L2-Q3)
**A1**: [환경]

**Q2**: 플랫폼 제약?
**A2**: [제약사항]

**Q3**: 보안 요구사항? (← L2-Q3)
**A3**: [보안 수준]

**→ NFR**:
- [요구사항 1]
- [요구사항 2]
```

### 4-4. 🔥 충돌 패턴 감지 및 복합 요구사항 함정

#### 목적
Layer 2 NFR 프로파일에서 발견된 **충돌 패턴**을 구현방법에서 해결

핵심정의의 Layer 2에서 "충돌 감지 메커니즘"이 작동했다면, 구현방법 단계에서 **구체적 해결책**을 도출해야 합니다.

#### 충돌 패턴 1: 속도 + 즉시성 = 동기식 불가능

**핵심정의 Layer 2 결과**:
```
L2-Q1: B (가장 빠름 - p99 < 500ms)
L2-Q4: A (즉시 반영 - 수 초 이내)

문제: 동기식으로는 불가능!
→ 트레이드오프 질문: "최종일관성(수 초 지연)을 수용할 수 있나?"
```

**구현방법 2단계 해결**:
```
속성 질문:
Q: "API 응답 시간은?" → A: "p99 < 500ms"
Q: "데이터 최신성은?" → A: "수 초 지연 허용"

→ NFR 도출:
- API 응답: < 500ms (동기 불가능)
- 데이터 반영: 최종일관성 (수 초)

→ 기술 옵션 (4단계):
  옵션 1: Kafka + 비동기 Workers ✅
  옵션 2: 동기식 처리 ❌ (500ms 초과)
  옵션 3: 배치 처리 ❌ (최신성 미충족)

→ 권장안: Kafka 기반 비동기 아키텍처
  - API: 즉시 202 Accepted 응답 (< 100ms)
  - Workers: 백그라운드 처리 (수 초)
  - 대가: 최종일관성 (Eventually Consistent)
```

**ADR 연결**:
```
ADR-002: Kafka 기반 비동기식 수집
Context: API 응답 < 500ms + 데이터 즉시 반영 충돌
Decision: Kafka + Workers 채택
Consequences: 최종일관성 수용 (수 초 지연)
```

#### 충돌 패턴 2: 규모 + 보안 = 물리적 격리 불가능

**핵심정의 Layer 2 결과**:
```
L2-Q2: C (API - 수천 테넌트)
L2-Q3: A (절대 격리 - 물리적 분리)

문제: 수천 테넌트를 물리적으로 분리 불가능!
→ 트레이드오프 질문: "논리적 격리를 수용할 수 있나?"
```

**구현방법 2단계 해결**:
```
속성 질문:
Q: "동시 사용자 수는?" → A: "수천 테넌트"
Q: "보안 요구사항은?" → A: "테넌트 간 데이터 격리"

→ NFR 도출:
- 멀티 테넌시: 수천 테넌트 지원
- 데이터 격리: 논리적 격리 (암호화)

→ 기술 옵션 (4단계):
  옵션 1: 공유 DB + 논리적 격리 ✅
    - tenant_id 필드
    - Row-level Security (RLS)
    - 암호화 (at-rest, in-transit)
  옵션 2: 테넌트별 DB ❌ (수천 개 DB 불가능)
  옵션 3: 온프레미스 ❌ (API 서비스 불가)

→ 권장안: 공유 DB + RLS + 암호화
  - PostgreSQL RLS 정책
  - 테넌트별 암호화 키
  - 대가: 물리적 격리 불가 (논리적 격리만)
```

**ADR 연결**:
```
ADR-003: 멀티 테넌시 격리 전략
Context: 수천 테넌트 + 데이터 격리 필요
Decision: 공유 DB + Row-level Security
Consequences: 논리적 격리 (물리적 격리 불가)
```

#### 충돌 패턴 3: 정확성 + 비용 = 수동 검증 필요

**핵심정의 Layer 2 결과**:
```
L2-Q1: A (정확성 최우선 - 100%)
L2-Q2: A (B2B - 10개사)

문제: 100% 자동화는 비용 과다!
→ 트레이드오프 질문: "수동 검증을 수용할 수 있나?"
```

**구현방법 2단계 해결**:
```
속성 질문:
Q: "실패하면?" → A: "치명적 (법적/금전)"
Q: "동시 사용자?" → A: "10개사"

→ NFR 도출:
- 정확성: 100% (실패 불가)
- 규모: 10개사 (수동 가능)

→ 기술 옵션 (4단계):
  옵션 1: AI 생성 + 수동 검증 ✅
    - AI: 초안 생성
    - Human: 최종 승인
  옵션 2: 100% 자동화 ❌ (100% 정확성 불가)
  옵션 3: 100% 수동 ❌ (비효율적)

→ 권장안: Hybrid (AI + Human-in-the-loop)
  - AI: 80% 작업 자동화
  - Human: 20% 검증 및 승인
  - 대가: 완전 자동화 불가
```

#### 복합 요구사항 함정

**함정 1: "빠르고 정확하고 저렴하게" (불가능한 삼각형)**
```
요구사항:
- 속도: p99 < 100ms
- 정확성: 100%
- 비용: 최소화

문제: 3가지 모두 불가능!

해결:
→ Layer 2 L2-Q1에서 우선순위 결정 필수
  - 정확성 우선 → 속도/비용 희생
  - 속도 우선 → 정확성 희생 (캐싱)
  - 비용 우선 → 속도/정확성 희생
```

**함정 2: "실시간 + 완벽한 일관성" (CAP 정리)**
```
요구사항:
- 지연 시간: < 100ms
- 일관성: Strong Consistency

문제: CAP 정리 위반!

해결:
→ Layer 2 L2-Q4에서 명확히
  - 실시간 우선 → 최종일관성 (Eventual)
  - 일관성 우선 → 지연 시간 증가
```

**함정 3: "확장성 + 단순성"**
```
요구사항:
- 확장성: 1M QPS
- 단순성: 단일 서버

문제: 모순!

해결:
→ Layer 2 L2-Q2에서 실제 규모 확인
  - 실제: B2B 10개사 → 단순 우선 ✅
  - 실제: API 수천 → 확장성 우선 ✅
```

#### 템플릿

```markdown
### 충돌 패턴 해결

#### Layer 2 충돌 (핵심정의에서)
**충돌**: [L2-Qx + L2-Qy]
**트레이드오프**: [선택한 것]

#### 구현방법 해결책

**속성 질문 (2단계)**:
- Q1: [질문] → A1: [답변]
- Q2: [질문] → A2: [답변]

**NFR 도출**:
- [요구사항 1]
- [요구사항 2]

**기술 옵션 (4단계)**:
- 옵션 1: [기술] ✅ [이유]
- 옵션 2: [기술] ❌ [이유]

**권장안**: [선택한 기술]
**대가**: [수용한 트레이드오프]

**ADR 연결**: ADR-00X: [제목]
```

### 4-5. 3단계: 제약조건 파악

#### 목적
현실적 제약 사항을 식별하여 **실현 가능한** 설계 도출

#### 4가지 주요 제약

##### 1) 팀 역량 제약

**질문**:
- 우리 팀이 익숙한 기술은?
- 새로운 기술을 배울 시간이 있나?
- 운영 경험이 있는가?

##### 2) 비용/시간 제약

**질문**:
- 예산은 얼마나?
- 개발 기간은?
- 인프라 비용은?

##### 3) 기존 시스템 제약

**질문**:
- 기존 시스템과 통합해야 하나?
- 레거시 데이터 마이그레이션?
- 기존 인증 시스템 활용?

##### 4) 규제/정책 제약

**질문**:
- 보안 정책은?
- 데이터 저장 위치 제약?
- 규제 준수 사항?

#### 템플릿

```markdown
## 3단계: 제약조건 파악

### 팀 역량
**현재 역량**:
- [기술 1]: [경험 수준]
- [기술 2]: [경험 수준]

**제약**:
- [제약 1]
- [제약 2]

**영향**:
- [기술 선택에 미치는 영향]

### 비용/시간
**예산**: [금액]
**기간**: [개월]
**인프라**: [월 비용]

**제약**:
- [제약 1]
- [제약 2]

### 기존 시스템
**연동 필요**:
- [시스템 1]: [버전/제약]
- [시스템 2]: [버전/제약]

**제약**:
- [제약 1]
- [제약 2]

### 규제/정책
**준수 사항**:
- [규제 1]
- [규제 2]

**영향**:
- [기술/아키텍처 제약]
```

### 4-6. 4단계: 기술 옵션 탐색

#### 목적
**속성(2단계)**과 **제약(3단계)**을 바탕으로 기술 옵션을 비교하고 권장안 도출

#### 프로세스

**각 주요 기능별로**:
1. 속성과 제약을 만족할 수 있는 옵션 3개 도출
2. 각 옵션의 장단점 분석 (속성 충족도 중심)
3. 권장안 선정 (근거 명확히)

#### 템플릿

```markdown
## 4단계: 기술 옵션 탐색

### 기능 A: [이름]

**속성 요구사항 (2단계에서)**:
- [NFR 1]
- [NFR 2]

**제약 조건 (3단계에서)**:
- [제약 1]
- [제약 2]

---

#### 옵션 1: [기술명]

**장점**:
- [장점 1]
- [장점 2]

**단점**:
- [단점 1]
- [단점 2]

**속성 충족도**:
- [NFR 1]: ✅/❌/⚠️ ([설명])
- [NFR 2]: ✅/❌/⚠️ ([설명])

**비용**: [예상 비용]

---

#### 옵션 2: [기술명]
[동일 구조]

---

#### 옵션 3: [기술명]
[동일 구조]

---

**권장안**: 옵션 [번호] ([기술명])

**근거**:
1. 속성 충족도: [설명]
2. 제약 충족도: [설명]
3. 추가 고려사항: [설명]
```

### 4-7. 5단계: 통합 설계

#### 목적
개별 기술 선택을 **하나의 시스템**으로 통합

#### 3가지 산출물

##### 1) 시스템 아키텍처

전체 시스템의 구조와 컴포넌트 간 관계

##### 2) 데이터 스키마 v1.0

초기 버전의 데이터 모델

##### 3) API 설계 v1.0

주요 인터페이스 정의

#### 템플릿

```markdown
## 5단계: 통합 설계

### 시스템 아키텍처

```
[ASCII 다이어그램]
```

**컴포넌트 설명**:
- **[컴포넌트 1]**: [역할]
- **[컴포넌트 2]**: [역할]

**통신 방식**:
- [A → B]: [프로토콜/방식]

---

### 데이터 스키마 v1.0

```sql
-- [테이블 1]
CREATE TABLE ...

-- [테이블 2]
CREATE TABLE ...
```

**설계 원칙**:
- [원칙 1]
- [원칙 2]

**진화 계획**:
- v1.0: [현재 충분한 이유]
- v2.0 예정: [향후 추가 가능]

---

### API 설계 v1.0

#### [API 그룹 1]
```
GET /api/...
POST /api/...
```

#### [API 그룹 2]
```
Event: ...
Data: ...
```

**설계 원칙**:
- [원칙 1]
- [원칙 2]
```

### 4-8. Amazon 방법론과의 연결

우리의 5단계 프로세스는 Amazon의 3단계 Use-Case Driven Architecture와 다음과 같이 대응됩니다:

```
┌────────────────────────────────────────────┐
│ Amazon 1단계: Identify Use Cases          │
│ (사용 사례 식별)                           │
└────────────────────────────────────────────┘
                    ↓
        ┌───────────────────────────┐
        │  핵심정의 작성 가이드       │
        │  (3-Layer 질문 구조)       │
        └───────────────────────────┘
                    ↓
┌────────────────────────────────────────────┐
│ Amazon 2단계: Specify Concrete Requirements│
│ (구체적 요구사항 도출)                      │
└────────────────────────────────────────────┘
                    ↓
        ┌───────────────────────────┐
        │  구현방법 작성 가이드       │
        │  (5단계 프로세스)          │
        │                           │
        │  1. 기능 분해              │
        │  2. 속성 질문 ⭐          │
        │     (Layer 2 NFR 매핑)    │
        │  3. 제약조건 파악          │
        │  4. 기술 옵션 탐색         │
        │  5. 통합 설계              │
        └───────────────────────────┘
                    ↓
┌────────────────────────────────────────────┐
│ Amazon 3단계: Select Tools & Infrastructure│
│ (기술 선택 및 구현)                         │
└────────────────────────────────────────────┘
                    ↓
        ┌───────────────────────────┐
        │  ADR (결정 기록)           │
        └───────────────────────────┘
```

**핵심 통찰**:

1. **속성 질문이 핵심**
   - Amazon 2단계 "Specify Concrete Requirements"의 본질
   - Layer 2 NFR 프로파일 → 속성 질문으로 변환
   - "어떻게 사용할지"를 구체적 수치로 변환
   - 이것 없이는 기술을 올바르게 선택할 수 없음

2. **순서가 중요**
   - 기능 → 속성 → 기술 (순방향만 가능)
   - 기술 → 속성 → 기능 (역방향은 "이력서 주도 개발")

3. **ADR은 결과의 기록**
   - ADR은 2단계(구현방법)의 탐색을 기록
   - ADR이 탐색을 대체하는 것이 아님

---

## 5. 작성 프로세스

### 5-1. 실제 사용 사례 수집

**목적**: 구체적 시나리오 파악

**방법**:
```
1. AI가 질문: "언제 이 시스템을 사용하나요?"
2. Jason이 답변: 구체적 상황 6-10개
3. AI가 기록: 각 사례별 상세 내용
4. AI가 확인: "이 경우는?" (추가 시나리오)
```

**좋은 사례**:
```
✅ "2호와 작업하다가 퇴근 시간.
    집에서 1호와 이어가고 싶음"

✅ "예전에 비슷한 문제 겪었는데
    어떻게 해결했는지 기억 안 남"
```

**나쁜 사례**:
```
❌ "정보를 저장하고 싶을 때" (너무 추상적)
❌ "필요할 때" (언제가 필요?)
```

### 5-2. 사례별 시나리오 작성

**각 사례별로**:
```
□ 언제: 구체적 상황
□ 저장: 어떤 정보?
□ 검색: 어떻게 찾기?
□ 결과: 몇 개? 어떤 순서?
□ 제약: 성능? 컨텍스트?
```

### 5-3. 공통 패턴 추출

**방법**:
```
1. 모든 사례 나열
2. 공통 요소 표시
3. 차이점 분석
4. 필수/선택 구분
```

### 5-4. 점진적 구체화

**원칙**: 완벽 추구 금지

```
v1.0 (현재 충분):
- 필수 필드만
- 6가지 사례 커버
- 진화 가능 구조

v2.0 (나중에):
- 추가 필드
- 더 많은 사례
- 고급 기능
```

**Jason의 조언**:
> "지금은 충분해요. 이후 검토하면서 더 늘어날 수도 있고 변경도 있겠죠."

---

## 6. 템플릿

### 6-1. Stage 2 문서 템플릿

```markdown
# [프로젝트명] - Stage 2 (구현 방법)

**작성일**: YYYY-MM-DD
**기반**: Stage 1 문서

---

## Layer 2 NFR 프로파일 (핵심정의에서)

- L2-Q1: [핵심 품질]
- L2-Q2: [규모 특성]
- L2-Q3: [데이터 노출]
- L2-Q4: [데이터 최신성]
- 충돌: [있다면 설명]

---

## 1단계: 기능 분해

[템플릿 참고]

---

## 2단계: 속성 질문

### Layer 2 NFR → 속성 질문 매핑
[매핑 표 작성]

### 기능별 속성 질문
[각 기능별로 성능/품질/환경 속성 질문]

---

## 3단계: 제약조건 파악

[팀 역량, 비용/시간, 기존 시스템, 규제/정책]

---

## 4단계: 기술 옵션 탐색

[각 기능별로 옵션 3개 비교 + 권장안]

### 충돌 패턴 해결 (있다면)
[Layer 2 충돌 → 구현방법 해결책]

---

## 5단계: 통합 설계

[아키텍처 + 스키마 v1.0 + API v1.0]

---

## Stage 2 완료 체크리스트

```
□ 5단계 모두 작성
□ Layer 2 NFR → 속성 질문 매핑 완료
□ 충돌 패턴 해결 (있다면)
□ 사용 사례 6개 이상
□ 스키마 v1.0 도출
□ 기술 옵션 비교 및 권장안
□ 통합 설계 완료
□ ADR 준비 완료
```

---

## 다음 단계

→ **ADR (기술 결정) 작성**
```

### 6-2. 체크리스트

**시작 전**:
```
□ Stage 1 완료?
□ Layer 2 NFR 프로파일 확인?
□ 충돌 패턴 있는지 확인?
□ Trade-off 결정 상기?
```

**진행 중**:
```
□ Layer 2 NFR → 속성 질문 매핑 완료?
□ 사용 사례 6개 이상 수집?
□ 각 사례별 시나리오 작성?
□ 기술 질문 → 경험 질문 전환?
□ 공통 패턴 추출?
□ 충돌 패턴 해결책 도출? (있다면)
□ 초기 스키마 도출?
□ 기술 옵션 3개 비교?
□ 권장안 근거 명확?
□ 통합 설계 완료?
```

**완료 후**:
```
□ 5단계 모두 완료?
□ NFR 모두 충족?
□ 충돌 해결 완료? (있다면)
□ v1.0 충분? (진화 가능?)
□ ADR 준비 완료?
```

---

## 7. 다음 단계

### 7-1. 실전 사례 참고

**상세한 사례 분석**은 별도 문서를 참고하세요:

📄 **[02-1_IMPLEMENTATION_CASES.md](./02-1_IMPLEMENTATION_CASES.md)** (실전 사례집)

다음 3가지 사례를 5단계 프로세스로 완전 분석:
1. **문서 자동생성** (결정론적 시스템)
   - Layer 2 NFR: 정확성 최우선, B2B, 온프레미스
   - 충돌 패턴: 없음
   - 5단계 프로세스 적용 예시

2. **AI 외부 메모리** (확률론적 시스템)
   - Layer 2 NFR: 속도 최우선, API, 클라우드
   - 충돌 패턴: 속도 + 즉시성 → 비동기 아키텍처
   - 충돌 해결 과정 상세 분석

3. **채팅 애플리케이션** (실시간 시스템)
   - Layer 2 NFR: 가용성 우선, B2C, 브라우저
   - WebSocket 기술 선택 근거
   - ADR로의 전환 예시

### 7-2. ADR로 전환

**진입 조건**:
```
✅ 구현방법 완료 (5단계)
✅ Layer 2 NFR → 속성 질문 매핑 완료
✅ 충돌 패턴 해결 완료 (있다면)
✅ 기술 옵션 비교 완료
✅ 권장안 도출 완료
```

**ADR 목표**:
```
구현방법: "Redis 8" (방향) + "옵션 3개 비교" (탐색)
    ↓
ADR: "왜 Redis 8?"
     "PostgreSQL vs Redis vs Neo4j"
     "각각의 Trade-off"
     "선택 근거"
     (탐색 과정을 문서화)
```

### 7-3. ADR 준비사항

**질문 목록**:
```
□ 왜 [기술 A]? (vs [대안 B], [대안 C])
□ 4단계의 옵션 비교를 ADR로 전환
□ 각 선택의 Trade-off는?
□ 충돌 패턴 해결책을 ADR로 기록
□ 대가(Consequences)를 명확히
```

**다음 단계**:
```
구현방법 (완료): 구현 방법 + 기술 탐색
    ↓
ADR: 기술 결정 근거 기록
    ↓
Blueprint: 구체적 설계
    ↓
SPARK: 자동화된 실행
```

---

## 참고 문서

### 관련 가이드
- [01_CORE_DEFINITION_GUIDE.md](./01_CORE_DEFINITION_GUIDE.md) - 이전 단계 (3-Layer 질문 구조)
- [02-1_IMPLEMENTATION_CASES.md](./02-1_IMPLEMENTATION_CASES.md) - 실전 사례집 ⭐
- [03_ADR_GUIDE.md](./03_ADR_GUIDE.md) - 다음 단계 (기술 결정 기록)
- [05_BLUEPRINT_GUIDE.md](./05_BLUEPRINT_GUIDE.md) - 구체적 설계

### 실전 사례
- `memory_프로젝트_재구성_Level2_완료_20251110.md` - 전체 세션
- `00_종합분석_7개프로젝트_패턴분석_20251110.md` - 실패 분석
- `Gemini_아키텍처_정의_질문_구조화_리서치.md` - ADQs 리서치
- `Gemini_AI외부메모리_아키텍처_설계_프로세스.md` - 충돌 패턴 사례

---

**구현방법 작성 가이드 (Implementation Approach Guide) v2.0** - 2025-11-11

이전: [핵심정의 작성 가이드 (Core Definition Guide)](./01_CORE_DEFINITION_GUIDE.md)
다음: [ADR (기술 결정) 가이드](./03_ADR_GUIDE.md)
사례집: [실전 사례집 (Implementation Cases)](./02-1_IMPLEMENTATION_CASES.md)
