# 패밀리별 기술 매트릭스 작성 가이드

**작성일**: 2025-11-12
**목적**: 7개 아키텍처 패밀리별 기술 매트릭스 일관성 유지

---

## 🎯 매트릭스의 역할: DNA 방법론의 핵심 연결고리

### DNA 방법론에서 이 매트릭스의 위치

```
Stage 1: 패밀리 구분 (A-A-B, B-C-A 등)
  ↓
🔥 이 매트릭스가 바로 여기! 🔥
  ↓
Stage 2: 구조설계 (Layer 3 + 충돌 + 5단계)
  ↓
Stage 3: ADR 작성 (Bootstrap + 도메인)
  ↓
Stage 4~9: 청사진 → 분해 → 체크리스트 → 구현
```

### 매트릭스의 3가지 핵심 역할

#### 1. 시스템 영역 구별 → 필수 기술 자동 결정

**패밀리 특성이 기술을 강제합니다**:

```
A-A-B (트랜잭션/CRUD):
- A (치명적) + A (구조화) + B (수초)
→ 필수: RDBMS, 캐시, 메시징
→ 자동으로 PostgreSQL/MySQL 비교하게 됨

B-C-A (실시간 스트리밍):
- B (점진적) + C (비구조화) + A (밀리초)
→ 필수: 스트리밍, 시계열 DB, 캐시
→ 자동으로 Kafka/Kinesis 비교하게 됨
```

**핵심**: 개발자가 "뭘 써야 하지?"를 고민하는 게 아니라,
**패밀리가 정해주면 선택지가 자연스럽게 좁혀집니다!**

---

#### 2. Bootstrap vs 도메인 구분

**매트릭스는 두 종류의 기술을 명확히 구분합니다**:

**Bootstrap 요소** (패밀리가 강제):
- A-A-B → RDBMS, 캐시, 메시징 (필수!)
- B-C-A → 스트리밍, 시계열 DB, 캐시 (필수!)
- 이걸 선택 안 하면 시스템 본질이 깨짐
- → **Bootstrap ADR 작성 대상**

**도메인 요소** (프로젝트별 변수):
- 프론트엔드 프레임워크 (React vs Vue)
- 백엔드 언어 (Node.js vs Python)
- 인증/권한 (Auth0 vs Cognito)
- 패밀리와 무관, 팀 역량/선호도에 따름
- → **도메인 ADR 작성 대상**

**왜 중요한가?**
- Bootstrap ADR = 전체 프로젝트 공통 (common/ 폴더)
- 도메인 ADR = 프로젝트 특화 (services/ 폴더)
- Stage 3에서 이걸 구분 못 하면 → ADR이 뒤죽박죽!

---

#### 3. 다음 단계로 연결

**이 매트릭스를 통해 선택한 기술들이**:

**→ Stage 3: ADR 작성**
```
Bootstrap ADR (예시):
- ADR-001: PostgreSQL 선택 (MySQL vs CockroachDB)
- ADR-002: Redis 선택 (Memcached 대비)
- ADR-003: RabbitMQ 선택 (Kafka vs SQS)

도메인 ADR (예시):
- ADR-101: FastAPI 선택 (Django vs Flask)
- ADR-102: React 선택 (Vue vs Svelte)
- ADR-103: Auth0 선택 (Cognito vs 자체 구현)
```

**→ Stage 4: 청사진 작성**
```
Bootstrap 청사진 (common/):
- PostgreSQL 스키마 설계
- Redis 캐싱 전략
- RabbitMQ 메시지 구조

도메인 청사진 (services/):
- 주문 서비스 API 설계
- 사용자 서비스 인증 흐름
- 알림 서비스 이벤트 처리
```

**→ Stage 5~9: 분해 → 체크리스트 → 구현**

---

### 정리: 이 매트릭스가 없으면?

❌ **매트릭스 없이**:
```
개발자: "뭘 써야 하지? PostgreSQL? MongoDB? Redis? Kafka?"
→ 무한 고민 → 잘못된 선택 → 나중에 갈아엎기
→ ADR도 엉망 → 청사진도 엉망 → 구현도 엉망
```

✅ **매트릭스 있으면**:
```
1. 패밀리 구분 (A-A-B) → 매트릭스 참고
2. Bootstrap 요소 자동 도출 (RDBMS, 캐시, 메시징)
3. 3가지 옵션 비교 → 의사결정 플로우차트
4. 선택 완료 → Bootstrap/도메인 구분
5. ADR 작성 → 청사진 작성 → 구현
→ 체계적이고 정확한 기술 선택!
```

**이것이 DNA 방법론의 힘입니다!** 💪

---

## ⚠️ 가장 중요한 원칙

**이 문서는 "기술 선택 매트릭스"입니다!**

### ✅ 목적: 기술 **선택** 지원

개발자가 기술을 **선택**할 수 있게 돕는 것:
- 어떤 DB를 쓸까? (PostgreSQL vs MySQL vs CockroachDB)
- 어떤 캐시를 쓸까? (Redis vs Memcached)
- 어떤 메시징을 쓸까? (Kafka vs RabbitMQ vs SQS)

**필요한 정보**:
- 스펙 (처리량, 레이턴시, 구체적 수치)
- 비용 (월 $XXX~$XXX)
- 트레이드오프 (장단점)
- 비교표 + 플로우차트

### ❌ 목적 아님: 구현 가이드

**절대 포함하지 말 것**:
1. ❌ **코드 예시** (단 한 줄도!)
   - Cache-Aside 패턴 코드
   - 메시징 패턴 코드
   - API 호출 예시
   - 설정 코드

2. ❌ **도구/생태계 나열**
   - ORM 목록 (Prisma, TypeORM, SQLAlchemy...)
   - GUI 도구 (pgAdmin, DBeaver...)
   - 클라이언트 라이브러리 (node-redis, ioredis...)
   - 마이그레이션 도구 (Flyway, Liquibase...)

3. ❌ **패턴 설명**
   - Cache-Aside vs Write-Through vs Write-Behind
   - Pub/Sub vs Task Queue
   - CQRS, Event Sourcing 등

4. ❌ **설정/구현 방법**
   - 설정 파일 예시
   - 배포 스크립트
   - 튜닝 가이드

**이유**: 이런 내용은 구현 단계에서 각 기술의 공식 문서를 보면 됩니다!

---

## 🔍 정보 수집 방법

### ✅ 필수: Context7 MCP 사용

**모든 기술 정보는 Context7 MCP에서 확보해야 합니다.**

**이유**:
- 토큰 효율 6~10배 (WebSearch 대비)
- 출처 확인된 공식 문서만 사용
- 600~800줄 문서 작성 가능 (WebSearch는 불가능)

**사용 방법**:
1. `resolve-library-id("기술명")` → 라이브러리 ID 확인
2. `get-library-docs("/org/project", topic="주제")` → 핵심 정보 추출

**예시**:
```
PostgreSQL 성능:
get-library-docs("/postgresql/postgresql", topic="performance")

Redis 가격:
get-library-docs("/redis/redis", topic="pricing")

Kafka 벤치마크:
get-library-docs("/apache/kafka", topic="benchmarks")
```

### ❌ 금지: WebSearch

**절대 사용하지 말 것!**

**이유**:
- 토큰 10~30K/회 소비 (Context7의 10배)
- 3~4회 검색으로 컨텍스트 절반 소진
- 문서 작성 불가능 → 세션 중단

**예외**: 없음. Context7에 없으면 Jason에게 확인

---

## ✅ 데이터 신뢰성 원칙

**반드시 출처가 확인된 사실과 데이터를 기반으로 작성해야 합니다.**

### 1. 공식 문서 우선
- PostgreSQL 공식 문서
- Redis 공식 문서
- AWS 공식 문서
- Kafka 공식 문서

### 2. 검증된 벤치마크
- Netflix Tech Blog
- Uber Engineering Blog
- Confluent Benchmark
- AWS Architecture Blog

### 3. 구체적 수치 필수
- ✗ "빠름" → ✓ "p99 <10ms"
- ✗ "저렴함" → ✓ "$25/월"
- ✗ "대기업" → ✓ "Netflix, Uber"
- ✗ "많이 사용" → ✓ "초당 100만 메시지"

### 4. 추측 금지
- ❌ "아마도"
- ❌ "대략"
- ❌ "보통"
- ❌ "일반적으로"

**Context7 → 공식 문서 → 구체적 수치 → 사실만!**

---

## 🎯 목표

패밀리 → Bootstrap 요소 → 기술 선택 흐름을 명확히 보여주기

---

## 📐 핵심 논리

```
패밀리 특성 (L1-Q1, Q2, Q3)
  ↓
시스템 구조 강제 (무엇이 필수인가?)
  ↓
Bootstrap 요소 (2~5개)
  ↓
각 요소별 3가지 기술 옵션
  ↓
도메인 특화 (프로젝트별 변수)
```

**핵심**: 패밀리가 다르면 Bootstrap 요소가 다름!

### 패밀리별 Bootstrap 예시
- **A-A-A**: RDBMS, ORM, 트랜잭션 관리, 캐시
- **B-C-A**: 스트리밍, 시계열 DB, 캐시
- **A-C-A**: RDBMS, WebSocket, Queue, 캐시
- **C-B-B**: Vector DB, Embedding, 검색엔진
- **B-A-A**: RDBMS, WebSocket, 동기화 엔진
- **C-C-C**: 데이터 레이크, 분석 엔진, 시각화
- **X-X-X**: Layer 3 의존성 높음 (특수 케이스)

---

## ✅ 4-Part 구조 (B-C-A 예시 참고)

### Part 1: 패밀리가 요구하는 시스템 구조 ⭐⭐⭐

**1.1 [패밀리] 특성이 강제하는 것**
- 각 특성(B/C/A 등) → 기술적 요구사항 매핑
- 검증 사례 1~2개 인용 (Netflix, Uber 등)

**1.2 Bootstrap 필수 요소 (패밀리 강제)**
- 필수 요소 목록 (2~5개)
- 각 요소의 역할, 이유, 선택지

**핵심**: "패밀리 → 시스템 구조" 연결고리를 명확히!

---

### Part 2: Bootstrap 요소별 기술 선택 ⭐⭐⭐

각 Bootstrap 요소마다 **3가지 옵션** 제시:

#### 옵션 1: 고성능/고비용
- **핵심 스펙**: 처리량, 레이턴시 (구체적 수치!)
- **아키텍처**: 간단한 다이어그램
- **비용**: 월 $XXX~$XXX
- **배포 & 운영**: 시간, 복잡도
- **장단점**: 구체적으로
- **적합한 경우**: 어떤 프로젝트에?
- **검증 사례**: 실제 기업 인용

#### 옵션 2: 균형 (중간)
동일 구조

#### 옵션 3: 저비용
동일 구조

**필수**: 비교표 + 의사결정 플로우차트

---

### Part 3: 도메인 선택 요소 (프로젝트별)

패밀리와 **무관**하게 프로젝트 요구사항에 따라 선택:
- 프론트엔드 프레임워크
- 백엔드 언어
- 인증/권한
- 모니터링/로깅

**간결하게!** (3~5줄 정도)

---

### Part 4: Stage 2 통합

**4.1 Layer 3 제약 반영 예시**
- 실제 프로젝트 시나리오 (예: 주식 거래)
- 외부 제약 발견
- Bootstrap 기술 선택에 미치는 영향

**4.2 충돌 해결 예시**
- NFR vs Layer 3 제약 충돌
- 트레이드오프 결정
- 해결 방법

**4.3 ADR 작성 준비**
- Bootstrap ADR 목록
- 도메인 ADR 목록

---

## 🔍 작성 원칙

### 1. 실증 데이터 기반
- ✅ Netflix, Uber, Twitter 등 실제 사례
- ✅ 구체적 수치 (처리량, 레이턴시, 비용)
- ✅ 벤치마크 인용

### 2. 의사결정 지원
- ✅ 3가지 옵션 (고/중/저)
- ✅ 비교표 필수
- ✅ 플로우차트 (if-then 논리)

### 3. Stage 2 통합
- ✅ Layer 3 조사 방법론 반영
- ✅ 충돌 패턴 발견 → 해결
- ✅ ADR 작성으로 연결

### 4. DNA 방법론 용어 사용
- ✅ Layer 1, Layer 2, Layer 3
- ✅ Bootstrap vs 도메인
- ✅ NFR 프로파일
- ✅ 9 Stage 구조

---

## 📋 7개 패밀리 작업 계획

### 완료
1. ✅ **B-C-A** (실시간 스트리밍)
   - 파일: `05_real_time_streaming_tech_options.md`
   - Bootstrap: 스트리밍, 시계열 DB, 캐시

### 진행 예정
2. **A-A-A** (CRUD/트랜잭션)
   - Bootstrap: RDBMS, ORM, 트랜잭션 관리, 캐시

3. **C-B-B** (검색/추천)
   - Bootstrap: Vector DB, Embedding, 검색엔진

4. **B-A-A** (협업/동기화)
   - Bootstrap: RDBMS, WebSocket, 동기화 엔진

5. **A-C-A** (실시간 트랜잭션)
   - Bootstrap: RDBMS, WebSocket, Queue, 캐시

6. **C-C-C** (분석/BI)
   - Bootstrap: 데이터 레이크, 분석 엔진, 시각화

7. **X-X-X** (기타/혼합)
   - 특수 케이스 (Layer 3 의존성 높음)

---

## 🎯 골드 스탠다드 (Gold Standard)

**B-C-A 문서 (`05_real_time_streaming_tech_options.md`)를 표준으로 삼습니다.**

### 왜 B-C-A가 표준인가?

✅ **분량**: 640줄 (간결하면서도 충분)
✅ **목적 준수**: 선택 지원에만 집중, 구현 내용 없음
✅ **구조**: 4-Part 완벽 준수
✅ **간결성**: 핵심만, 반복 최소
✅ **실용성**: 비교표 + 플로우차트로 의사결정 지원

**모든 패밀리 문서는 B-C-A 수준을 목표로!**

---

## 📏 구체적 분량 제한

### 전체
- **목표**: 600~800줄
- **최대**: 900줄 (절대 초과 금지)
- **B-C-A 기준**: 640줄

### Part별 제한
- **Part 1**: 100~150줄
- **Part 2**: 300~500줄 (Bootstrap 요소 3~4개 × 100~150줄)
- **Part 3**: 20~50줄 (간결하게!)
- **Part 4**: 150~200줄

### 요소별 제한
- **필수 Bootstrap 요소**: 100~150줄/개
- **선택적 요소**: 50줄 이내
- **각 기술 옵션**: 40~60줄

---

## 💡 주의사항

### ❌ 피할 것
- **과도한 디테일**: Part 2에서 3가지 옵션에만 집중
- **불필요한 반복**: Part 3는 간결하게 (20~50줄)
- **이론적 설명**: 실용성 우선
- **구조 변경**: B-C-A 문서와 동일한 구조 유지
- **분량 초과**: 900줄 절대 초과 금지

### ❌ 절대 포함 금지 (재강조)
1. **코드 예시 전부 삭제**
2. **도구 나열 최소화** (대표 1~2개만 언급)
3. **패턴 설명 금지**
4. **"도구 및 생태계" 섹션 금지**
5. **"요약" 섹션 금지**
6. **"다음 단계" 섹션 금지**

### ✅ 집중할 것
- **구체적 수치**: "빠름" ✗ → "p99 <10ms" ✓
- **실제 사례**: "대기업" ✗ → "Netflix RDG" ✓
- **비용 현실성**: 범위로 제시 ($500~$2K/월)
- **의사결정 지원**: 비교표 + 플로우차트
- **B-C-A와 동일한 톤**: 간결, 실용적, 선택 중심

---

## 각 옵션에 포함할 내용 (정확히 이것만!)

### 각 기술 옵션마다 (40~60줄)

**필수 포함**:
1. **핵심 스펙** (5~10줄)
   - 처리량: 초당 XXX 메시지
   - 레이턴시: p99 <XXms
   - 구체적 수치만!

2. **비용** (3~5줄)
   - 월 $XXX~$XXX
   - 옵션별 비용 범위

3. **장단점** (10~15줄)
   - 장점 3~4개 (구체적으로)
   - 단점 3~4개 (구체적으로)

4. **적합한 경우** (5~10줄)
   - 어떤 프로젝트에?
   - 어떤 규모에?

5. **검증 사례** (1~2줄)
   - 회사명만 (Netflix, Uber 등)

**절대 포함하지 말 것**:
- ❌ 아키텍처 다이어그램 (간단한 것도 불필요)
- ❌ 코드 예시
- ❌ 도구 나열 (ORM, GUI 등)
- ❌ "의사결정 가이드" 반복 (비교표/플로우차트로 통합)
- ❌ 배포 & 운영 디테일 (간단히 1줄만)

---

## 📚 참고할 이론적 근거

- **SEI Quality Attributes**: 성능, 확장성, 가용성, 보안
- **Martin Fowler Patterns**: 아키텍처 패턴
- **CAP/ACID/BASE Theorem**: 분산 시스템 특성
- **12-Factor App**: 클라우드 네이티브

---

## 🔄 작업 흐름

1. **B-C-A 문서 읽기** (`05_real_time_streaming_tech_options.md`)
2. **패밀리 특성 파악** (Layer 1 답변)
3. **Bootstrap 요소 도출** (패밀리가 강제하는 것)
4. **3가지 옵션 조사** (실증 데이터 수집)
5. **4-Part 구조로 작성**
6. **비교표 + 플로우차트 추가**
7. **검토**: 체크리스트 확인

---

## ✅ 완성도 체크리스트

### 제출 전 필수 확인

**분량 체크**:
- [ ] 전체 600~800줄 (최대 900줄)
- [ ] Part 1: 100~150줄
- [ ] Part 2: 300~500줄
- [ ] Part 3: 20~50줄
- [ ] Part 4: 150~200줄

**금지 사항 체크** (하나라도 있으면 ❌):
- [ ] 코드 예시 **없음**
- [ ] 도구 나열 **최소화** (대표 1~2개만)
- [ ] 패턴 설명 **없음**
- [ ] "도구 및 생태계" 섹션 **없음**
- [ ] "요약" 섹션 **없음**
- [ ] "다음 단계" 섹션 **없음**
- [ ] 아키텍처 다이어그램 **없음**

**Part 1**:
- [ ] 패밀리 특성 → 시스템 구조 연결 명확
- [ ] 실증 사례 1~2개
- [ ] Bootstrap 필수 요소 목록 (2~5개)

**Part 2**:
- [ ] 각 Bootstrap 요소마다 3가지 옵션
- [ ] 각 옵션 40~60줄
- [ ] 구체적 수치 (처리량, 비용, 레이턴시)
- [ ] 비교표 + 의사결정 플로우차트
- [ ] 검증 사례 (회사명만)

**Part 3**:
- [ ] 도메인 요소와 패밀리 무관성 명시
- [ ] 간결하게 (20~50줄)

**Part 4**:
- [ ] Layer 3 제약 반영 예시 (간결)
- [ ] 충돌 패턴 → 해결 방법 (1~2개만)
- [ ] ADR 작성 준비 (목록만)

**전체**:
- [ ] DNA 방법론 용어 일관성
- [ ] B-C-A 문서 구조와 일치
- [ ] "선택 지원"에만 집중, "구현" 내용 없음
- [ ] 개발자가 기술 선택 가능한 수준
- [ ] B-C-A와 동일한 톤 (간결, 실용적)

---

**골드 스탠다드**: `05_real_time_streaming_tech_options.md` (B-C-A) - 반드시 참고!
**질문 있으면 Jason에게!**
