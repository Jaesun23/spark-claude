# Phase 2: 복합 시스템 도전 - 주식 거래 플랫폼

**날짜**: 2025-11-12
**참여자**: Jason + 2호 (Claude Code)
**목적**: 3-Layer 프레임워크로 복합 시스템 분석 도전

---

## 🎯 현재 상황

### Phase 1 완료 ✅
- ✅ 이론적 매핑 완료 (ARCHITECTURE_THEORY_MAPPING.md)
- ✅ Layer 2 ↔ SEI Quality Attributes 검증
- ✅ Layer 1 ↔ Martin Fowler Patterns 검증
- ✅ 충돌 패턴 ↔ CAP/ACID/BASE 검증

### Phase 2 시작 🔄
- 목표: 실시간 스트리밍 패밀리 (패밀리 3) 사례 추가
- 선정: **주식 거래 플랫폼** (Jason이 나중에 실제 만들 시스템)

---

## 🔥 핵심 도전 과제 발견

### 복합 시스템의 복잡도

**시스템 구성**:
```
주식 거래 플랫폼 = 복합 시스템
├─ 1. 실시간 호가 스트리밍 (부가 기능)
│  └─ 역할: 최신 가격 정보 제공
│
└─ 2. 거래 (핵심 기능) 💥
   ├─ 구현 방식 A: 수동 거래
   │  └─ 사용자 클릭 → 거래 요청 → 체결
   └─ 구현 방식 B: 자동 거래
      ├─ 전략 1: 지정가 도달 시 매수
      ├─ 전략 2: % 변동 감지 시 매도
      └─ 전략 3: 정기 매수 (적립식)

   실패 영향: 거래 못 함 → 금전 손실 (A)
   → 구현 방식과 무관!
```

**핵심 인사이트**:
- **핵심 기능 = "거래" (하나!)**
- **수동/자동 = "구현 방식" (여러 개)**
- 거래 실패 = 금전 손실 (방식과 무관)

---

## 💡 Jason의 핵심 통찰

### "방법론의 본질"

```
❌ "복잡하니까 시스템을 쪼개자"
   → 구현 편의주의

✅ "3-Layer 질문이 이 복잡도를 해결하는가?"
   → 방법론 검증!
```

**Jason의 원칙**:
> "우리는 엔터프라이즈 기업의 소프트웨어 개발 방법을 연구하고 있어요.
> 복잡도를 떠나서 우리의 질문들이 어떻게 구성되어야
> 이 문제들을 해결할 시스템적 답안으로 이끌 것인가를 찾아야 한다는 거에요."

**검증 질문**:
```
현재 3-Layer 10개 질문으로
복합 시스템을 하나의 일관된 아키텍처로 이끌 수 있는가?

YES → 질문이 잘 설계됨 ✅
NO → 질문 수정/추가 필요 ⚠️
```

---

## 🎯 현재까지 분석 결과

### Layer 1: 아키텍처 패밀리 (핵심 기능 기준)

**판단 원칙**: "핵심 기능"의 **비즈니스 목적**으로 답변 (구현 방식 X)

**L1-Q1: 실패 파급력**
```
핵심 기능 = 거래 (Trading)
- 거래 요청 전달 실패 → 금전 손실
- 원하는 가격에 체결 못 함 → 금전 손실
- 수동/자동 무관, 모든 거래 실패가 치명적

선택: A (치명적) ✅
```

**L1-Q2: 정보 형태**
```
주가, 호가, 거래량 = 숫자 시계열
% 변동 계산, 이동평균
조건 비교 (지정가 도달 여부)

선택: C (숫자·분석 데이터) ✅
```

**L1-Q3: 응답 시점**
```
거래 요청 → 즉시 체결 필요
가격 변동 → 즉시 감지 필요
체결 완료 → 즉시 알림 필요

선택: A (즉각 응답) ✅
```

**→ 패밀리: A-C-A** 💥

**핵심 포인트**:
- ❌ "자동 거래"가 핵심 (구현 방식 기준)
- ✅ "거래 기능"이 핵심 (비즈니스 목적 기준)

### 🔥 중요 발견 1: 새로운 패밀리 패턴!

**기존 5개 패밀리**:
```
1. CRUD/트랜잭션 (A-A-A)
2. 검색/추천 (C-B-B)
3. 실시간 스트리밍 (B-C-A)
4. 협업/동기화 (B-A-A)
5. 분석/배치 (C-C-C)
```

**주식 거래 플랫폼**:
```
A-C-A ← 기존에 없던 조합!
```

**새 패밀리 후보**:
- **"실시간 트랜잭션"** 패밀리?
- 특성: 실패 치명적 + 숫자 데이터 + 즉각 응답
- 예시: 금융 거래, 자동화 시스템, IoT 제어

---

### Layer 2: NFR 우선순위

**L2-Q1: 핵심 품질**
```
A (가장 정확 - 100%) ✅
- 조건 감지 오류 = 금전 손실
- "70,000원 도달" 놓치면 안 됨
```

**L2-Q2: 규모**
```
B (B2C - 동시 1만 명) ✅
- 개인 투자자 플랫폼
```

**L2-Q3: 데이터 노출**
```
B (암호화 - 멀티 테넌트) ✅
- 개인 투자 내역 = 민감 정보
- 금융위원회 규제
```

**L2-Q4: 데이터 최신성**
```
A (즉시 반영 - 초 단위) ✅
- 호가 변동 즉시 반영
- 조건 감지 즉시 체결
```

**NFR 프로파일**: A-B-B-A

### 🔥 중요 발견 2: 충돌 패턴 예상

```
L2-Q1 (정확성 A: 100%) + L2-Q4 (즉시 A: 초 단위)
→ 100% 정확하게 + 즉시 감지/실행?
→ 가능한가? 트레이드오프 있나?
```

**예상 충돌**:
- 조건 감지의 정확성 vs 실시간 처리
- 모든 조건을 실시간으로 100% 정확히 감지 가능한가?

---

## 🤔 현재 질문 및 과제

### 질문 1: 패밀리 분류
- **A-C-A 패턴**을 어떻게 다룰 것인가?
  - 옵션 1: 6번째 패밀리 추가 ("실시간 트랜잭션")
  - 옵션 2: 기존 패밀리에 억지로 매핑
  - 옵션 3: 패밀리 수를 늘리는 게 맞는가?

### 질문 2: 복합 시스템 처리
- ✅ "핵심 기능" 판단 기준 명확화 완료
  - ❌ 구현 방식 (수동/자동)
  - ✅ 비즈니스 목적 (거래)
- 부가 기능(호가 스트리밍)은 어떻게 설계하나?
- Layer 1-2로 핵심 아키텍처 결정 → 부가 기능은 그 안에서 설계

### 질문 3: Layer 3 & 5단계
- Layer 3 (환경 제약) 적용 필요
- 5단계 구현방법 작성
- 충돌 패턴 해결 전략 도출

---

## 📝 다음 단계 (Context 복구 후)

### 1. Layer 3 완료 ✅

**접근 방식**: 내부 결정 사항 먼저 → 외부 제약 조사 → 통합 답변

#### Part 1: 우리가 결정/가정 가능한 항목 ✅

**L3-Q2: 팀 역량 (가정)**
```
팀 구성:
- 백엔드: 1-2명 (Python/Node.js)
- 프론트엔드: 1명 (React/Next.js)
- 금융 도메인 경험: 없음 (학습 필요)

기술 역량:
✅ 일반 웹 개발: 가능
✅ REST API, WebSocket: 가능
❓ 금융 규제 이해: 학습 필요
❓ 보안 인증: 학습 필요
```

**기술 스택 (제약 내 선택 가능)**
```
백엔드:
- FastAPI (Python) 또는 NestJS (Node.js)

프론트엔드:
- Next.js + React

실시간 통신:
- WebSocket (증권사 API 지원 시)
- Server-Sent Events (대안)

데이터:
- Redis (실시간 호가 캐싱)
- PostgreSQL (거래 기록, 사용자)
- TimescaleDB (시계열 데이터)
```

#### Part 2: 외부 제약 조사 완료 ✅

**조사 완료**: `20251112_Layer3_외부제약조사.md` 참고

**증권사 6개 비교 결과**:
```
| 증권사 | 초당 제한 | API 방식 | 개인 사용 |
|--------|-----------|----------|-----------|
| 한투 | 20건 | REST ✅ | 가능 ⭐ |
| 키움 | 5건 | COM/DLL | 가능 (Windows) |
| 이베스트 | 10건 | REST ✅ | 가능 |
| 대신 | ? | COM/DLL | 보안 이슈 ⚠️ |
| NH투자 | ? | QV API | 정보 부족 |
| 삼성 | - | - | 불가능 ❌ |

→ 한국투자증권 선택 (REST, 20건/초, 크로스 플랫폼)
```

**법적 규제 조사 결과**:
```
✅ 개인 사용:
- 5억원 미만 거래: 규제 없음
- 신고/인허가 불필요
- 거래 기록 보관 의무 없음
- 개인정보보호법 미적용

⚠️ 유일한 의무:
- 증권사 API 약관 준수
- 본인 계좌만 사용
- API 키 보안 관리

❌ 서비스화 시:
- 완전히 다른 차원의 규제 발생!
```

---

#### Part 3: Layer 3 최종 답변 (통합)

**L3-Q1: 기술 스택 제약은?**
```
외부 제약 (확정):
✅ 증권사: 한국투자증권
✅ API 방식: REST + WebSocket
✅ Rate Limit: 초당 20건 (실전), 2건 (모의)
✅ WebSocket: 1세션 41건
✅ 인증: 토큰 기반 (Appkey + App secret)
✅ OS: 크로스 플랫폼 (Linux/Docker 가능)
✅ 비용: API 무료

필수 구현:
- 요청 큐잉 시스템 (Redis Queue)
- Throttling (초당 20건 제한)
- WebSocket 구독 관리 (최대 41건)
- 토큰 갱신 자동화

선택 가능 (제약 내):
- 백엔드: FastAPI (Python) 또는 NestJS (Node.js)
- 프론트: Next.js + React
- 데이터: Redis, PostgreSQL, TimescaleDB
```

**L3-Q2: 팀 역량은?**
```
가정:
- 백엔드: 1-2명 (Python/Node.js)
- 프론트: 1명 (React/Next.js)
- 도메인 경험: 없음

필수 학습:
✅ 기술:
   - 증권사 API 사용법
   - WebSocket 실시간 통신
   - Rate Limiting 처리

✅ 보안 (권장):
   - API 키 보안 관리
   - 환경 변수 설정
   - Git 보안 (.gitignore)

❌ 불필요 (개인 사용):
   - 금융 규제 상세
   - KYC 프로세스
   - 개인정보보호법 상세
```

**L3-Q3: 배포 환경은?**
```
자유로운 선택:
✅ 클라우드 (AWS, Azure, GCP) 가능
✅ 로컬 서버 가능
✅ Docker 컨테이너 가능
✅ 한투 API = 크로스 플랫폼 OK

규제 제약 없음:
❌ 데이터 보관 의무 없음 (개인 사용)
❌ 국내 서버 의무 없음
❌ 금융보안원 인증 불필요

권장 사항 (선택):
- 안정적인 인터넷 연결
- 24/7 실행 환경 (거래 시간)
- 백업 (설정, 전략 코드)
```

### 2. 5단계 구현방법 작성
```
1단계: 기능 분해
  - 호가 스트리밍
  - 수동 거래
  - 자동 거래 (3가지 전략)

2단계: 속성 질문 ⭐
  - "조건 감지 정확도는?"
  - "호가 업데이트 지연은?"
  - "체결 응답 시간은?"

3단계: 제약조건
  - 거래소 API 호출 비용
  - 금융위원회 규제

4단계: 기술 옵션 탐색
  - WebSocket vs gRPC
  - Redis vs Kafka
  - 조건 감지 엔진?

5단계: 통합 설계
  - 전체 아키텍처
  - 데이터 흐름
```

### 3. 충돌 패턴 분석
```
충돌: 정확성 (A) + 즉시성 (A)
해결 전략: ???
ADR 작성: ???
```

### 4. Martin Fowler Patterns 매핑
```
A-C-A 패턴 → 어떤 Fowler Pattern?
- 실시간: Gateway (WebSocket)?
- 조건 감지: ???
- 자동 실행: Transaction Script?
```

---

## 🎁 핵심 교훈

### 1. 방법론 검증의 본질
```
❌ "사례를 방법론에 끼워 맞추기"
✅ "방법론이 사례를 해결하는지 검증"
```

### 2. 복잡도는 회피 대상이 아님
```
복잡한 시스템 = 방법론의 진짜 시험대
→ 여기서 막히면 질문 구조 개선 필요
→ 이게 진짜 "이론 검증"
```

### 3. 새로운 패턴 발견 = 성공
```
A-C-A 패턴 발견
→ 기존 5개 패밀리로 부족할 수 있음
→ 방법론 확장의 기회
```

---

## Part 4: 충돌 패턴 발견 및 분석 ⭐

### 🎯 충돌 패턴이란?

```
Layer 2: 이상적 목표 (NFR 우선순위)
         ↓
Layer 3: 현실적 제약 (외부 환경)
         ↓
      충돌 발견!
```

**핵심 원칙**:
- 충돌은 정상이다! (이상 vs 현실)
- 중요한 것: **의식적으로 트레이드오프 결정**
- ADR로 결정 근거 문서화

---

### 📋 Part 4 질문 체크리스트

#### Q4-1: NFR 달성 가능한가?

**Layer 2 목표 검토**:
```
NFR 프로파일: A-B-B-A

L2-Q1: 정확성 A (100% 정확)
→ 조건 감지 오류 = 금전 손실
→ "70,000원 도달" 놓치면 안 됨

L2-Q4: 최신성 A (초 단위 즉시)
→ 호가 변동 즉시 반영
→ 조건 감지 즉시 체결
```

**Layer 3 제약 확인**:
```
외부 API 제약:
- Rate Limit: 초당 20건 (실전)
- Rate Limit: 초당 2건 (모의)
- WebSocket: 41개 동시 구독
```

**달성 가능성 분석**:
```
✅ 가능한 것:
- 개별 거래 정확성 100% → API 자체가 보장
- 체결 즉시성 → WebSocket으로 즉시 알림

⚠️ 제약이 있는 것:
- 조건 감지 빈도 제한 → API 호출 제한
- 동시 감시 종목 수 제한 → WebSocket 41개
```

**결론**: ⚠️ **부분적 제약 존재**

---

#### Q4-2: 어떤 충돌이 있는가?

**충돌 #1: 정확성 A vs API Rate Limit**

```
목표 (L2-Q1):
- 정확성 A → 모든 조건을 100% 정확히 감지

현실 (L3):
- 초당 20건 제한 (실전)
- 초당 2건 제한 (모의)

충돌:
❌ 100개 조건을 초당 체크하려면?
   → 100건/초 필요 vs 20건/초 제한
   → 불가능!
```

**영향**:
- 조건 체크 주기가 길어짐 (5초마다 100개 체크 = 20건/초)
- 조건 만족 시점 감지 지연 가능
- 빠른 시장 변동 시 놓칠 위험

---

**충돌 #2: 즉시성 A vs WebSocket 구독 제한**

```
목표 (L2-Q4):
- 최신성 A → 호가 변동 즉시 반영

현실 (L3):
- WebSocket 41개 동시 구독 제한

충돌:
❌ 100개 종목을 실시간 감시하려면?
   → 100개 구독 필요 vs 41개 제한
   → 불가능!
```

**영향**:
- 전체 종목 실시간 감시 불가
- 우선순위 높은 41개만 WebSocket
- 나머지는 Polling (정확성·즉시성 하락)

---

**충돌 #3: 모의투자 vs 실전 투자 성능 차이**

```
목표:
- 모의투자로 전략 검증 후 실전 투자

현실:
- 모의투자: 초당 2건 제한 ⚠️
- 실전투자: 초당 20건 제한
- 10배 차이!

충돌:
❌ 모의투자 검증 결과를 실전에 적용 가능한가?
   → 제약이 달라서 동작이 다를 수 있음!
```

**영향**:
- 모의에서 성공한 전략이 실전에서 실패 가능
- 모의에서 충분한 테스트 불가능
- 전략 검증의 신뢰도 하락

---

#### Q4-3: 트레이드오프 필요한가?

**트레이드오프 #1: 정확성 vs 감시 범위**

```
Option A: 정확성 우선
- WebSocket 41개 + Polling 최소화
- 감시 범위: 41개 종목만 100% 정확
- 나머지는 포기

Option B: 범위 우선
- 100개 종목 모두 감시
- Polling (5초 주기) → 정확성 하락
- 빠른 변동 놓칠 위험

→ 결정 필요! (ADR #1)
```

---

**트레이드오프 #2: 즉시성 vs 비용**

```
Option A: 즉시성 최대화
- 조건 체크 주기 짧게 (1초)
- API 호출 많음 → Rate Limit 도달
- 추가 비용 발생 가능 (유료 플랜)

Option B: 비용 최소화
- 조건 체크 주기 길게 (5초)
- API 호출 적음 → 무료 플랜
- 즉시성 하락 (5초 지연)

→ 결정 필요! (ADR #2)
```

---

**트레이드오프 #3: 복잡도 vs 성능**

```
Option A: 단순 구조
- Queue 없이 직접 API 호출
- 구현 간단
- Rate Limit 초과 시 실패

Option B: 복잡한 구조
- Redis Queue + Throttling
- 구현 복잡
- Rate Limit 보장, 안정성 향상

→ 결정 필요! (ADR #3)
```

---

### 🎯 충돌 패턴 요약

| 충돌 | Layer 2 목표 | Layer 3 제약 | 심각도 |
|------|-------------|-------------|-------|
| #1: 조건 감지 | 정확성 A (100%) | API 20건/초 | 🔴 높음 |
| #2: 실시간 감시 | 즉시성 A (초 단위) | WebSocket 41개 | 🔴 높음 |
| #3: 모의 검증 | 전략 검증 신뢰 | 모의 2건/초 | 🟡 중간 |

**결론**:
- ✅ 개별 거래 정확성·즉시성은 달성 가능
- ⚠️ 대규모 감시·처리는 트레이드오프 필요
- 📝 ADR 3개 작성 필요

---

---

## Stage 2 Part 3: 구현방법 결정 (5단계 프로세스)

### 🎯 5단계 프로세스 개요

```
입력: Stage 1 결과 + Stage 2 Part 1-2 결과
   ↓
1️⃣ 기능 분해: 문제 → 필요한 기능들
   ↓
2️⃣ 속성 질문 ⭐: 각 기능의 구체적 NFR
   ↓
3️⃣ 제약조건: 팀, 비용, 규제, 외부 시스템
   ↓
4️⃣ 기술 옵션: 속성과 제약 하에서 선택
   ↓
5️⃣ 통합 설계: 아키텍처 + Schema + API
   ↓
출력: 구체적 구현 계획
```

---

### 1️⃣ 기능 분해

**핵심 기능**: 거래 (Trading)

**필요한 기능 분해**:
```
F1. 거래 조건 설정
    - 사용자가 조건 입력 (종목, 가격, 수량)
    - 조건 유효성 검증
    - 조건 저장

F2. 실시간 시장 데이터 수신
    - 호가 데이터 스트리밍 (WebSocket)
    - 체결가 데이터 수신
    - 거래량, 변동률 등 추가 정보

F3. 조건 감지 및 체결
    - 설정된 조건과 시장 데이터 비교
    - 조건 만족 시 거래 API 호출
    - 체결 결과 확인

F4. 거래 내역 관리
    - 체결 내역 저장
    - 수익률 계산
    - 거래 이력 조회

F5. 알림 및 모니터링
    - 조건 만족 시 알림
    - 체결 완료 알림
    - 오류 발생 시 알림
```

---

### 2️⃣ 속성 질문 ⭐ (NFR 구체화)

**Stage 1 Layer 2 결과 활용**:
```
NFR 프로파일: A-B-B-A
- 정확성: A (100%)
- 규모: B (1만 명)
- 보안: B (암호화)
- 최신성: A (초 단위)
```

#### Q2-1: 성능 요구사항 (최신성 A → 속성 질문)

**F2 (실시간 데이터 수신)**:
```
Q: 시장 데이터를 얼마나 빨리 받아야 하나요?
A: 실시간 (100ms 이내)
   → WebSocket 필수

Q: 몇 개 종목을 동시에 감시하나요?
A: 100개 종목
   → WebSocket 41개 제한 충돌! (Part 2 발견)

Q: 데이터 업데이트 빈도는?
A: 호가 변동마다 (초당 수십~수백 건)
   → 고빈도 처리 필요
```

**F3 (조건 감지)**:
```
Q: 조건을 얼마나 자주 체크해야 하나요?
A: 실시간 (1초 이내)
   → Polling vs Event-driven?

Q: 조건 체크 지연이 얼마나 허용되나요?
A: 최대 1초 (가격 변동 놓치면 손실)
   → 낮은 레이턴시 필수
```

#### Q2-2: 품질 요구사항 (정확성 A → 속성 질문)

**F3 (조건 감지 및 체결)**:
```
Q: 조건 감지를 놓치면 어떻게 되나요?
A: 금전 손실 (원하는 가격에 못 삼)
   → 100% 정확성 필요

Q: 잘못된 가격에 체결되면?
A: 직접적 금전 손실
   → 가격 검증 필수

Q: 중복 체결이 발생하면?
A: 의도하지 않은 매수 (2배 손실)
   → 멱등성(Idempotency) 보장 필요
```

**F4 (거래 내역)**:
```
Q: 거래 기록이 손실되면?
A: 세금 신고 문제, 수익률 계산 불가
   → 영구 저장 필요
```

#### Q2-3: 규모 요구사항 (규모 B → 속성 질문)

**전체 시스템**:
```
Q: 동시 사용자 수는?
A: 1만 명 (B2C)

Q: 사용자당 조건 개수는?
A: 평균 10개 (최대 100개)
   → 총 10만~100만 개 조건 감시

Q: 피크 시간대 부하는?
A: 장 시작/종료 시 집중 (3배)
   → 스케일링 필요
```

#### Q2-4: 보안 요구사항 (보안 B → 속성 질문)

**F1 (조건 설정)**:
```
Q: 다른 사용자의 조건을 볼 수 있나요?
A: 절대 안 됨 (개인 투자 전략 = 민감 정보)
   → 멀티 테넌트 격리 필요

Q: API 키가 노출되면?
A: 계좌 접근 가능 → 금전 손실
   → 암호화 저장, HTTPS 필수
```

#### Q2-5: 환경 요구사항 (Stage 2 Part 1 결과)

**배포 환경**:
```
Q: 어디서 실행되나요?
A: 클라우드 (AWS/GCP) 또는 로컬 서버
   → 플랫폼 무관 설계

Q: 24/7 실행이 필요한가요?
A: 거래 시간 (9:00-15:30) 필수
   → 고가용성 중요도 중간

Q: 데이터 센터 위치 제약은?
A: 한국 내 (증권사 API 레이턴시)
   → 한국 리전 권장
```

---

### 3️⃣ 제약조건 파악

#### 외부 제약 (Stage 2 Part 1 결과)

```
증권사 API:
✅ 한국투자증권 선택
✅ REST API: 초당 20건 (실전), 2건 (모의)
✅ WebSocket: 41개 동시 구독
✅ 인증: 토큰 기반 (1시간 TTL)
✅ 비용: 무료

규제:
✅ 개인 사용: 규제 없음 (5억원 미만)
✅ 본인 계좌만 사용
✅ API 약관 준수
```

#### 내부 제약

```
팀 역량:
- 백엔드: 1-2명 (Python/Node.js)
- 프론트엔드: 1명 (React)
- 금융 도메인: 학습 필요

비용:
- 클라우드: 월 $100 이하
- DB: 무료 티어 활용
- 모니터링: 오픈소스

일정:
- MVP: 3개월
- 전체: 6개월
```

---

### 4️⃣ 기술 옵션 비교 및 선택

#### Option 1: 단순 Polling 방식

**아키텍처**:
```
사용자 → API Server → Polling Worker
                           ↓
                  증권사 API (REST)
                           ↓
                       PostgreSQL
```

**장점**:
- ✅ 구현 간단
- ✅ 디버깅 쉬움
- ✅ 팀 역량 내

**단점**:
- ❌ API Rate Limit 초과 (100개 종목 × 1초 = 100건/초 > 20건/초)
- ❌ 레이턴시 높음 (최소 5초 주기)
- ❌ 정확성 하락 (빠른 변동 놓침)

**적합성**: ❌ NFR 정확성 A, 최신성 A 달성 불가

---

#### Option 2: WebSocket + Polling 하이브리드 ⭐ (권장)

**아키텍처**:
```
사용자 → API Server → Condition Manager
                           ↓
        ┌─────────────────┴─────────────────┐
        ↓                                    ↓
  WebSocket Handler (41개)         Polling Worker (나머지)
        ↓                                    ↓
  증권사 WebSocket                 증권사 REST API
        ↓                                    ↓
        └─────────────────┬─────────────────┘
                          ↓
                    Redis Queue + PostgreSQL
```

**상세 설계**:
```
1. 우선순위 기반 감시:
   - 상위 41개: WebSocket (실시간, 100ms)
   - 나머지: Polling (5초 주기)

2. Rate Limiting:
   - Redis 기반 Throttling
   - Queue를 통한 순차 처리
   - 초당 20건 보장

3. 우선순위 동적 조정:
   - 조건 만족 임박 → WebSocket으로 승격
   - 조건 만족 멀어짐 → Polling으로 강등
```

**장점**:
- ✅ 정확성 A 달성 (중요 종목 실시간 감시)
- ✅ 최신성 A 달성 (WebSocket 100ms)
- ✅ API 제한 준수 (Queue + Throttling)
- ✅ 확장 가능 (우선순위 조정)

**단점**:
- ⚠️ 복잡도 증가 (Redis, Queue 관리)
- ⚠️ WebSocket 연결 관리 필요
- ⚠️ 우선순위 알고리즘 필요

**적합성**: ✅ NFR 달성 + 제약 준수 + 확장성

---

#### Option 3: 완전 Event-Driven (과도한 설계)

**아키텍처**:
```
사용자 → API Gateway → Lambda Functions
                              ↓
                        Kafka/RabbitMQ
                              ↓
                    여러 Microservices
                              ↓
                        DynamoDB/Redis
```

**장점**:
- ✅ 확장성 극대화
- ✅ 고가용성

**단점**:
- ❌ 복잡도 과다 (MVP 범위 초과)
- ❌ 비용 증가 (월 $500+)
- ❌ 팀 역량 부족
- ❌ 디버깅 어려움

**적합성**: ❌ Over-engineering (팀 역량, 비용 초과)

---

#### 기술 스택 결정 (Option 2 기반)

| 계층 | 기술 | 이유 |
|------|------|------|
| **백엔드** | FastAPI (Python) | - 비동기 지원 (WebSocket)<br>- 빠른 개발<br>- 팀 역량 |
| **실시간** | WebSocket (증권사 제공) | - 41개 종목 실시간 감시<br>- 100ms 레이턴시 |
| **Queue** | Redis + Bull/Celery | - Rate limiting<br>- 작업 큐잉<br>- 무료 티어 |
| **DB** | PostgreSQL | - 거래 기록 영구 저장<br>- ACID 보장<br>- 무료 티어 |
| **캐시** | Redis | - 호가 데이터 캐싱<br>- 조건 우선순위 관리 |
| **프론트** | Next.js + React | - SSR 성능<br>- 실시간 업데이트 (SWR) |
| **배포** | Docker + AWS ECS | - 컨테이너화<br>- 스케일링 용이 |

---

### 5️⃣ 통합 설계

#### 아키텍처 다이어그램

```
┌─────────────────────────────────────────────────────────────┐
│                       사용자 (Web UI)                        │
└──────────────────────────────┬──────────────────────────────┘
                               ↓
┌─────────────────────────────────────────────────────────────┐
│                    FastAPI Backend                          │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐      │
│  │ Auth API     │  │ Condition API│  │ History API  │      │
│  └──────────────┘  └──────────────┘  └──────────────┘      │
└──────────────────────────────┬──────────────────────────────┘
                               ↓
┌─────────────────────────────────────────────────────────────┐
│                  Condition Manager (핵심)                    │
│  ┌───────────────────────────────────────────────────┐      │
│  │ Priority Calculator (우선순위 41개 선택)          │      │
│  └───────────────────────────────────────────────────┘      │
└───────────┬──────────────────────────────┬──────────────────┘
            ↓                              ↓
┌─────────────────────┐        ┌─────────────────────┐
│ WebSocket Handler   │        │ Polling Worker      │
│ - 41개 종목         │        │ - 나머지 종목        │
│ - 실시간 (100ms)    │        │ - 5초 주기           │
└─────────┬───────────┘        └─────────┬───────────┘
          ↓                              ↓
┌─────────────────────────────────────────────────────┐
│         증권사 API (한국투자증권)                    │
│  ┌──────────────┐           ┌──────────────┐       │
│  │ WebSocket    │           │ REST API     │       │
│  │ (41 구독)    │           │ (20건/초)    │       │
│  └──────────────┘           └──────────────┘       │
└─────────┬──────────────────────────┬────────────────┘
          ↓                          ↓
┌─────────────────────────────────────────────────────┐
│              Redis Queue + Cache                    │
│  - Rate Limiting (20건/초)                          │
│  - 우선순위 관리                                     │
│  - 호가 데이터 캐싱                                  │
└─────────────────────┬───────────────────────────────┘
                      ↓
┌─────────────────────────────────────────────────────┐
│              PostgreSQL                             │
│  - 조건 저장                                         │
│  - 거래 내역                                         │
│  - 사용자 정보                                       │
└─────────────────────────────────────────────────────┘
```

#### 데이터 스키마 v1.0

**Conditions (조건)**:
```sql
CREATE TABLE conditions (
  id UUID PRIMARY KEY,
  user_id UUID NOT NULL,
  stock_code VARCHAR(10) NOT NULL,    -- 종목 코드
  condition_type VARCHAR(20) NOT NULL, -- 'price_above', 'price_below'
  target_price DECIMAL(10,2) NOT NULL,
  quantity INT NOT NULL,
  priority INT DEFAULT 50,             -- 0-100 (높을수록 우선)
  status VARCHAR(20) DEFAULT 'active', -- 'active', 'triggered', 'expired'
  created_at TIMESTAMP DEFAULT NOW(),
  triggered_at TIMESTAMP,
  INDEX idx_user_active (user_id, status),
  INDEX idx_priority DESC (priority)
);
```

**Trades (거래 내역)**:
```sql
CREATE TABLE trades (
  id UUID PRIMARY KEY,
  user_id UUID NOT NULL,
  condition_id UUID REFERENCES conditions(id),
  stock_code VARCHAR(10) NOT NULL,
  trade_type VARCHAR(10) NOT NULL,   -- 'buy', 'sell'
  price DECIMAL(10,2) NOT NULL,
  quantity INT NOT NULL,
  total_amount DECIMAL(15,2) NOT NULL,
  executed_at TIMESTAMP DEFAULT NOW(),
  api_response JSONB,                -- 증권사 API 응답 저장
  INDEX idx_user_time (user_id, executed_at DESC)
);
```

**Redis 구조**:
```
# WebSocket 구독 목록 (Sorted Set)
websocket:subscriptions -> {stock_code: priority}

# Polling 큐 (List)
polling:queue -> [stock_code1, stock_code2, ...]

# Rate Limiting (String with TTL)
ratelimit:{api_type} -> count (TTL 1초)

# 호가 캐시 (Hash)
price:{stock_code} -> {bid, ask, last, timestamp}
```

#### API 설계 v1.0

**조건 생성**:
```http
POST /api/v1/conditions
Content-Type: application/json

{
  "stock_code": "005930",        # 삼성전자
  "condition_type": "price_above",
  "target_price": 70000,
  "quantity": 10
}

Response 201:
{
  "id": "uuid",
  "priority": 50,
  "status": "active",
  "estimated_trigger_time": "2025-11-12T14:30:00Z"
}
```

**조건 목록 조회**:
```http
GET /api/v1/conditions?status=active

Response 200:
{
  "conditions": [
    {
      "id": "uuid",
      "stock_code": "005930",
      "target_price": 70000,
      "current_price": 69500,
      "priority": 75,           # 가격 근접 → 우선순위 상승
      "monitoring_type": "websocket"  # 또는 "polling"
    }
  ]
}
```

**거래 내역 조회**:
```http
GET /api/v1/trades?from=2025-11-01&to=2025-11-30

Response 200:
{
  "trades": [...],
  "total_profit": 150000,
  "win_rate": 0.65
}
```

---

### 🎯 구현방법 결정 요약

| 항목 | 결정 내용 |
|------|----------|
| **아키텍처** | WebSocket + Polling 하이브리드 |
| **핵심 전략** | 우선순위 기반 41개 실시간 감시 |
| **백엔드** | FastAPI (Python, 비동기) |
| **큐/캐시** | Redis (Rate limit + Priority) |
| **DB** | PostgreSQL (거래 기록) |
| **프론트** | Next.js + React |
| **배포** | Docker + AWS ECS |

**NFR 달성 검증**:
- ✅ 정확성 A: 중요 종목 WebSocket 실시간 감시
- ✅ 최신성 A: 100ms 레이턴시 (WebSocket)
- ✅ 규모 B: 1만 명 (Redis Queue로 확장 가능)
- ✅ 보안 B: 멀티 테넌트 격리, HTTPS, API 키 암호화

**제약 준수**:
- ✅ API 20건/초: Redis Throttling으로 보장
- ✅ WebSocket 41개: 우선순위 알고리즘으로 최적 활용
- ✅ 팀 역량: FastAPI, React 모두 가능
- ✅ 비용: 무료 티어 + 월 $50 이하

---

### 🔗 다음 단계: Stage 3 (ADR 작성)

이제 **Stage 2 Part 3 완료**! 다음은 **Stage 3: ADR 작성**

**작성할 ADR 3개**:
1. **ADR-001**: WebSocket + Polling 하이브리드 아키텍처 선택
2. **ADR-002**: 우선순위 기반 41개 종목 선택 알고리즘
3. **ADR-003**: Redis Queue 기반 Rate Limiting 전략

---

## 📊 현재 검증 상태

| 항목 | 상태 | 비고 |
|------|------|------|
| Phase 1: 이론 매핑 | ✅ 완료 | SEI, Fowler, CAP 검증 완료 |
| 사례 1: 문서 생성 | ✅ 완료 | 패밀리 1 (A-A-A) |
| 사례 2: AI 메모리 | ✅ 완료 | 패밀리 2 (C-B-B), 충돌 해결 |
| 사례 3: 채팅 앱 | ✅ 완료 | 패밀리 3 (B-C-A) |
| **사례 4: 주식 거래** | 🔄 진행 중 | **패밀리 A-C-A** (새 패턴!) |
| **Stage 1** | ✅ 완료 | Part 0-2 완료 |
| **Stage 2 Part 1-2** | ✅ 완료 | Layer 3 + 충돌 패턴 |
| **Stage 2 Part 3** | ✅ 완료 | 5단계 구현방법 결정 |
| **Stage 3** | ⏸️ 대기 | ADR 3개 작성 |

---

## 🚀 현재 작업 진행 상황

### ✅ Stage 1 완료 (아키텍처 패밀리 결정)
1. **Part 0: 핵심 기능 구분 명확화**
   - ❌ 수동/자동 = 2개 기능 → ✅ 거래 = 1개 기능
   - 문서: `20251112_핵심기능_판단기준.md`

2. **Part 1-2: Layer 1-2 분석 완료**
   - Layer 1: A-C-A (새 패밀리 패턴!)
   - Layer 2: A-B-B-A

### ✅ Stage 2 완료 (환경 제약 및 구현 결정)

3. **Part 1: Layer 3 외부 제약 조사**
   - 증권사 API 비교 (6개)
   - 금융 규제 조사
   - 한국투자증권 선택
   - 문서: `20251112_Layer3_외부제약조사.md`

4. **Part 2: 충돌 패턴 발견** ⭐
   - 충돌 #1: 정확성 A vs API 20건/초
   - 충돌 #2: 즉시성 A vs WebSocket 41개
   - 충돌 #3: 모의투자 vs 실전투자 성능 차이

5. **Part 3: 구현방법 결정 (5단계)** ⭐
   - 1️⃣ 기능 분해: F1~F5 정의
   - 2️⃣ 속성 질문: NFR 구체화 (성능, 품질, 규모, 보안, 환경)
   - 3️⃣ 제약조건: 외부 (API) + 내부 (팀, 비용, 일정)
   - 4️⃣ 기술 옵션: 3개 비교 → WebSocket + Polling 하이브리드 선택
   - 5️⃣ 통합 설계: 아키텍처, Schema v1.0, API v1.0

### ⏸️ Stage 3 대기 (ADR 작성)
6. **ADR 3개 작성**
   - ADR-001: WebSocket + Polling 하이브리드 선택
   - ADR-002: 우선순위 기반 41개 종목 선택 알고리즘
   - ADR-003: Redis Queue 기반 Rate Limiting 전략

### ⏸️ 기타 작업
7. **02-1_IMPLEMENTATION_CASES.md**에 사례 4 추가
   - Case 4: 주식 거래 플랫폼 (A-C-A)

8. **A-C-A 패밀리** 이론적 검증 (Fowler Pattern 매핑)

---

**작성**: 2호 (Claude Code)
**검토**: Jason
**상태**: Stage 2 완료! (5단계 구현방법 결정)
**핵심**: 속성 질문이 기술 선택을 주도한다! (SEI ADD 원칙)
