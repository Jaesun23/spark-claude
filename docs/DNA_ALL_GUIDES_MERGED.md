# DNA Methodology v4.0 - All Guides (Merged)

**생성일**: 2025-11-19 10:20:19

**포함된 파일**: 9개

---

## 📚 목차

1. [01G-00_core_definition_guide.md](#01G-00_core_definition_guide)
2. [02G-00_environment_constraints_guide.md](#02G-00_environment_constraints_guide)
3. [03G-00_adr_guide.md](#03G-00_adr_guide)
4. [04G-00_dna_planning_guide.md](#04G-00_dna_planning_guide)
5. [05G-00_dna_implementation_guide.md](#05G-00_dna_implementation_guide)
6. [06G-00_project_standards_guide.md](#06G-00_project_standards_guide)
7. [07G-00_blueprint_guide.md](#07G-00_blueprint_guide)
8. [08G-00_task_breakdown_guide.md](#08G-00_task_breakdown_guide)
9. [09G-00_checklist_guide.md](#09G-00_checklist_guide)

---



================================================================================
# 📄 1. 01G-00_core_definition_guide.md
================================================================================

# Stage1. 핵심정의 가이드 (Core Definition Guide)

> **목적**: Stage 1 - 패밀리 구분과 핵심기능 파악 (큰 방향과 큰 틀만 잡기)
>
> **버전**: v4.0 (2025-11-14)
>
> - v4.0 (2025-11-14): Stage - Part - Layer 구조 재정립 및 내용 수정
> - v3.0: Stage 구조 재정립 (Layer 3 → Stage 2로 이동)
> - v2.0: 3-Layer Decision Tree 도입

---

## 📚 이 가이드의 구성

- **이 문서** (Guide): 질문 템플릿 + 작성 원칙 (간결)
- **해설서** (Manual): 왜? 어떻게? 상세 설명 → `./01M-01_layer1_manual.md`, `./01M-02_layer2_manual.md`
- **사례집** (Cases): 전체 흐름 실전 예시 → `./02E-01_stock_trading_case.md`

---

## 📥 입력 문서 (이 Stage를 시작하기 전에 필요한 것)

**없음** - Stage 1은 프로젝트의 시작점입니다.

**필요한 것**:

- 프로젝트 아이디어 (간단한 설명)
- 해결하고자 하는 문제
- 기본적인 요구사항 (선택적)

---

## 📤 출력 문서 (이 Stage에서 생성해야 할 문서)

### 필수 문서

#### 1. **`01F-01_core_functions.md`** - '핵심기능' 정의 문서

#### 2. **`01C-01_family_classification.md`** - 7가지 패밀리 중 해당되는 패밀리(유형) 선택 문서

#### 3. **`01C-02_nfr_profile.md`** - NFR(Non-Functional Requirement) 프로파일링 문서

#### 4. **`01D-01_tech_candidates.md`** - 기술 후보군 명세서

---

### 🔄 4개의 문서를 통해 다음 Stage로 전달되는 것

#### Stage 1 → Stage 2:

- ##### ✅ 패밀리 코드 (A-C-A)

- ##### ✅ 핵심 기능 (거래)

- ##### ✅ NFR 프로파일 (A-B-B-A)

- ##### ✅ 기술 후보군 (WebSocket, FastAPI, Redis, PostgreSQL)

#### Stage 2에서는 이를 기반으로:

- ##### Layer 3 외부 제약 조사 (실제 API, 법규 등)

- ##### 충돌 패턴 발견

- ##### 구체적 기술 스택 확정

---

## Part 0: 핵심 기능 파악 ⭐

프로젝트의 시작은 아주 간단한 아이디어가 떠올라 그걸 실현시키고 싶을 때, 또는 어떤 일의 불편함이나 문제를 인식하고 그걸 해결하려고 할 때 시작하게 됩니다. 먼저 아이디어나 문제와 해결방법, 추가 요구사항을 접수하세요.

- 프로젝트 아이디어 (간단한 설명)
- 해결하고자 하는 문제
- 기본적인 요구사항 (선택적)

이제부터 접수된 내용에서 가장 '근원적인 기능'과 그 기능을 통해 무엇을 이루려고 하는 것인지 그 '목적'을 파악해 내야 합니다. 그 방법은 질문을 던져서 찾아냅니다.

------

### Q. 이 시스템은 무엇을 하기 위한 시스템인가요?

**작성 원칙**:

- 가장 **원자적인 기능(핵심기능)**만 파악하세요.
- 기능의 **확장 형태** 또는 **구현 방식**을 별개의 기능으로 보면 안 됩니다
- **비즈니스 목적**으로 구분하세요.

**예시**:

```
❌ 잘못된 구분:
   - 수동 거래 (핵심기능 1)
   - 자동 거래 (핵심기능 2)
❌ 잘못된 비지니스 목적: 편하게 거래하고, 필요할 때는 불편해도 수동으로 거래

✅ 올바른 구분:
   - 거래 (핵심기능)
     ├─ 구현 방식 A: 수동
     └─ 구현 방식 B: 자동
✅ 비지니스 목적: "거래"를 통해 법적인 소유권 이전 효과 획득
```

✅ 다른 예시:
- AI 챗봇 + 외부메모리 (X) → AI 외부메모리 (CRUD) (O)
- 일반 검색 + AI 검색 (X) → 검색 (O)

**상세 설명**: **Manual**(`01M-01_layer1_manual.md`) 1.2절 참고

---

## Part 1: 시스템의 패밀리 유형 파악

### DNA 방법론의 7가지 패밀리 유형

> DNA Development Methodology v4.0에서는 모든 소프트웨어 시스템을 **3가지 핵심 차원**으로 분류하여 이론적으로 2×3×3 = 18가지 조합이 가능하지만, 실증 연구를 통해 **실무적으로 의미 있고 검증된 7가지 패밀리**를 도출했습니다.
>
> 지금 개발하려는 시스템이 **7가지 패밀리**에서 어떤 패밀리에 해당하는 지는 **3개의 질문에 답변**을 하면 자연스럽게 정해집니다.

---

## 3가지 분류 차원 (3-Layer Decision Tree)

### Layer 1: 실패의 파급력 (Failure Impact) ➟ "시스템이 실패하면 어떤 일이 벌어지는가?"

| 코드  |       유형        |                     의미                      |              실제 예시              |
| :---: | :---------------: | :-------------------------------------------: | :---------------------------------: |
| **A** | 치명적 (Critical) |    실패 시 생명, 재산, 시장에 즉각적 피해     |   금융 거래, 의료 기록, 항공 관제   |
| **B** | 점진적 (Graceful) | 실패 시 성능 저하나 일부 기능 상실, 계속 작동 | 소셜 미디어, 추천 시스템, 협업 도구 |

#### 핵심 질문: "이 시스템이 5분간 멈추면 어떻게 되나요?"

- A: 돈을 잃거나, 생명이 위험하거나, 법적 문제 발생
- B: 불편하지만 재시도하거나 나중에 처리 가능

---

### Layer 2: 데이터의 형태 (Data Structure) ➟ "다루는 정보가 얼마나 정형화되어 있는가?"

| 코드  |            유형            |                     의미                      |                 실제 예시                  |
| :---: | :------------------------: | :-------------------------------------------: | :----------------------------------------: |
| **A** |    구조화 (Structured)     | 고정된 스키마, 명확한 관계, 정확한 쿼리 가능  |    주문 데이터, 회계 장부, 예약 시스템     |
| **B** | 반구조화 (Semi-Structured) |    유연한 스키마, 일부 비정형, JSON/XML 등    |   사용자 프로필, IoT 센서 로그, API 응답   |
| **C** |  비구조화 (Unstructured)   | 스키마 없음, 이벤트 스트림, 자연어, 이미지 등 | 실시간 스트리밍, 로그 분석, AI 학습 데이터 |

#### 핵심 질문: "데이터베이스 스키마를 미리 정의할 수 있나요?"

- A: 네, 명확히 정의 가능 (ORDER, USER, PRODUCT 테이블)
- B: 부분적으로 (기본 필드 + 추가 속성)
- C: 아니오, 매번 다를 수 있음 (이벤트 스트림, 로그)

---

### Layer 3: 응답 시점 (Response Time) ➟ "얼마나 빨리 결과를 내야 하는가?"**

| 코드  |        유형        |                   의미                    |              실제 예시              |
| :---: | :----------------: | :---------------------------------------: | :---------------------------------: |
| **A** | 밀리초 (Real-time) | 사람이 "즉각"이라고 느끼는 속도 (< 100ms) | 협업 편집, 고빈도 거래, 실시간 채팅 |
| **B** | 수초 (Interactive) |    사람이 기다릴 수 있는 속도 (1~10초)    | 검색 결과, 주문 처리, 일반 API 응답 |
| **C** |    배치 (Batch)    |       스케줄 기반, 시간/분/일 단위        |   데이터 분석, 월말 정산, ML 학습   |

#### 핵심 질문: "사용자가 결과를 얼마나 빨리 기대하나요?"

- A: 즉시 (타이핑하는 동안, 클릭 직후)
- B: 잠깐 기다림 (로딩 인디케이터 표시)
- C: 나중에 (야간 처리, 주간 리포트)

---

## 패밀리 선택 플로우차트 예시

```
시작: 어떤 시스템을 만드나요?
  ↓
[Q1] 실패하면 어떻게 되나요?
  ├─ 돈/생명/시장 손실 → A (치명적)
  └─ 성능 저하/재시도 → B (점진적)
       ↓
[Q2] 데이터 형태는?
  ├─ 고정 스키마 → A (구조화)
  ├─ 유연한 JSON → B (반구조화)
  └─ 이벤트/로그 → C (비구조화)
       ↓
[Q3] 얼마나 빨라야 하나요?
  ├─ 즉시 (< 100ms) → A (밀리초)
  ├─ 기다림 (1~10초) → B (수초)
  └─ 나중에 (배치) → C (배치)
       ↓
패밀리 코드 확정! (예: B-C-A)
  ↓
해당 패밀리 기술 매트릭스 참고
```

### 아키텍처 패밀리 결정

**7가지 아키텍처 패밀리**:

| 패밀리 코드 | 패밀리 이름     | 대표 사례                    | 핵심 기술                  |
| ----------- | --------------- | ---------------------------- | -------------------------- |
| **A-A-A**   | 초고속 거래     | NASDAQ 매칭 엔진 (14μs)      | FPGA, 코로케이션           |
| **A-A-B**   | 트랜잭션/CRUD   | Amazon 주문, 은행 ATM        | PostgreSQL, 마이크로서비스 |
| **B-A-A**   | 협업/동기화     | Google Docs, Figma           | CRDT, WebSocket            |
| **B-B-B**   | 검색/추천       | Elasticsearch, AI 외부메모리 | 벡터 DB, 역인덱스          |
| **B-C-A**   | 실시간 스트리밍 | Netflix RDG, Uber GPS        | Kafka, Flink               |
| **B-A-C**   | 분석/배치       | Snowflake, BigQuery          | MPP, ETL                   |
| **A-B-A**   | 안전-임계 IoT   | 산업 제어, 긴급 경보         | MQTT, SCADA                |

## Part 2: NFR 우선순위

> **목표**: 품질 속성(Quality Attributes) 우선순위 결정

---

### P2-Q1. 핵심 품질은 무엇인가? (북극성)

**선택지**:

- **A (정확성)**: 100% 정확, 오류 불허
- **B (속도)**: 빠른 응답, 처리량
- **C (관련성)**: 맥락 이해, 품질

**상세 설명**: **Manual**(`01M-02_layer2_manual.md`) 3.1절 참고

---

### P2-Q2. 예상 사용자 규모는?

**선택지**:

- **A (소규모)**: < 100명
- **B (중규모)**: 100 ~ 10,000명
- **C (대규모)**: > 10,000명

**상세 설명**: **Manual**(`01M-02_layer2_manual.md`) 3.2절 참고

---

### P2-Q3. 데이터 노출 수준은?

**선택지**:
- **A (극비)**: 개인 금융, 의료
- **B (민감)**: 사용자 정보
- **C (공개)**: 공개 콘텐츠

**상세 설명**: **Manual**(`01M-02_layer2_manual.md`) 3.3절 참고

---

### P2-Q4. 데이터 최신성은?

**선택지**:
- **A (즉시)**: 실시간 (ms~초)
- **B (준실시간)**: 분~시간
- **C (배치)**: 일~주

**상세 설명**: **Manual**(`01M-02_layer2_manual.md`) 3.4절 참고

---

### NFR 프로파일 생성

**출력 형식**: `L2-Q1: A, L2-Q2: B, L2-Q3: B, L2-Q4: A → A-B-B-A`

**충돌 감지**:

- A (정확성) + A (즉시) → 가능하지만 비용 높음
- B (속도) + A (정확성) → 트레이드오프 필요

**상세 설명**: **Manual**(`01M-02_layer2_manual.md`) 3.5절 참고

---

## 템플릿

### Part 0: 핵심 기능
```markdown
## 핵심 기능

### Q0-1: 존재 이유
- 핵심 기능: [기능명]
- 구현 방식: [A, B, C...]

### Q0-2: 실패 영향
- 영향: [금전 손실 / 불편함 / 데이터 손실]
- 치명도: [A / B / C]
```

### Part 1: 패밀리

```markdown
## Layer 1: 아키텍처 패밀리

### L1-Q1: 실패 파급력
- 선택: [A / B]
- 이유: [...]

### L1-Q2: 정보 형태
- 선택: [A / B / C]
- 이유: [...]

### L1-Q3: 응답 시점
- 선택: [A / B / C]
- 이유: [...]

### 패밀리: [패밀리명] ([패턴])
```

### Part 2: NFR
```markdown
## Layer 2: NFR 우선순위

### L2-Q1: 핵심 품질
- 선택: [A / B / C]

### L2-Q2: 규모
- 선택: [A / B / C]

### L2-Q3: 데이터 노출
- 선택: [A / B / C]

### L2-Q4: 최신성
- 선택: [A / B / C]

### NFR 프로파일: [A-B-B-A]
```

---

## 다음 단계

**Stage 1 완료 후 → Stage 2: 구조설계**

Stage 1에서 결정된 내용:
- ✅ 패밀리 (예: A-C-A) → 필수 기술 방향
- ✅ 핵심 기능 (예: 거래) → 구현 후보군
- ✅ NFR 프로파일 (예: A-B-B-A) → 품질 우선순위

Stage 2에서 할 일:
- 🔄 외부 제약, 내부 자원
- 🔄 충돌 패턴 발견 (NFR vs 제약)
- 🔄 5단계 구현방법 (기능→속성→제약→기술→설계)
- 🔄 결정 요소 목록 작성

**다음 문서**: `02G-00_structure_design_guide.md`

---

## 참고 문서

- **상세 해설**: `01M-01_layer1_manual.md`, `01M-02_layer2_manual.md`
  - 왜 이 질문들인가?
  - 어떻게 답변하는가?
  - 7가지 패밀리 상세 설명

- **실전 사례**: `02E-01_stock_trading_case.md`
  - Case 1: Memory (CRUD/트랜잭션)
  - Case 2: BioNeX (검색/추천)
  - Case 3: BlueprintAI (협업/동기화)
  - Case 4: Stock Trading (실시간 트랜잭션) ⭐

- **이론적 근거**: `../research/ARCHITECTURE_THEORY_MAPPING.md`
  - SEI Quality Attributes
  - Martin Fowler Patterns
  - CAP Theorem

---

**버전 이력**:
- v4.0 (2025-11-14): Stage - Part - Layer 구조 재정립 및 오류 정정 포함 내용 수정
- v3.0 (2025-11-12): Stage 구조 재정립 (Layer 3 → Stage 2로 이동)
- v2.1 (2025-11-12): Part 0 추가, A-C-A 패밀리 추가
- v2.0 (2025-11-11): 3-Layer Decision Tree 도입
- v1.0 (2025-11-10): 7가지 고정 질문


================================================================================
# End of 01G-00_core_definition_guide.md
================================================================================



================================================================================
# 📄 2. 02G-00_environment_constraints_guide.md
================================================================================

# Stage2. 환경 제약 가이드 (Environment Constraints Guide)

> **버전**: v4.0 (2025-11-14)
> - v4.0 (2025-11-14): Stage 2 구조 확립 - Part 1-3 구성
>
> **목적**: Stage 1에서 결정한 패밀리가 실제 환경에서 구현 가능한지 확인하고, 충돌 발견시 트레이드오프 결정

---

## 📚 이 가이드의 구성
- **이 문서** (Guide): 질문 템플릿 + 작성 원칙 (간결)
- **해설서** (Manual): 왜? 어떻게? 상세 설명 → `02M-01_environment_constraints_manual.md`
- **사례집** (Cases): 전체 흐름 실전 예시 → `02E-01_stock_trading_case.md`

---

## 📋 목차
1. [Stage 2가 필요한 이유](#stage-2가-필요한-이유)
2. [Part 1: Layer 3 (외부 제약) 조사](#part-1-layer-3-외부-제약-조사)
3. [Part 2: 충돌 패턴 식별](#part-2-충돌-패턴-식별)
4. [Part 3: 구현 방법 결정 (5단계)](#part-3-구현-방법-결정-5단계)
5. [산출물 작성 가이드](#산출물-작성-가이드)

---

## Stage 2가 필요한 이유

Stage 1에서 시스템의 패밀리를 결정했습니다. 예를 들어 "A-A-B (트랜잭션/CRUD)" 또는 "B-C-A (실시간 스트리밍)" 같은 패밀리 코드를 얻었죠.

**하지만 여기서 중요한 질문이 생깁니다**:

> "이 패밀리가 요구하는 성능과 구조를, 현실 세계의 외부 환경(API, 클라우드, 규제 등)이 지원할 수 있나요?"

**예시로 이해하기**:
```
Stage 1 결정: A-C-A 패밀리 (초고속 실시간 거래)
  ├─ Layer 1: A (실패 = 금전 손실)
  ├─ Layer 2: C (스트림 데이터)
  └─ Layer 3: A (100ms 이하 응답)  ← 이게 가능한가?

Stage 2 조사: 실제 증권 API 성능 확인
  ├─ 한국투자증권: 평균 200-400ms  ❌ (Layer 3 불만족!)
  ├─ 키움증권: 평균 300-600ms      ❌ (Layer 3 불만족!)
  └─ WebSocket 실시간: 50-100ms   ✅ (조건부 가능)

결론: Layer 3 목표(100ms)와 현실(200-600ms)이 충돌!
→ 트레이드오프 결정 필요
```

**이것이 바로 Stage 2의 역할입니다**:
- **현실 확인**: 이상과 현실 사이의 간극 파악
- **충돌 발견**: 목표와 제약 사이의 충돌 명확히 식별
- **트레이드오프**: 의식적으로 절충안 결정하고 문서화

---

## Part 1: Layer 3 (외부 제약) 조사

Stage 1에서 결정된 패밀리의 **Layer 3 (응답 시간)** 요구사항을 만족시킬 수 있는 **외부 환경**을 조사합니다.

여기서 "Layer 3"는 Stage 1 Part 1의 3-Layer Decision Tree에서 결정한 **응답 시간 요구사항**(A: 100ms 이하, B: 1초 이하, C: 1초 이상)을 의미합니다.

### 왜 Layer 3만 조사하나요?

**Layer 1, 2는 이미 확정**:
- **Layer 1 (실패 영향)**: 시스템 본질 - 바꿀 수 없음
- **Layer 2 (데이터 구조)**: 데이터 특성 - 바꿀 수 없음

**Layer 3 (응답 시간)만 협상 가능**:
- 외부 API/서비스로 달성해야 하는 성능
- 불가능하면 목표를 조정하거나 아키텍처 변경
- **이것이 Stage 2의 핵심!**

---

### P1-Q1: Layer 3 제약을 만족하는 외부 서비스/API는 무엇이 있나요?

**질문 의도**: Stage 1에서 결정된 응답 시간 요구사항(A/B/C)을 만족하는 실제 사용 가능한 외부 서비스를 찾습니다.

**작성 가이드**:
1. **Stage 1 결과 확인**: "우리 시스템은 Layer 3가 A/B/C인가?"
2. **후보 서비스 조사**: 해당 응답 시간을 제공하는 서비스 찾기
3. **비교표 작성**: 성능, 가격, SLA, 제약사항 비교

**작성 예시** (Layer 3: B - 1초 이하인 경우):

```markdown
## Layer 3 제약 조사: 증권 거래 API

**Stage 1 결과**: Layer 3 = B (1초 이하 응답 필요)

### 후보 서비스 비교

| 서비스명 | 평균 응답 시간 | SLA | 월 비용 | Rate Limit | 비고 |
|----------|----------------|-----|---------|------------|------|
| 한국투자증권 REST API | 200-400ms | 99.9% | 무료 | 실전: 20건/초<br>모의: 2건/초 | ✅ Layer 3 만족 |
| 키움증권 OpenAPI | 300-600ms | 99.5% | 무료 | 초당 5건 | ⚠️ 응답 시간 경계선 |
| WebSocket (실시간) | 50-100ms | - | 무료 | 동시 41개 | ✅ 실시간 가능 |

### 제약사항 발견

1. **Rate Limit 차이**:
   - 실전 거래: 초당 20건
   - 모의 거래: 초당 2건 (10배 차이!)

2. **WebSocket 구독 제한**:
   - 동시 41개 종목만 구독 가능
   - 더 많은 종목은 Polling 필요

3. **SLA 보장 범위**:
   - 99.9% ≠ 100% → 장애 시간 존재
```

> 📖 **더 알아보기**: [Manual 1.1절: Layer 3 조사 방법론](./02M-01_environment_constraints_manual.md#11-layer-3-조사-방법론)(`02M-01_environment_constraints_manual.md:20-80`)

---

### P1-Q2: 다른 외부 제약(규제, 클라우드, 비용 등)이 있나요?

**질문 의도**: API 성능 외에 시스템 구현에 영향을 주는 다른 제약사항을 모두 파악합니다.

**작성 가이드**:

**1. 규제 제약**:
- 금융, 의료, 교육 등 규제 산업인가?
- 데이터 보관/삭제 의무 기간
- 개인정보보호 요구사항

**2. 클라우드/인프라 제약**:
- 온프레미스 필수인가? (보안, 규제)
- 클라우드 사용 가능한가?
- 지역(Region) 제한

**3. 비용 제약**:
- 예산 한도
- 트래픽 비용 구조
- 무료 티어 제한

**4. 기술 제약**:
- 기존 시스템과의 호환성
- 사용 가능한 프로그래밍 언어
- 라이선스 제약

**작성 예시**:

```markdown
## 외부 제약 조사

### 1. 규제 제약
- **금융위원회 전자금융거래법**:
  - 거래 기록 5년 보관 의무
  - 고객 거래 내역 조회 제공 의무

- **개인정보보호법**:
  - 주민번호 암호화 저장 필수
  - 개인정보 제3자 제공 동의 필요

### 2. 클라우드 제약
- ✅ 클라우드 사용 가능 (금융권 승인됨)
- ⚠️ 한국 리전(Region) 필수 (데이터 국외 반출 금지)
- 권장: AWS Seoul, NCP (네이버 클라우드)

### 3. 비용 제약
- 초기 예산: 월 50만원 이하
- 증권 API: 무료 (한국투자증권)
- 클라우드: t3.medium 24시간 = 월 약 40만원

### 4. 기술 제약
- 증권사 API: Python, Java, C++ 지원
- ActiveX 제외 (키움증권 일부 기능)
- 64비트 환경 필수
```

> 📖 **더 알아보기**: [Manual 1.2절: 외부 제약 조사 체크리스트](./02M-01_environment_constraints_manual.md#12-외부-제약-조사-체크리스트)(`02M-01_environment_constraints_manual.md:81-150`)

---

## Part 2: 충돌 패턴 식별

Part 1에서 조사한 **현실적 제약**이 Stage 1에서 결정한 **이상적 목표(NFR 프로파일)**와 **충돌하는지** 확인합니다.

### 충돌이란?

```
이상 (Stage 1 Part 2: NFR 프로파일)
  "정확성 A: 100% 정확한 조건 감지"
  "최신성 A: 실시간 즉시 반영"

         vs

현실 (Stage 2 Part 1: Layer 3 제약)
  "API Rate Limit: 초당 20건"
  "WebSocket 구독: 최대 41개"

        ↓
     충돌 발생!
```

**충돌은 정상입니다!** 이상과 현실 사이의 간극은 항상 존재합니다.
중요한 것은 **의식적으로 트레이드오프를 결정하고 문서화**하는 것입니다.

---

### P2-Q1: NFR 목표가 Layer 3 제약 하에서 달성 가능한가?

**질문 의도**: Stage 1 Part 2에서 정한 NFR 우선순위를, Part 1에서 조사한 실제 제약 환경에서 달성할 수 있는지 검증합니다.

**작성 가이드**:
1. **NFR 목표 나열**: Stage 1 Part 2 결과 (A-B-B-A 등)
2. **제약 사항 나열**: Part 1 조사 결과
3. **달성 가능성 분석**: 각 NFR별로 체크

**작성 예시**:

```markdown
## NFR 달성 가능성 분석

### Stage 1 Part 2 결과: NFR 프로파일 = A-B-B-A

| NFR | 목표 | Part 1 제약 | 달성 가능? |
|-----|------|-------------|-----------|
| **정확성** | A (100%) | API 자체가 정확한 데이터 제공 | ✅ 가능 |
| **성능** | B (1초) | 평균 200-400ms | ✅ 가능 |
| **확장성** | B (중간) | Rate Limit 20건/초 | ⚠️ 조건부 |
| **최신성** | A (실시간) | WebSocket 41개 제한 | ⚠️ 조건부 |

### 상세 분석

#### ✅ 달성 가능: 정확성 A
- API가 제공하는 데이터 자체가 정확함
- 거래소 직접 연결 데이터
- 추가 검증 불필요

#### ✅ 달성 가능: 성능 B
- 목표: 1초 이하
- 실제: 평균 200-400ms
- 충분한 여유 있음

#### ⚠️ 조건부 달성: 확장성 B
- Rate Limit: 초당 20건
- 100개 조건 체크 시: 5초마다 1회 전체 체크
- 빠른 변동 감지 어려움 → 충돌!

#### ⚠️ 조건부 달성: 최신성 A
- WebSocket: 최대 41개 동시 구독
- 100개 종목 감시 불가능
- 나머지는 Polling → 최신성 하락 → 충돌!
```

> 📖 **더 알아보기**: [Manual 2.1절: NFR 달성 가능성 분석 방법](./02M-01_environment_constraints_manual.md#21-nfr-달성-가능성-분석)(`02M-01_environment_constraints_manual.md:151-220`)

---

### P2-Q2: 어떤 충돌 패턴이 존재하나요?

**질문 의도**: P2-Q1에서 발견한 "⚠️ 조건부" 또는 "❌ 불가능" 항목을 구체적으로 분석하여 충돌 패턴을 명확히 정의합니다.

**작성 가이드**:

각 충돌마다 다음 형식으로 작성:

```markdown
### 충돌 #N: [목표 vs 제약]

**목표 (NFR)**:
- [Stage 1 Part 2에서 정한 목표]

**현실 (Layer 3 제약)**:
- [Part 1에서 조사한 제약]

**충돌 상황**:
- [왜 불가능한가? 구체적 수치로]

**영향**:
- [이 충돌이 시스템에 미치는 영향]

**트레이드오프 옵션**:
- 옵션 A: [방법 1 - 장단점]
- 옵션 B: [방법 2 - 장단점]
```

**작성 예시**:

```markdown
## 발견된 충돌 패턴

### 충돌 #1: 정확성 A vs API Rate Limit

**목표 (NFR 정확성 A)**:
- 100개 조건을 초 단위로 정확히 감지
- 조건 만족 시점을 놓치지 않아야 함

**현실 (API Rate Limit)**:
- 실전 거래: 초당 20건 제한
- 모의 거래: 초당 2건 제한

**충돌 상황**:
100개 조건을 초당 체크하려면?
  → 100건/초 API 호출 필요
  → 하지만 20건/초 제한
  → 불가능!

해결책: 5초마다 1회 전체 체크 (100건 ÷ 20건/초 = 5초)

**영향**:
- 조건 체크 주기: 1초 → 5초로 증가
- 빠른 시장 변동 시 조건 만족 시점 놓칠 위험
- 정확성 A 목표 달성 어려움

**트레이드오프 옵션**:

**옵션 A: 감시 조건 개수 축소**
- 장점: 정확성 A 유지 가능 (20개 × 1초 = 20건)
- 단점: 기능 제한 (100개 → 20개)

**옵션 B: 체크 주기 연장 수용**
- 장점: 100개 조건 모두 감시 가능
- 단점: 정확성 A → B로 하락 (5초 주기)

**옵션 C: 하이브리드 - 우선순위 기반**
- 중요한 20개: WebSocket 실시간 감시
- 나머지 80개: 5초 주기 Polling
- 장점: 핵심 기능은 정확성 A 유지
- 단점: 복잡도 증가

---

### 충돌 #2: 최신성 A vs WebSocket 구독 제한

**목표 (NFR 최신성 A)**:
- 호가 변동 즉시 반영
- 조건 감지 즉시 체결

**현실 (WebSocket 제한)**:
- 동시 구독: 최대 41개 종목
- 초과 시: Polling으로 대체 필요

**충돌 상황**:
100개 종목 실시간 감시하려면?
  → 100개 WebSocket 구독 필요
  → 하지만 41개 제한
  → 불가능!

해결책: 41개 WebSocket + 59개 Polling

**영향**:
- 41개: 실시간 (50-100ms)
- 59개: Polling (5초 주기 = 5000ms)
- 전체 종목 최신성 A 달성 불가

**트레이드오프 옵션**:

**옵션 A: 동적 구독 전환**
- 우선순위 높은 41개만 WebSocket
- 우선순위 변경 시 구독 교체
- 장점: 중요한 것은 실시간
- 단점: 구독 전환 지연 (1-2초)

**옵션 B: 계좌 분산**
- 여러 계좌 사용 (각 41개)
- 장점: 더 많은 종목 실시간 가능
- 단점: 관리 복잡도 증가

---

### 충돌 #3: 모의투자 검증 vs 실전 성능 차이

**목표**:
- 모의투자로 전략 검증 후 실전 투자

**현실**:
- 모의투자: 초당 2건 제한
- 실전투자: 초당 20건 제한
- **10배 성능 차이!**

**충돌 상황**:
모의투자 검증이 의미 있는가?
  → 제약이 10배 차이
  → 동작 양상이 완전히 다름
  → 검증 신뢰도 하락!
  
**영향**:
- 모의에서 성공한 전략이 실전에서 실패 가능
- 모의 환경에서 충분한 테스트 불가능
- 실전 직접 투입 위험 증가

**트레이드오프 옵션**:

**옵션 A: 모의 환경 제약에 맞춰 설계**
- 초당 2건 제한 내에서 전략 설계
- 장점: 모의 검증 신뢰도 100%
- 단점: 실전에서 성능 미활용 (20건 중 2건만 사용)

**옵션 B: 실전 환경 기준 설계 + 제한적 모의 테스트**
- 초당 20건 기준으로 설계
- 모의는 기본 로직만 검증
- 장점: 실전 성능 최대 활용
- 단점: 모의 검증 불완전

**옵션 C: 시뮬레이션 환경 자체 구축**
- 과거 데이터로 백테스팅 환경 구축
- 장점: 제약 없이 완전 테스트
- 단점: 개발 시간/비용 증가
```
> 📖 **더 알아보기**: [Manual 2.2절: 충돌 패턴 분석 방법론](./02M-01_environment_constraints_manual.md#22-충돌-패턴-분석-방법론)(`02M-01_environment_constraints_manual.md:221-300`)
>
> 📖 **실전 사례**: [Case: 주식 거래 시스템 충돌 분석](./02E-01_stock_trading_case.md#part-2-충돌-패턴)(`02E-01_stock_trading_case.md:150-250`)

---

## Part 3: 구현 방법 결정 (5단계)

Part 2에서 충돌을 발견했다면, 이제 **어떻게 구현할 것인지** 결정해야 합니다.

DNA 방법론의 **5단계 구현 결정 프로세스**를 따릅니다:

```
기능 → 속성 → 제약 → 기술 → 설계

1. 기능 요구사항 (Functional Requirements)
2. 속성 요구사항 (Quality Attributes = NFR)
3. 제약 사항 (Constraints = Layer 3)
4. 기술 스택 (Technology Stack)
5. 아키텍처 설계 (Architecture Design)
```

### 왜 5단계인가?

이 순서는 **SEI (Software Engineering Institute) ADD (Attribute-Driven Design)** 방법론에서 검증된 결정 순서입니다:

1. **기능이 먼저**: 무엇을 할 것인가?
2. **속성이 두 번째**: 얼마나 잘 해야 하는가?
3. **제약이 세 번째**: 현실적으로 무엇이 가능한가?
4. **기술이 네 번째**: 위 3가지를 만족하는 도구는?
5. **설계가 마지막**: 어떻게 조합할 것인가?

---

### P3-Q1: 핵심 기능 요구사항은 무엇인가요? (1단계)

**질문 의도**: Stage 1 Part 0에서 정의한 핵심 기능을 다시 확인합니다.

**작성 가이드**:
- Stage 1 Part 0 결과를 그대로 가져오기
- 변경 없음 (이미 확정됨)

**작성 예시**:

```markdown
## 1단계: 기능 요구사항

**핵심 기능** (Stage 1 Part 0):
- **주식 거래**

**세부 기능**:
1. 조건 설정 (가격, 수량, 지표)
2. 조건 감시 (시장 데이터 실시간 체크)
3. 자동 체결 (조건 만족 시 즉시 매매)

**목적**:
- 거래를 통한 주식의 소유권 획득 또는 소유권 이전
- 관련 법규와 규정의 범위 안에서 거래
- 수익 창출
- 24시간 자동 거래
```

---

### P3-Q2: 속성 요구사항(NFR)과 실제 달성 가능 수준은? (2단계)

**질문 의도**: Part 2에서 분석한 충돌을 반영하여, **이상적 목표**와 **현실적 달성 가능 수준**을 명확히 구분합니다.

**작성 가이드**:

```markdown
| NFR | 이상 (Stage 1) | 현실 (Part 2 분석) | 최종 결정 |
|-----|----------------|-------------------|-----------|
| 정확성 | A | 충돌 #1 | ? |
| 성능 | B | ✅ 가능 | B |
| 확장성 | B | ✅ 가능 | B |
| 최신성 | A | 충돌 #2 | ? |
```

**작성 예시**:

```markdown
## 2단계: 속성 요구사항 (NFR) 최종 결정

| NFR | 이상 목표 | 현실 제약 | 트레이드오프 결정 | 최종 등급 |
|-----|-----------|-----------|------------------|-----------|
| **정확성** | A (100%) | Rate Limit 충돌 | 옵션 C: 하이브리드<br>- 중요 20개: 실시간<br>- 나머지 80개: 5초 주기 | A (부분적) |
| **성능** | B (1초) | ✅ 200-400ms | 충분히 달성 가능 | B |
| **확장성** | B (중간) | ✅ 20건/초 | 100개 조건은 5초 주기로 가능 | B |
| **최신성** | A (실시간) | WebSocket 41개 제한 | 옵션 A: 동적 구독<br>- 우선순위 41개: 실시간<br>- 나머지: 5초 Polling | A (부분적) |

### 최종 NFR 프로파일

**현실적 달성 수준**: A(부분)-B-B-A(부분)

**핵심 트레이드오프**:
1. ✅ 중요한 기능은 정확성·최신성 A 유지
2. ⚠️ 비중요 기능은 B로 하락 수용
3. 📋 이 결정을 ADR로 문서화 (Stage 3)
```

---

### P3-Q3: 제약 사항 종합 정리 (3단계)

**질문 의도**: Part 1에서 조사한 모든 제약을 한눈에 볼 수 있도록 정리합니다.

**작성 가이드**:

```markdown
**Layer 3 제약**:
- [API 성능 제약]

**규제 제약**:
- [법률, 규정]

**비용 제약**:
- [예산 한도]

**기술 제약**:
- [호환성, 라이선스]
```

**작성 예시**:

```markdown
## 3단계: 제약 사항 종합

### Layer 3 제약 (성능)
- API Rate Limit: 실전 20건/초, 모의 2건/초
- WebSocket 구독: 최대 41개 동시
- 평균 응답 시간: 200-400ms

### 규제 제약
- 거래 기록 5년 보관 의무
- 개인정보 암호화 필수
- 데이터 국외 반출 금지 (한국 리전 필수)

### 비용 제약
- 월 예산: 50만원 이하
- 증권 API: 무료
- 클라우드: 40만원 (t3.medium)

### 기술 제약
- Python/Java 지원 (ActiveX 제외)
- 64비트 환경 필수
- 한국투자증권 API 사용
```

---

### P3-Q4: 적합한 기술 스택은 무엇인가요? (4단계)

**질문 의도**: 1-3단계에서 정리한 기능, 속성, 제약을 **모두 만족하는** 기술을 선택합니다.

**작성 가이드**:

**SEI ADD 원칙 적용**:
1. **NFR 프로파일 먼저** → 패밀리 코드
2. **패밀리에 맞는 기술** 후보 선정
3. **제약으로 필터링** → 최종 결정

**작성 예시**:

```markdown
## 4단계: 기술 스택 선택

### Step 1: 패밀리 기반 후보 선정

**패밀리**: A-C-A (Stage 1 결정)
  ├─ A: 실패 = 손실
  ├─ C: 스트림 데이터
  └─ A: 100ms 이하 (→ 현실: 200-400ms로 조정)

**패밀리 권장 기술**:
- **언어**: Python (데이터 처리), Go (고성능)
- **프레임워크**: FastAPI (비동기), Flask
- **DB**: PostgreSQL (트랜잭션), Redis (캐시)
- **메시징**: Kafka, RabbitMQ
- **실시간**: WebSocket, gRPC

### Step 2: 제약으로 필터링

| 기술 | 패밀리 적합 | 제약 만족 | 최종 |
|------|------------|----------|------|
| **언어: Python** | ✅ 데이터 처리 강점 | ✅ 한투 API 지원 | ✅ 선택 |
| 언어: Go | ✅ 고성능 | ❌ 한투 API 미지원 | ❌ 제외 |
| **프레임워크: FastAPI** | ✅ 비동기 지원 | ✅ Python 기반 | ✅ 선택 |
| **DB: PostgreSQL** | ✅ 트랜잭션 | ✅ 5년 보관 가능 | ✅ 선택 |
| DB: MongoDB | ⚠️ 비정형 | ✅ 가능 | ❌ 불필요 (정형 데이터) |
| **캐시: Redis** | ✅ 고속 | ✅ 조건 캐싱 | ✅ 선택 |
| **실시간: WebSocket** | ✅ 필수 | ✅ 한투 제공 | ✅ 선택 |

### Step 3: 최종 기술 스택

[언어]
- Python 3.11+

[웹 프레임워크]
- FastAPI (비동기 처리)

[데이터베이스]
- PostgreSQL 15+ (거래 기록, 5년 보관)
- Redis 7+ (조건 캐싱, 실시간 데이터)

[실시간 통신]
- WebSocket (한국투자증권)

[클라우드]
- AWS Seoul Region (데이터 국내 보관)
- t3.medium (월 40만원)

[모니터링]
- CloudWatch (AWS 기본 제공)

### 기술 선택 근거 (ADR 작성 예정)

1. **Python**: 한투 API 공식 지원, 데이터 분석 생태계
2. **FastAPI**: 비동기 처리로 20건/초 Rate Limit 최적 활용
3. **PostgreSQL**: 트랜잭션 ACID, 5년 보관 안정성
4. **Redis**: 100개 조건 빠른 매칭 (메모리 캐시)
5. **WebSocket**: 41개 핵심 종목 실시간 감시
6. **AWS Seoul**: 규제 준수 (데이터 국내), 안정적 SLA
```
> 📖 **더 알아보기**: [Manual 3.1절: 기술 스택 선택 방법론 (SEI ADD)](./02M-01_environment_constraints_manual.md#31-기술-스택-선택-방법론)(`02M-01_environment_constraints_manual.md:301-400`)

---

### P3-Q5: 아키텍처 설계 방향은? (5단계)

**질문 의도**: 선택한 기술 스택으로 **어떤 아키텍처 패턴**을 사용할 것인지 결정합니다.

**작성 가이드**:

1. **패밀리 권장 패턴** 확인
2. **충돌 해결 방안** 반영
3. **고수준 아키텍처 스케치**

**작성 예시**:

```markdown
## 5단계: 아키텍처 설계 방향

### 패밀리 A-C-A 권장 패턴

**핵심 패턴**: Event-Driven + Microservices
- **Event-Driven**: 실시간 스트림 처리 (Layer 2: C)
- **트랜잭션 보장**: ACID + 보상 트랜잭션 (Layer 1: A)
- **고성능**: 비동기 처리, 캐싱 (Layer 3: A → 현실 B)

### 충돌 해결 아키텍처 반영

**충돌 #1 해결** (Rate Limit):
[아키텍처 컴포넌트]
Priority Queue Scheduler
  ├─ High Priority (20개): 1초 주기 체크
  ├─ Medium Priority (30개): 3초 주기 체크
  └─ Low Priority (50개): 5초 주기 체크

총 API 호출: 20건 (High) + 10건 (Med) + 10건 (Low) = 40건
→ 2초에 분산하면 20건/초 준수!

**충돌 #2 해결** (WebSocket 41개):
[아키텍처 컴포넌트]
Dynamic Subscription Manager
  ├─ WebSocket Pool: 41개 슬롯
  ├─ Priority Ranking: 실시간 우선순위 계산
  └─ Swap Mechanism: 우선순위 변경 시 구독 교체
  
### 고수준 아키텍처 스케치
┌─────────────────────────────────────────┐
│         API Gateway (FastAPI)            │
│  - REST API (사용자 조건 설정)           │
│  - WebSocket (실시간 알림)               │
└────────────┬────────────────────────────┘
             │
┌────────────┴────────────────────────────┐
│      Application Layer                   │
│  ┌─────────────┐  ┌──────────────────┐ │
│  │ Condition   │  │ Trading Engine   │ │
│  │ Manager     │  │ (주문 실행)      │ │
│  └─────────────┘  └──────────────────┘ │
└────────────┬────────────────────────────┘
             │
┌────────────┴────────────────────────────┐
│      Event Processing Layer              │
│  ┌─────────────┐  ┌──────────────────┐ │
│  │ WebSocket   │  │ Priority Queue   │ │
│  │ Subscriber  │  │ Scheduler        │ │
│  │ (41개)      │  │ (Rate Limit)     │ │
│  └─────────────┘  └──────────────────┘ │
└────────────┬────────────────────────────┘
             │
┌────────────┴────────────────────────────┐
│      Data Layer                          │
│  ┌─────────────┐  ┌──────────────────┐ │
│  │ PostgreSQL  │  │ Redis Cache      │ │
│  │ (거래 기록) │  │ (조건 매칭)      │ │
│  └─────────────┘  └──────────────────┘ │
└────────────┬────────────────────────────┘
             │
┌────────────┴────────────────────────────┐
│      External Integration                │
│  ┌─────────────┐  ┌──────────────────┐ │
│  │ 한국투자    │  │ WebSocket        │ │
│  │ REST API    │  │ Real-time        │ │
│  │ (20건/초)   │  │ (41개 구독)      │ │
│  └─────────────┘  └──────────────────┘ │
└─────────────────────────────────────────┘

### 핵심 설계 결정

1. **Event-Driven Architecture**: 실시간 이벤트 처리
2. **Priority-Based Scheduling**: Rate Limit 우회
3. **Dynamic Subscription**: WebSocket 최적 활용
4. **Redis Caching**: 조건 매칭 성능 향상
5. **ACID Transaction**: 거래 정확성 보장
```
> 📖 **더 알아보기**: [Manual 3.2절: 아키텍처 패턴 선택 가이드](./02M-01_environment_constraints_manual.md#32-아키텍처-패턴-선택)(`02M-01_environment_constraints_manual.md:401-500`)
>
> 📖 **실전 사례**: [Case: 주식 거래 시스템 아키텍처 설계](./02E-01_stock_trading_case.md#part-3-구현-방법)(`02E-01_stock_trading_case.md:251-400`)

---

### P3-Q6: DNA 시스템은 어떻게 구성하나요? (6단계)

**질문 의도**: 모든 소프트웨어에 필수적인 **DNA 시스템 11개**를 패밀리 특성과 규모/예산에 맞춰 구성합니다.

**핵심 개념**:
```
소프트웨어 시스템 구성:
├─ DNA 시스템 (11개) ← 필수, 모든 프로젝트 공통
│   └─ 로깅, 에러 핸들링, 설정 관리 등
└─ 도메인 시스템 ← 선택, 문제 해결 위해 구상
    └─ Priority Queue Scheduler, Subscription Manager 등

선택의 자유도:
├─ ❌ 외부 제약 (어쩔 수 없음) → Part 1
├─ ❌ 충돌 타협 (어쩔 수 없음) → Part 2
├─ 🔄 기술 스택 (최선 선택) → Part 3-4단계
├─ 🔄 도메인 기술 (문제 해결 필수) → Part 3-5단계
└─ 🔄 DNA 시스템 (패밀리 + 규모/예산 → 대부분 자동 결정) → Part 3-6단계

💡 실제로는 "꼬리에 꼬리를 물면서" 대부분 자동 결정됨!
```

**작성 가이드**:

**Step 1: 패밀리 매트릭스에서 DNA 기본 스택 확인**

각 패밀리는 DNA 시스템 11개에 대한 권장 기술 스택을 제공합니다. (1호가 작성 중인 7개 패밀리 매트릭스 참조)

**Step 2: 규모와 예산에 따른 조정**

| DNA 시스템 | 소규모 (< 1000 사용자) | 중규모 (< 10만 사용자) | 대규모 (> 10만 사용자) |
|-----------|---------------------|-------------------|-------------------|
| **로깅** | 파일 로깅 (무료) | CloudWatch (월 $10) | ELK Stack (월 $100+) |
| **DB 연결** | 단순 커넥션 풀 | asyncpg (비동기) | PgBouncer (연결 관리) |
| **캐싱** | 로컬 메모리 | Redis (월 $30) | Redis Cluster |
| **모니터링** | 기본 헬스체크 | Prometheus | Datadog/New Relic |

**Step 3: DNA 시스템 11개 ADR 목록 생성**

**작성 예시**:

```markdown
## 6단계: DNA 시스템 구성

### DNA 시스템 11개 목록

**우리 프로젝트**: 소규모 (< 100 사용자), 월 40만원 예산, A-C-A 패밀리

#### 1. 로깅 시스템
- **선택**: structlog + 파일 로깅
- **근거**:
  - A-C-A → 구조화 로그 필수 (스트림 데이터 추적)
  - 소규모 → CloudWatch 불필요, 파일로 충분
- **ADR**: ADR-001 로깅 전략

#### 2. 에러 핸들링
- **선택**: FastAPI HTTPException + 트랜잭션 롤백
- **근거**:
  - A-C-A → Layer 1: A (실패=손실) → 트랜잭션 필수
  - FastAPI 표준 예외 + 커스텀 에러 코드
- **ADR**: ADR-002 에러 핸들링 전략

#### 3. 설정 관리
- **선택**: pydantic Settings + .env
- **근거**:
  - 소규모 → AWS Secrets Manager 불필요
  - FastAPI와 통합 용이
- **ADR**: ADR-003 설정 관리

#### 4. DB 연결 관리
- **선택**: SQLAlchemy async + 커넥션 풀 (pool_size=5)
- **근거**:
  - A-C-A → 비동기 필수 (실시간 처리)
  - 소규모 → pool_size 5면 충분
- **ADR**: ADR-004 DB 연결 전략

#### 5. 인증/인가
- **선택**: JWT (jose) + 간단한 RBAC
- **근거**:
  - 개인 사용 → OAuth 불필요
  - JWT로 stateless 인증
- **ADR**: ADR-005 인증/인가 전략

#### 6. 캐싱
- **선택**: Redis 7+ (AWS ElastiCache)
- **근거**:
  - 100개 조건 매칭 → 메모리 캐시 필수
  - 월 $30 예산 내
- **ADR**: ADR-006 캐싱 전략

#### 7. 비동기 처리
- **선택**: FastAPI BackgroundTasks (간단한 작업용)
- **근거**:
  - 소규모 → Celery 불필요
  - 간단한 알림 전송만 비동기
- **ADR**: ADR-007 비동기 처리

#### 8. API 설계
- **선택**: REST + OpenAPI 자동 문서화
- **근거**:
  - FastAPI 기본 제공
  - 개인 사용 → GraphQL 불필요
- **ADR**: ADR-008 API 설계 원칙

#### 9. 테스트 전략
- **선택**: pytest + pytest-asyncio
- **근거**:
  - Python 표준
  - 비동기 코드 테스트 필요
- **ADR**: ADR-009 테스트 전략

#### 10. 배포 전략
- **선택**: Docker + AWS ECS Fargate
- **근거**:
  - 서버 관리 불필요
  - 월 예산 내 (t3.medium 상당)
- **ADR**: ADR-010 배포 전략

#### 11. 모니터링
- **선택**: CloudWatch 기본 모니터링 + 헬스체크
- **근거**:
  - AWS 기본 제공 (추가 비용 무)
  - 소규모 → Datadog 불필요
- **ADR**: ADR-011 모니터링 전략

### DNA 시스템 결정 요약

| DNA 시스템 | 선택 기술 | 결정 근거 | ADR |
|-----------|----------|----------|-----|
| 1. 로깅 | structlog + 파일 | A-C-A (구조화) + 소규모 | ADR-001 |
| 2. 에러 | HTTPException + 롤백 | A-C-A (트랜잭션) | ADR-002 |
| 3. 설정 | pydantic + .env | 소규모 | ADR-003 |
| 4. DB 연결 | SQLAlchemy async | A-C-A (비동기) | ADR-004 |
| 5. 인증 | JWT + RBAC | 개인 사용 | ADR-005 |
| 6. 캐싱 | Redis 7+ | 필수 (조건 매칭) | ADR-006 |
| 7. 비동기 | BackgroundTasks | 소규모 | ADR-007 |
| 8. API | REST + OpenAPI | FastAPI 기본 | ADR-008 |
| 9. 테스트 | pytest + async | Python 표준 | ADR-009 |
| 10. 배포 | Docker + Fargate | 예산 내 | ADR-010 |
| 11. 모니터링 | CloudWatch | AWS 기본 | ADR-011 |

💡 **패턴 발견**:
- 패밀리 (A-C-A) → 4개 자동 결정 (로깅, 에러, DB, 캐싱)
- 규모 (소규모) → 5개 자동 결정 (설정, 비동기, 배포, 모니터링, 인증)
- 기술 스택 (FastAPI) → 2개 자동 결정 (API, 테스트)

👉 **총 11개 중 11개 "꼬리에 꼬리를 물면서" 결정됨!**
```

> 📖 **더 알아보기**: [Manual 3.3절: DNA 시스템 구성 방법](./02M-01_environment_constraints_manual.md#33-dna-시스템-구성)(`02M-01_environment_constraints_manual.md:501-650`)

---

## 산출물 작성 가이드

### Stage 2 최종 산출물: `02D-01_implementation_approach.md`

Stage 2는 **1개의 통합 문서**를 생성합니다. 이 문서는 Part 1-3의 모든 결과를 포함하며, Stage 3 (ADR 작성)의 입력이 됩니다.

**작성 순서** (중요!):
```
1. Part 1 작업 → 중간 결과 정리
2. Part 2 작업 → Part 1 결과 사용, 중간 결과 정리
3. Part 3 작업 → Part 1-2 결과 사용
4. 최종 문서 작성 → 02D-01_implementation_approach.md
```

---

### 문서 구조: `02D-01_implementation_approach.md`

```markdown
# Stage 2: 환경 제약 및 구현 방법 결정서

> **프로젝트**: [프로젝트명]
> **작성일**: YYYY-MM-DD
> **패밀리**: A-C-A (Stage 1 결과)
> **NFR**: A-B-B-A (Stage 1 결과)

---

## Part 1: Layer 3 (외부 제약) 조사 결과

### 1.1 외부 서비스/API 비교
[P1-Q1 결과: 비교표]

**선택**: [최종 선택한 API/서비스]
**이유**: [선택 근거]

### 1.2 기타 제약사항
[P1-Q2 결과]
- 규제: ...
- 클라우드: ...
- 비용: ...
- 기술: ...

### 1.3 제약 종합
[Part 1 요약]

---

## Part 2: 충돌 패턴 식별 결과

### 2.1 NFR 달성 가능성 분석
[P2-Q1 결과: NFR별 달성 가능성 표]

### 2.2 발견된 충돌

#### 충돌 #1: [제목]
[P2-Q2 결과: 목표, 현실, 충돌 상황, 영향]

**트레이드오프 옵션**:
- 옵션 A: ...
- 옵션 B: ...
- 옵션 C: ...

**선택**: 옵션 [X]
**이유**: ...

#### 충돌 #2: [제목]
...

### 2.3 충돌 해결 요약
[모든 충돌과 선택된 옵션 요약]

---

## Part 3: 5단계 구현 방법 결정

### 3.1 1단계: 기능 요구사항
[P3-Q1 결과: Stage 1 Part 0 재확인]

### 3.2 2단계: 속성 요구사항 (NFR)
[P3-Q2 결과: 트레이드오프 반영된 현실적 NFR]

### 3.3 3단계: 제약 사항
[P3-Q3 결과: Part 1 제약 종합]

### 3.4 4단계: 기술 스택
[P3-Q4 결과: 선택된 기술 스택과 근거]

### 3.5 5단계: 아키텍처 설계
[P3-Q5 결과: 고수준 아키텍처 스케치와 도메인 기술]

### 3.6 6단계: DNA 시스템 구성
[P3-Q6 결과: DNA 시스템 11개 선택과 근거]

---

## Stage 3 준비: ADR 작성 목록

Stage 2에서 결정된 모든 사항은 Stage 3에서 ADR로 문서화됩니다. ADR은 **5개 카테고리**로 구성됩니다:

### 📋 ADR 5개 카테고리 (총 ~25개)

#### 1️⃣ 외부 제약 ADR (Part 1 결과, 3-5개)
**어쩔 수 없는 선택** - 외부 요인으로 강제된 결정

**작성 항목**:
- **ADR-101**: [외부 API/서비스] 선택
  - 내용: Part 1.1 비교 결과
  - 근거: 공식 지원, 기능 만족, 제약 준수

- **ADR-102**: [클라우드 제공자] 선택
  - 내용: Part 1.2 제약 분석
  - 근거: 지역 요구사항, 규제 준수

- **ADR-103**: [규제/컴플라이언스] 준수 방안
  - 내용: Part 1.2 규제 요구사항
  - 근거: 법적 의무사항

**예시**: 한국투자증권 API 선택, AWS Seoul Region, 금융위원회 전자금융거래법 준수

---

#### 2️⃣ 충돌 해결 ADR (Part 2 결과, 2-3개)
**어쩔 수 없는 타협** - NFR 간 충돌과 트레이드오프 결정

**작성 항목**:
- **ADR-201**: 충돌 #1 - [충돌 제목]
  - 내용: Part 2.2 충돌 분석
  - 트레이드오프: 옵션 A vs B vs C
  - 선택: 옵션 [X]
  - 근거: [장기적 관점, 비용 효율 등]

- **ADR-202**: 충돌 #2 - [충돌 제목]
  - 내용: Part 2.2 충돌 분석
  - 근거: [우선순위, 제약 등]

**예시**: 하이브리드 아키텍처 (성능-일관성 균형), Rate Limit 우회 전략

---

#### 3️⃣ 기술 스택 ADR (Part 3-4단계 결과, 4-6개)
**최선의 선택** - 패밀리 권장 + 제약으로 필터링된 기술

**작성 항목**:
- **ADR-301**: [언어] 선택
  - 내용: Part 3.4 기술 스택 결정
  - 근거: 패밀리 권장 + 외부 API 지원

- **ADR-302**: [프레임워크] 선택
  - 내용: Part 3.4 기술 스택 결정
  - 근거: 패밀리 특성 (비동기, 성능 등)

- **ADR-303**: [데이터베이스] 선택
  - 내용: Part 3.4 기술 스택 결정
  - 근거: 트랜잭션, NFR 요구사항

- **ADR-304**: [기타 기술] 선택
  - 내용: Part 3.4 기술 스택 결정
  - 근거: 특정 기능 요구사항

**예시**: Python 3.11+, FastAPI, PostgreSQL + Redis, WebSocket

---

#### 4️⃣ 도메인 기술 ADR (Part 3-5단계 결과, 2-4개)
**문제 해결 필수** - 아이디어 현실화를 위해 구상한 시스템

**작성 항목**:
- **ADR-401**: [도메인 컴포넌트 #1] 설계
  - 내용: Part 3.5 아키텍처 설계
  - 근거: 충돌 해결, 문제 해결 필수

- **ADR-402**: [도메인 컴포넌트 #2] 설계
  - 내용: Part 3.5 아키텍처 설계
  - 근거: 핵심 기능 구현 필수

**예시**: Priority Queue Scheduler, Dynamic Subscription Manager, Event-Driven Architecture

---

#### 5️⃣ DNA 시스템 ADR (Part 3-6단계 결과, 11개)
**자동 결정** - 패밀리 매트릭스 + 규모/예산으로 대부분 자동 결정

**작성 항목**:
- **ADR-001**: 로깅 전략
- **ADR-002**: 에러 핸들링 전략
- **ADR-003**: 설정 관리 전략
- **ADR-004**: DB 연결 관리 전략
- **ADR-005**: 인증/인가 전략
- **ADR-006**: 캐싱 전략
- **ADR-007**: 비동기 처리 전략
- **ADR-008**: API 설계 원칙
- **ADR-009**: 테스트 전략
- **ADR-010**: 배포 전략
- **ADR-011**: 모니터링 전략

**내용**: Part 3.6 DNA 시스템 구성 결과
**근거**: 패밀리 특성, 규모, 예산, 기술 스택 선택

**예시**: structlog + 파일, HTTPException + 롤백, pydantic + .env, SQLAlchemy async 등

---

### 🎯 ADR 작성 목록 요약

| 카테고리 | 개수 | 결정 근거 | 예시 |
|---------|-----|---------|------|
| 1. 외부 제약 | 3-5 | 어쩔 수 없음 | 한투 API, AWS Seoul |
| 2. 충돌 해결 | 2-3 | 어쩔 수 없음 | 하이브리드 아키텍처 |
| 3. 기술 스택 | 4-6 | 최선 선택 | FastAPI, PostgreSQL |
| 4. 도메인 기술 | 2-4 | 문제 해결 필수 | Priority Scheduler |
| 5. DNA 시스템 | 11 | 자동 결정 | 로깅, 에러, 인증 등 |
| **합계** | **22-29** | **꼬리에 꼬리** | **Stage 3 입력** |

💡 **핵심**: "꼬리에 꼬리를 물면서" 대부분 자동으로 결정됨!

**예상 ADR 총 개수**: [22-29]개
```

---

## Stage 2 완료 체크리스트

다음 항목을 **순서대로** 완료했는지 확인하세요:

### Part 1: Layer 3 조사 (먼저)
- [ ] P1-Q1: 외부 서비스/API 비교표 작성 (최소 2개 이상)
- [ ] P1-Q2: 규제, 클라우드, 비용, 기술 제약 조사
- [ ] Part 1 중간 결과 정리 (메모/초안)

### Part 2: 충돌 패턴 식별 (Part 1 완료 후)
- [ ] P2-Q1: NFR 달성 가능성 분석 (Part 1 제약 사용)
- [ ] P2-Q2: 충돌 패턴 상세 분석 (최소 1개 이상)
- [ ] 각 충돌에 대한 트레이드오프 옵션 제시 (2-3개)
- [ ] 각 충돌별 최종 선택 결정
- [ ] Part 2 중간 결과 정리 (메모/초안)

### Part 3: 구현 방법 결정 (Part 1-2 완료 후)
- [ ] P3-Q1: 기능 요구사항 확인 (Stage 1 Part 0)
- [ ] P3-Q2: 현실적 NFR 수준 결정 (Part 2 트레이드오프 반영)
- [ ] P3-Q3: 제약 종합 정리 (Part 1 결과 사용)
- [ ] P3-Q4: 기술 스택 선택 (SEI ADD 원칙)
- [ ] P3-Q5: 아키텍처 설계 방향 수립 (도메인 기술)
- [ ] P3-Q6: DNA 시스템 11개 구성

### 최종 산출물 작성
- [ ] `02D-01_implementation_approach.md` 작성
  - [ ] Part 1 결과 포함
  - [ ] Part 2 결과 포함
  - [ ] Part 3 결과 포함 (Q1-Q6)
  - [ ] Stage 3 준비: ADR 작성 목록 5개 카테고리 포함

### Stage 3 입력 확인
- [ ] ADR 5개 카테고리 모두 식별됨
  - [ ] 1️⃣ 외부 제약 ADR (3-5개)
  - [ ] 2️⃣ 충돌 해결 ADR (2-3개)
  - [ ] 3️⃣ 기술 스택 ADR (4-6개)
  - [ ] 4️⃣ 도메인 기술 ADR (2-4개)
  - [ ] 5️⃣ DNA 시스템 ADR (11개)
- [ ] 각 ADR 주제와 결정 내용이 문서화됨
- [ ] 예상 ADR 총 개수 파악됨 (22-29개)

---

## 변경 이력

- **v4.0 (2025-11-14)**: 초안 작성
  - Part 1-3 구조 확립
  - 5단계 구현 결정 프로세스 정의
  - 충돌 패턴 분석 방법론 정립
  - 맥락 있는 설명과 흐름 강화
  - 새로운 링크 스타일 적용

---

**문서 끝**


================================================================================
# End of 02G-00_environment_constraints_guide.md
================================================================================



================================================================================
# 📄 3. 03G-00_adr_guide.md
================================================================================

# ADR (Architecture Decision Records) 작성 가이드

> **목적**: Stage 3 - 모든 아키텍처 결정을 문서화하고 시스템 강제(System Enforcement)로 전환
>
> **버전**: v3.0 (2025-11-13, Stage 3 분리)
> - v3.0: Guide/Manual/Cases 분리로 간결성 확보
> - v2.0: Stage 3 범위 명시 (DNA 시스템 vs 도메인 ADR 구분)
> - v1.0: ADR 작성 방법론 확립

---

## 📚 이 가이드의 구성

- **이 문서** (Guide): ADR 작성 방법 + 템플릿
- **상세 설명** (Manual):
  - `03M-01_adr_types_manual.md` - 5가지 유형 상세
  - `03M-02_adr_to_standards_manual.md` - 변환 프로세스
- **실전 사례** (Cases):
  - `IMPLEMENTATION_CASES.md` - 프로젝트 사례
  - `03M-01_adr_types_manual.md` 섹션 2-6 - 구현방법→ADR 변환 사례

---

---

## 📚 이 가이드의 구성

- **이 문서** (Guide): ADR 작성 방법 + 템플릿
- **사례집** (Cases): 실전 ADR 예시 → `IMPLEMENTATION_CASES.md`

---

## 📥 입력 문서 (Stage 2에서 받은 것)

Stage 3를 시작하기 전에 다음 문서를 읽어야 합니다:

#### 1. **`02D-01_tech_stack_decision.md`** (필수)
- 확정된 DNA 시스템 기술 스택
- 확정된 Domain 기술 스택
- **활용**: ADR 작성 대상 파악

#### 2. **`02C-01_layer3_constraints.md`** (필수)
- 외부 제약 조사 결과
- **활용**: 제약에 의한 결정 ADR 작성

#### 3. **`02C-02_conflicts_analysis.md`** (필수)
- 충돌 패턴 및 해결 방안
- **활용**: 충돌 해결 ADR 작성

#### 4. **`02L-01_adr_list.md`** (필수)
- 작성할 ADR 목록 (18-25개)
- 우선순위
- **활용**: ADR 작성 계획

#### 5. **`02S-02_data_schema_v1.md`**, **`02S-03_api_design_v1.md`** (필수)
- 데이터 스키마 및 API 설계
- **활용**: 설계 결정 ADR 작성

#### 6. **Stage 1 모든 산출물** (참고)
- 패밀리, NFR, 핵심 기능
- **활용**: 결정의 근거

---

## 📤 출력 문서 (이 Stage에서 생성해야 할 문서)

### 필수 문서

#### DNA 시스템 ADR (001-099)
**위치**: `docs/adr/dna-systems/`

**DNA 시스템 ADR 목록** (전 프로젝트 공통 요소):

1. **`03A-001_logging_strategy.md`**
   - 로깅 레벨, 포맷, 저장소
   - 예: Structured logging with JSON format

2. **`03A-002_error_handling_standard.md`**
   - 에러 타입, 메시지 형식, 전파 방식
   - 예: Custom exception hierarchy

3. **`03A-003_authentication_method.md`**
   - 인증 방식 (JWT, OAuth, Session 등)
   - 예: JWT with RS256

4. **`03A-004_configuration_management.md`**
   - 환경 변수, 설정 파일 관리
   - 예: Pydantic Settings

5. **`03A-005_database_connection_pooling.md`**
   - Connection pool 설정
   - 예: SQLAlchemy pool size

6. **`03A-006_caching_strategy.md`**
   - 캐시 레이어 설계
   - 예: Redis cache-aside pattern

7. **`03A-007_api_versioning.md`**
   - API 버전 관리 방식
   - 예: URL path versioning (/v1/)

8. **`03A-008_cors_policy.md`**
   - CORS 설정
   - 예: Origin whitelist

9. **`03A-009_rate_limiting.md`**
   - API 요청 제한
   - 예: Token bucket algorithm

10. **`03A-010_monitoring_observability.md`**
    - 모니터링 및 메트릭 수집
    - 예: Prometheus + Grafana

... (총 10-15개)

---

#### Domain ADR (100-999)
**위치**: `docs/adr/domain/`

**Domain ADR 목록** (프로젝트 특화 요소):

##### 외부 제약 관련 (101-105)
1. **`03A-101_kis_api_selection.md`**
   - 한국투자증권 API 선택
   - 대안: 키움증권, eBest
   - 근거: Layer 3 조사 결과

2. **`03A-102_api_rate_limit_handling.md`**
   - 20건/초 제한 대응
   - 해결: Queue + throttling

##### 충돌 해결 관련 (106-110)
3. **`03A-106_hybrid_order_strategy.md`**
   - REST + WebSocket 하이브리드
   - 충돌: 정확성 A + API 제한
   - 해결: WebSocket으로 실시간 체결, REST로 주문

4. **`03A-107_websocket_channel_management.md`**
   - 41개 채널 관리 방식
   - 충돌: 즉시성 A + 채널 제한

##### 기술 스택 관련 (111-115)
5. **`03A-111_fastapi_selection.md`**
   - FastAPI 선택
   - 대안: Django, Flask
   - 근거: 비동기, 성능, 타입 안전성

6. **`03A-112_postgresql_selection.md`**
   - PostgreSQL 선택
   - 대안: MySQL, CockroachDB
   - 근거: ACID, JSON 지원

7. **`03A-113_redis_usage.md`**
   - Redis 사용 범위
   - 캐시 + Queue + Pub/Sub

8. **`03A-114_nextjs_react_selection.md`**
   - Next.js + React 선택
   - 대안: Vue, Svelte
   - 근거: SSR, 생태계

##### 데이터 설계 관련 (116-120)
9. **`03A-116_order_schema_design.md`**
   - 주문 테이블 스키마
   - UUID vs SERIAL, status enum

10. **`03A-117_price_data_storage.md`**
    - 실시간 가격 데이터 저장
    - TimescaleDB vs Redis

11. **`03A-118_user_portfolio_model.md`**
    - 포트폴리오 데이터 모델

##### API 설계 관련 (121-125)
12. **`03A-121_rest_api_design.md`**
    - REST API 엔드포인트 설계
    - RESTful 원칙 적용

13. **`03A-122_websocket_protocol.md`**
    - WebSocket 메시지 프로토콜
    - JSON format, subscription model

14. **`03A-123_error_response_format.md`**
    - API 에러 응답 표준
    - RFC 7807 Problem Details

##### 품질/보안 관련 (126-130)
15. **`03A-126_input_validation.md`**
    - 입력 검증 전략
    - Pydantic models

16. **`03A-127_security_headers.md`**
    - 보안 헤더 설정
    - HSTS, CSP, X-Frame-Options

... (총 15-20개)

---

### ADR 템플릿

모든 ADR은 다음 형식을 따라야 합니다:

```markdown
# ADR-XXX: {Decision Title}

**상태**: Accepted | Proposed | Deprecated
**작성일**: YYYY-MM-DD
**결정자**: {Team/Person}
**태그**: #{dna-systems|domain}, #{tech-stack|data|api|...}

---

## Context (배경)

왜 이 결정이 필요한가?
- 문제 상황
- 제약 조건
- 요구사항

## Decision (결정)

무엇을 선택했는가?
- 선택한 옵션
- 핵심 이유 (간결하게)

## Alternatives (대안)

고려했던 다른 옵션들:
1. **Option A**: ...
   - 장점: ...
   - 단점: ...
   - 거부 이유: ...

2. **Option B**: ...

## Consequences (결과)

이 결정의 영향:
- ✅ 긍정적 영향
- ⚠️ 트레이드오프
- ❌ 부정적 영향
- 🔄 후속 조치 필요

## References (참고)

- Stage 2 문서: {파일명}
- 외부 링크: {URL}
- 관련 ADR: ADR-XXX
```

---

### ADR 작성 우선순위

1. **Phase 1**: 외부 제약 ADR (101-105)
   - 가장 먼저 작성 (변경 불가능)

2. **Phase 2**: 충돌 해결 ADR (106-110)
   - 외부 제약 기반 해결책

3. **Phase 3**: 핵심 기술 스택 ADR (111-115)
   - DNA 시스템 + Domain 주요 기술

4. **Phase 4**: 설계 ADR (116-125)
   - 데이터, API 설계

5. **Phase 5**: DNA 시스템 ADR (001-015)
   - 공통 환경 요소

6. **Phase 6**: 품질/보안 ADR (126-130)
   - 마지막 (다른 ADR 참조)

---

## 🔄 다음 Stage로 전달되는 것

Stage 3 → Stage 4:
- ✅ 완성된 DNA 시스템 ADR (10-15개)
- ✅ 완성된 Domain ADR (15-20개)
- ✅ 모든 아키텍처 결정의 근거 문서화

Stage 4에서는 이를 기반으로:
- DNA 시스템 ADR을 바탕으로 DNA 기본시스템 청사진 작성
- core/ 모듈 설계

---

## 📍 전체 프로세스에서의 위치

```
전체 프로세스:
Stage 0: 아이디어
Stage 1: 패밀리 구분 (01G-00_core_definition_guide.md) ✅
Stage 2: 구조설계 (02G-00_structure_design_guide.md) ✅
Stage 3: ADR 문서화 ← 이 가이드 ⭐
Stage 4-5: DNA 시스템 계획 및 실행
Stage 6-9: Standards → Blueprint → 분해 → 구현
```

---

## Stage 2에서 받은 입력

Stage 2 완료 후 확정된 것:
- ✅ **외부 제약** (API, 규제, 배포환경)
- ✅ **충돌 패턴** (NFR vs 제약)
- ✅ **기술 스택** (언어, DB, 프레임워크)
- ✅ **아키텍처** (구조, 통신, 배포)

Stage 3의 목표:
- 🔄 **DNA 시스템 ADR 작성** (전 프로젝트 공통)
- 🔄 **도메인 ADR 작성** (프로젝트 특화)
- 🔄 **ADR 원칙 적용** (제약도 ADR이다!)

---

## DNA 시스템 ADR vs 도메인 ADR ⭐

> **⚠️ TODO (2025-11-12)**:
> - 1호가 추가 패밀리 발견 및 명확한 구분 방법 확립
> - DNA 시스템 ADR 정의 수정 필요:
>   - 현재: core/ 공통 요소 (잘못된 이해)
>   - 올바름: 패밀리가 정한 시스템 구조에서 나오는 요소
> - 패밀리별 DNA 시스템 요소 목록 추가 예정

---

### ADR 작성 로직 (올바른 흐름)

```
1. 패밀리 결정 (Stage 1)
   ↓
2. 패밀리 → 시스템 구조 자동 결정
   ↓
3. 시스템 구조에서 DNA 시스템 vs 도메인 요소 구분
   - DNA 시스템: 구조가 강제하는 요소
   - 도메인: 프로젝트 특화 요소
   ↓
4. 도메인 특성 검토 → 추가 DNA 시스템 요소 발견
   ↓
5. DNA 시스템 ADR + 도메인 ADR 작성
```

---

### DNA 시스템 ADR (시스템 구조 기반)

**정의**: 패밀리가 결정한 시스템 구조에서 자동으로 도출되는 요소

**예시** (TODO: 패밀리별 상세 목록 추가 예정):
- A-A-A (CRUD/트랜잭션):
  - RDBMS 필수
  - ACID 트랜잭션 필수
  - ORM 필수
  - ...

- A-C-A (실시간 트랜잭션):
  - RDBMS + WebSocket 필수
  - 메시지 큐 필수
  - 캐시 필수
  - ...

**특징**:
- 패밀리가 정하면 자동으로 결정됨
- 도메인과 무관하게 필수
- 시스템 구조의 필수 구성 요소

---

### 도메인 ADR (프로젝트 특화)

**정의**: 특정 프로젝트만의 고유한 결정

**주식 거래 플랫폼 예시**:
- **ADR-101**: 한국투자증권 선택 (vs 키움, 이베스트)
- **ADR-102**: 하이브리드 아키텍처 (WebSocket + Polling)
- **ADR-103**: FastAPI 선택 (Python 프레임워크)
- **ADR-104**: PostgreSQL + Redis (구체적 DB 선택)
- **ADR-105**: Human-in-the-loop 주문 검증

**특징**:
- 프로젝트별 요구사항 반영
- DNA 시스템이 정한 범주 내에서 구체적 선택
- 도메인 제약 조건 반영

---

### ADR 번호 체계

```
DNA 시스템 ADR: 001-099
- 패밀리별 필수 구조 요소
- 시스템 구조가 강제하는 결정

도메인 ADR: 100+
- 프로젝트별로 100번대부터 시작
- DNA 시스템 범주 내 구체적 선택
```

---

## 목차

0. [DNA 시스템 vs 도메인 ADR](#dna-시스템-adr-vs-도메인-adr-) ⭐
1. [ADR이란 무엇인가](#1-adr이란-무엇인가)
2. [ADR의 5가지 유형](#2-adr의-5가지-유형)
3. [ADR 7개 섹션 템플릿](#3-adr-7개-섹션-템플릿)
4. [좋은 ADR 작성하기](#4-좋은-adr-작성하기)
5. [ADR → Standards 변환 프로세스](#5-adr--standards-변환-프로세스)
6. [ADR 생명주기 관리](#6-adr-생명주기-관리)
7. [다음 단계 연결](#7-다음-단계-연결)

---

## 1. ADR이란 무엇인가

### 1-1. 정의

**Architecture Decision Record (ADR)**는 프로젝트의 중요한 아키텍처 결정을 문서화하는 짧은 문서입니다.

**핵심 개념**:
- **단일 결정**: 하나의 ADR = 하나의 아키텍처 결정
- **결정 + 근거**: "무엇을" + "왜" 선택했는지
- **불변성**: 한번 작성된 ADR은 수정하지 않음 (Superseded로 대체)
- **시스템 강제**: Compliance 섹션을 통해 결정이 실제로 지켜지도록 강제

### 1-2. Jason의 방법론에서 ADR의 위치

#### 전체 흐름 (Amazon 3단계 방법론)

```
[Human-Driven Stages - SPARK Cannot Help]

핵심정의 (Core Definition)
  = Amazon 1단계: Identify Use Cases
  = "무엇을" (What) & "왜" (Why)
    ↓
구현방법 (Implementation Approach)
  = Amazon 2단계: Specify Concrete Requirements
  = "어떻게" (How)
  = 5단계 프로세스:
    1. 기능 분해
    2. 속성 질문 ⭐ (성능/품질/환경)
    3. 제약조건 파악
    4. 기술 옵션 탐색 (옵션 3개 비교)
    5. 통합 설계 (아키텍처, Schema, API)
    ↓
ADR (Architecture Decision Records) ← 여기!
  = Amazon 3단계: Select Tools & Infrastructure
  = "무엇을 선택" (Which) & "왜" (Why)
  = 구현방법의 탐색 과정을 **기록**
    ↓
Blueprint (구체적 설계)
  = 최종 구현 청사진

----------------------------------------------------------← SPARK STARTS HERE
[SPARK-Enabled Stages - Systematic Enforcement]
Standards → Task Breakdown → Checklists → Implementation
```

**중요한 순서**:
```
❌ 잘못된 순서: 핵심정의 → ADR (기술 먼저)
   "채팅 필요" → "Redis 쓰자"
   → 왜? (근거 없음)

✅ 올바른 순서: 핵심정의 → 구현방법 → ADR
   "채팅 필요"
   → "500ms, 1000명 동시 접속" (속성 질문)
   → WebSocket vs Long Polling vs gRPC (옵션 비교)
   → "WebSocket 선택" (근거: 모든 NFR 충족)
   → ADR 작성 (결정 기록)
```

**ADR의 역할**:
- ❌ ADR은 SPARK가 자동으로 생성할 수 없음 (너무 많은 맥락, 판단 필요)
- ❌ ADR은 탐색 도구가 아님 (구현방법에서 탐색 완료)
- ✅ ADR은 구현방법의 탐색 결과를 **기록**
- ✅ ADR은 사람(Jason + 1호/2호)의 협업으로 작성
- ✅ ADR은 Standards 문서의 입력이 됨
- ✅ ADR의 Compliance는 Quality Gates로 연결됨

**핵심 원칙** (One Medical의 Double-Diamond):
> 제안(Proposal) → 결정(Decision) → ADR
>
> - 제안 = 구현방법의 기술 옵션 탐색
> - 결정 = 권장안 선택
> - ADR = 최종 결정 기록

### 1-3. 왜 ADR이 필요한가?

**Problem**: "가이드라인"은 AI가 무시하거나 잊어버림

```markdown
❌ "좋은 로깅 관행을 따르세요"
❌ "표준 도구를 사용하세요"
❌ "print()를 사용하지 마세요"
```

**Solution**: ADR + Compliance = 시스템 강제

```python
# ADR-015: structlog 사용 (Decision)
# Compliance:
if "print(" in code:
    BLOCK "❌ print() 금지. structlog 사용."

if "import logging" in code:
    BLOCK "❌ logging 모듈 금지. structlog 사용."
```

**핵심 인사이트**:
- ADR = 결정 문서 (What + Why)
- Standards = 실행 규칙 (How + Enforcement)
- Quality Gates = 자동 검증 (Blocking + Validation)

---


## 2. ADR의 5가지 유형

ADR은 결정의 성격에 따라 5가지 유형으로 분류됩니다:

### 2-1. Type 1: Structure (구조 결정)
**정의**: 시스템 조직 방식, 아키텍처 패턴에 대한 결정

**예시**:
- Clean Architecture 사용
- Microservices vs Monolith
- Domain-Driven Design 적용

**생성되는 Standards**: `10_architecture.md`, `11_dependencies.md`

### 2-2. Type 2: Nonfunctional Characteristics (품질 속성 결정)
**정의**: 성능, 확장성, 보안, 테스트 커버리지 등 품질 요구사항

**예시**:
- 테스트 커버리지 95% 이상 필수
- API 응답 시간 200ms 이하
- 모든 API는 rate limiting 적용

**생성되는 Standards**: `05_testing.md`, `09_performance.md`, `08_security.md`

### 2-3. Type 3: Dependency (의존성 결정)
**정의**: 외부 라이브러리, 프레임워크, 서비스 선택

**예시**:
- structlog 사용 (logging 대신)
- FastAPI 사용 (Flask 대신)
- PostgreSQL 사용 (MySQL 대신)

**생성되는 Standards**: `01_logging.md`, `07_api.md`, `06_database.md`

### 2-4. Type 4: Interface (인터페이스 결정)
**정의**: API 설계, 모듈 간 계약, 외부 연동 방식

**예시**:
- RESTful API with OpenAPI
- GraphQL vs REST
- gRPC for microservices

**생성되는 Standards**: `07_api.md`, `12_events.md`

### 2-5. Type 5: Construction Technique (구현 기법 결정)
**정의**: 코드 작성 방식, 패턴, 기법

**예시**:
- Pydantic for all DTOs
- async/await for I/O operations
- Repository pattern for database

**생성되는 Standards**: `04_type_hints.md`, `06_database.md`, `09_performance.md`

---

**상세 설명**: 각 유형의 완전한 예시 ADR과 Compliance 전략은 `03M-01_adr_types_manual.md` 참고

---

## 3. ADR 7개 섹션 템플릿

Jason의 ADR 템플릿은 Michael Nygard의 기본 템플릿에 **Compliance**와 **Notes** 섹션을 추가한 확장 버전입니다.

### 3-1. 기본 구조

```markdown
# ADR-XXX: [간결한 제목]

## 1. Title
ADR 번호와 명확한 제목

## 2. Date
작성일 (YYYY-MM-DD)

## 3. Status
Proposed | Accepted | Rejected | Deprecated | Superseded

## 4. Context
이 결정을 내리게 된 배경, 문제, 제약사항

## 5. Decision
우리가 선택한 것, 구체적인 규칙/패턴

## 6. Consequences
이 결정으로 인해 더 쉬워지는 것 / 더 어려워지는 것

## 7. Compliance (Jason's Extension)
이 결정이 실제로 지켜지도록 하는 검증 메커니즘
- Automated: 자동 검증 (CI, pre-commit, Quality Gates)
- Semi-automated: 반자동 검증 (체크리스트, contract testing)
- Manual: 수동 검증 (architecture review, 코드 리뷰)

## 8. Notes (Jason's Extension)
추가 참고사항, 마이그레이션 가이드, 관련 문서
```

### 3-2. 각 섹션 작성 가이드

#### Section 1-2: Title + Date

**Format**:
```markdown
# ADR-015: Use structlog for Structured Logging

**Date**: 2025-01-15
**Status**: Accepted
```

**Guidelines**:
- 번호: 3자리 (ADR-001, ADR-015, ADR-123)
- 제목: 명령문 형태 ("Use X", "Apply Y", "Adopt Z")
- 간결하게 (5-10 단어)

#### Section 3: Status

**5가지 상태**:

1. **Proposed**: 제안됨, 아직 결정 안 됨
   - Standards 생성 ❌
   - 참고용으로만 보관

2. **Accepted**: 승인됨, 적용 시작
   - Standards 생성 ✅
   - Compliance 메커니즘 적용

3. **Rejected**: 거부됨
   - Standards 생성 ❌
   - 왜 거부했는지 Notes에 기록

4. **Deprecated**: 더 이상 사용 안 함
   - Standards에 "Deprecated" 표시
   - 마이그레이션 가이드 제공

5. **Superseded**: 다른 ADR로 대체됨
   - `Superseded by ADR-045` 표시
   - Standards 업데이트 (Before/After 표시)

#### Section 4: Context

**무엇을 작성하나**:
- 현재 문제점
- 제약사항 (기술, 비용, 시간)
- 대안 검토 결과

**Good Example**:
```markdown
## Context
현재 로깅 문제점:
1. print() 디버깅이 프로덕션에 남아있음
2. logging.info(f"...") → 문자열 포맷, ELK 파싱 불가
3. Request ID correlation 불가 → 분산 추적 어려움

제약사항:
- ELK stack 이미 구축됨 (JSON 로그 필요)
- 기존 코드 500+ print() 존재 (마이그레이션 필요)

검토한 대안:
1. 표준 logging + formatter → ELK 연동 가능하나 Request ID binding 어려움
2. structlog → ELK 연동 + Request ID binding 모두 가능
3. loguru → 좋지만 structlog보다 생태계 작음
```

**Bad Example** (너무 짧음):
```markdown
## Context
로깅이 필요함.
```

#### Section 5: Decision

**무엇을 작성하나**:
- 구체적인 선택 (라이브러리 이름, 버전, 패턴)
- 적용 범위
- 금지 사항

**Good Example**:
```markdown
## Decision
**모든 로깅은 structlog 사용, print()와 logging 모듈 금지.**

설정:
- JSON output (프로덕션)
- Pretty printing (개발)
- Auto-binding: request_id, user_id

패턴:
```python
from structlog import get_logger
logger = get_logger()
logger.info("event_name", key=value)
```

금지:
- ❌ print()
- ❌ import logging
- ❌ logger.info(f"...") (문자열 포맷)
```

**Bad Example** (추상적):
```markdown
## Decision
좋은 로깅 도구를 사용한다.
```

#### Section 6: Consequences

**무엇을 작성하나**:
- ✅ 더 쉬워지는 것 (benefits)
- ❌ 더 어려워지는 것 (trade-offs)

**Good Example**:
```markdown
## Consequences

✅ **Easier**:
- 로그 분석: ELK stack에서 `user_id:123` 필터링
- 프로덕션 디버깅: Request ID로 전체 흐름 추적
- 성능 측정: duration 자동 기록

❌ **Harder**:
- 초기 설정: structlog 설정 파일 작성
- 팀 교육: 1-2주 학습 곡선
- 마이그레이션: 500+ print() 제거 (4주 소요 예상)
```

**Key Point**: 장점만 나열하지 말고, trade-off를 정직하게 기록!

#### Section 7: Compliance (핵심 섹션!)

**무엇을 작성하나**:
- 이 결정이 실제로 지켜지도록 하는 **시스템 강제 메커니즘**
- 3가지 수준: Automated, Semi-automated, Manual

**Compliance 3가지 수준**:

1. **Automated** (자동 검증, 차단):
   - pre-commit hook으로 print() 차단
   - CI에서 ruff/mypy 실행 (실패 시 merge 불가)
   - Quality Gates (Phase 5B) blocking

2. **Semi-automated** (반자동 검증):
   - PR 체크리스트 (사람이 확인, 도구 지원)
   - Contract testing (Pact)
   - OpenAPI schema diff

3. **Manual** (수동 검증):
   - Architecture review
   - 코드 리뷰 (복잡한 패턴)
   - 주기적 감사

**Good Example** (3가지 수준 모두 포함):
```markdown
## Compliance

1. **Automated**: pre-commit hook
   ```python
   # .pre-commit-config.yaml
   - repo: local
     hooks:
       - id: no-print
         name: Detect print()
         entry: python scripts/check_no_print.py
         language: python
         types: [python]

   # scripts/check_no_print.py
   if "print(" in content:
       sys.exit("❌ print() 금지. logger.info() 사용.")
   ```

2. **Automated**: ruff T201
   ```toml
   [tool.ruff]
   select = ["T201"]  # Detect print()
   ```

3. **Automated**: Quality Gates (Phase 5B)
   ```python
   # ~/.claude/hooks/spark_quality_gates.py
   ruff_result = subprocess.run(["ruff", "check", "."])
   if ruff_result.returncode != 0:
       return "🚫 Quality gates FAILED"
   ```

4. **Semi-automated**: PR 체크리스트
   - [ ] 모든 print()가 logger.info()로 변경되었나?
   - [ ] structlog import가 사용되었나?

5. **Manual**: 코드 리뷰
   - 복잡한 로깅 로직 리뷰
   - 민감 정보 로깅 여부 확인
```

**Bad Example** (검증 방법 없음):
```markdown
## Compliance
개발자들이 이 규칙을 따를 것으로 기대한다.
```

**Key Insight**:
- **Compliance 섹션 = ADR과 Quality Gates의 연결고리**
- Compliance에 명시된 것 = Standards로 변환됨
- Compliance 없는 ADR = 그냥 "가이드라인" (무시됨)

#### Section 8: Notes

**무엇을 작성하나**:
- 마이그레이션 가이드 링크
- 관련 문서, 참고자료
- 팀 교육 계획
- 예외 사항

**Example**:
```markdown
## Notes

**마이그레이션**:
- 가이드: `docs/logging-migration.md`
- 일정: 4주 (Week 3-6)
- 우선순위: 프로덕션 코드 먼저, 테스트 코드 나중

**교육**:
- Week 3: structlog 기본 세션 (2시간)
- Week 4: ELK 연동 세션 (1시간)

**참고자료**:
- structlog docs: https://www.structlog.org/
- ELK integration: `docs/elk-integration.md`

**예외**:
- CLI 스크립트의 사용자 출력: print() 허용
- 마이그레이션 스크립트: 일회성이므로 예외
```

---

## 4. 좋은 ADR 작성하기

### 4-1. Good ADR의 특징

✅ **구체적**: "좋은 로깅" ❌ → "structlog 사용" ✅
✅ **검증 가능**: Compliance 섹션에 자동 검증 방법
✅ **실행 가능**: Standards로 변환 가능
✅ **정직함**: Trade-off를 숨기지 않음

### 4-2. Bad ADR 예시

```markdown
# ADR-010: Use Good Coding Practices

**Date**: 2025-01-10
**Status**: Accepted

## Context
We need to write good code.

## Decision
We will follow good coding practices.

## Consequences
Code will be better.

## Compliance
Developers will follow the guidelines.
```

**문제점**:
1. ❌ "Good coding practices" - 추상적, 측정 불가
2. ❌ Context가 문제를 설명하지 않음
3. ❌ Decision이 구체적 액션이 아님
4. ❌ Consequences가 trade-off를 보여주지 않음
5. ❌ Compliance에 검증 방법 없음 (그냥 "기대")

**Result**: Standards로 변환 불가능, 그냥 무시됨

### 4-3. Good ADR 예시

```markdown
# ADR-020: Enforce Domain → Infrastructure Dependency Rule

**Date**: 2025-01-20
**Status**: Accepted

## Context
현재 Domain 계층이 Infrastructure를 직접 import:
```python
# src/domain/user.py (문제!)
from src.infrastructure.database import UserRepository  # ❌

class User:
    def save(self):
        repo = UserRepository()
        repo.save(self)
```

문제점:
- Domain 로직 테스트 시 DB 필요 (느림, 복잡)
- Infrastructure 변경 시 Domain 수정 (결합도 높음)
- Clean Architecture 위반

## Decision
**Domain은 Infrastructure를 절대 import 금지.**

대신:
1. Domain에서 Interface(Protocol) 정의
2. Infrastructure에서 Interface 구현
3. Use Case에서 의존성 주입

```python
# src/domain/user.py (수정)
from typing import Protocol

class UserRepositoryProtocol(Protocol):
    def save(self, user: "User") -> None: ...

class User:
    def save(self, repo: UserRepositoryProtocol):
        repo.save(self)

# src/infrastructure/database/user_repository.py
from src.domain.user import UserRepositoryProtocol

class UserRepository(UserRepositoryProtocol):
    def save(self, user: User) -> None:
        # DB 저장 로직
```

## Consequences

✅ **Easier**:
- Domain 단위 테스트 (Mock repository 사용)
- Infrastructure 교체 (PostgreSQL → MongoDB)
- 여러 구현 공존 (MemoryRepository, FileRepository)

❌ **Harder**:
- 초기 설정: Protocol 정의, DI 설정
- 파일 개수 증가 (interface + implementation)
- 팀 교육: Protocol, DI 개념

## Compliance

1. **Automated**: import-linter
   ```toml
   # pyproject.toml
   [[tool.importlinter.contracts]]
   name = "Domain은 Infrastructure import 금지"
   type = "forbidden"
   source_modules = ["src.domain"]
   forbidden_modules = ["src.infrastructure"]
   ```

2. **Automated**: pre-commit hook
   ```yaml
   # .pre-commit-config.yaml
   - repo: https://github.com/seddonym/import-linter
     hooks:
       - id: import-linter
   ```

3. **Automated**: CI pipeline
   ```yaml
   # .github/workflows/ci.yml
   - name: Check Dependencies
     run: lint-imports
   ```

4. **Semi-automated**: PR 체크리스트
   - [ ] Domain 코드에 Infrastructure import 없는가?
   - [ ] Protocol이 올바르게 정의되었는가?

5. **Manual**: Architecture review (주 1회)
   - 복잡한 의존성 패턴 검토

## Notes

**마이그레이션**:
- 가이드: `docs/architecture/dependency-injection.md`
- 일정: 6주 (Week 4-9)
- 우선순위: User, Auth 모듈 먼저

**교육**:
- Week 4: Clean Architecture 세션
- Week 5: Protocol과 DI 세션
- Week 6: Hands-on workshop

**참고자료**:
- Uncle Bob's Clean Architecture
- import-linter docs: https://import-linter.readthedocs.io/

**예외 없음**: 모든 Domain 코드에 적용
```

**왜 Good인가**:
1. ✅ Context가 구체적 코드 예시로 문제 설명
2. ✅ Decision이 Before/After 코드로 명확
3. ✅ Consequences가 정직한 trade-off
4. ✅ Compliance에 5가지 검증 메커니즘 (자동 3개, 반자동 1개, 수동 1개)
5. ✅ Notes에 마이그레이션 계획, 교육 일정

**Result**: Standards/10_architecture.md Section 2로 변환 가능!

### 4-4. Compliance 작성 전략

**원칙**: Automated > Semi-automated > Manual 순서로 선호

**Step 1: Automated부터 찾기**
- 이 규칙을 자동으로 검증할 도구가 있나?
  - Linter (ruff, pylint)
  - Type checker (mypy)
  - Import checker (import-linter)
  - Security scanner (bandit)
  - Coverage tool (pytest-cov)

**Step 2: Pre-commit hook 추가**
- 자동 도구를 pre-commit에 연결
- 위반 시 commit 차단

**Step 3: CI pipeline 추가**
- Pre-commit 통과해도 CI에서 재검증
- Merge 전 마지막 방어선

**Step 4: Quality Gates 연결**
- Phase 5B에서 최종 검증
- `spark_quality_gates.py`에서 blocking

**Step 5: Semi-automated 추가**
- 자동화 어려운 부분 → 체크리스트
- PR template에 포함

**Step 6: Manual 최소화**
- 정말 사람 판단 필요한 것만
- 주기적 리뷰 (주 1회, 월 1회)

**예시 적용**:
```markdown
ADR-015: structlog 사용

Compliance:
1. ✅ Automated: ruff T201 (print 검출)
2. ✅ Automated: pre-commit hook (import logging 차단)
3. ✅ Automated: CI (ruff 실행)
4. ✅ Automated: Quality Gates (Phase 5B)
5. ⚠️ Semi-automated: PR 체크리스트 (logger.info 형식 확인)
6. ⚠️ Manual: 민감 정보 로깅 여부 리뷰 (주 1회)

→ 자동 4개, 반자동 1개, 수동 1개 = 균형!
```

---


## 5. ADR → Standards 변환 프로세스

ADR 작성 후 Standards 문서로 변환하여 Quality Gates에 연결합니다.

### 5-1. 변환 원칙

**ADR vs Standards 차이**:

| 측면 | ADR | Standards |
|------|-----|-----------|
| 목적 | 결정 기록 | 실행 가이드 |
| 내용 | What + Why | How + Enforcement |
| 형식 | Decision + Context | Rules + Examples |
| 독자 | 의사결정자 | 개발자 (Agent) |
| 변경 | 불변 (Superseded) | 업데이트 가능 |

**변환 원칙**:
1. ADR Decision → Standard Rules
2. ADR Compliance → Standard Enforcement
3. ADR Consequences (harder) → Standard Common Mistakes
4. ADR 예시 코드 → Standard Good/Bad Examples

### 5-2. 변환 절차

**Step 1**: ADR Decision → Standard Sections
- Decision 내용을 규칙으로 변환
- 패턴, 금지사항을 명시

**Step 2**: ADR Compliance → Standard Enforcement
- Automated: pre-commit hook, CI, Quality Gates
- Semi-automated: PR 체크리스트
- Manual: Architecture review

**Step 3**: ADR Consequences → Standard Common Mistakes
- "Harder" 항목을 실수 사례로 변환
- Before/After 예시 제공

**Step 4**: Standards 파일 완성
- 150줄 내외
- 5개 섹션: Import, Pattern, Context, Mistakes, Enforcement

---

**상세 프로세스**: 완전한 변환 예시(structlog, API, Testing)는 `03M-02_adr_to_standards_manual.md` 참고

---

## 6. ADR 생명주기 관리

### 6-1. Status 변경 흐름

```
Proposed → Accepted → Deprecated/Superseded
    ↓           ↓              ↓
  보관        Standards    Standards
  (참고)        생성          업데이트
```

### 6-2. Proposed → Accepted

**Trigger**: 팀 회의에서 승인

**Actions**:
1. ADR status 변경: `Proposed` → `Accepted`
2. Standards 생성:
   - ADR Decision → Standards rules
   - ADR Compliance → Standards enforcement
3. `00_index.md` 업데이트:
   ```markdown
   ## Standards 출처
   - 01_logging.md ← ADR-015
   - 05_testing.md Section 4 ← ADR-010
   ```

**Example**:
```markdown
# ADR-015 변경
- **Status**: Proposed ~~Accepted~~
+ **Status**: Accepted
  **Date Accepted**: 2025-01-15
```

### 6-3. Accepted → Deprecated

**Trigger**: 더 이상 사용하지 않기로 결정

**Actions**:
1. ADR status 변경: `Accepted` → `Deprecated`
2. Standards에 Deprecated 표시:
   ```markdown
   # 01. Logging Standards

   > **⚠️ DEPRECATED**: 이 표준은 deprecated됩니다.
   > **Deprecated Date**: 2025-06-01
   > **Reason**: ADR-015 deprecated (ADR-045로 대체)
   > **Migration**: docs/migration/logging-v2.md
   ```
3. 마이그레이션 가이드 작성

**Example**:
```markdown
# ADR-015 변경 (structlog → 다른 도구로 변경)
  **Status**: Accepted ~~Deprecated~~
+ **Status**: Deprecated
+ **Deprecated Date**: 2025-06-01
+ **Reason**: Performance issues in production
```

**Standards 변경**:
```markdown
# 01. Logging Standards

> **⚠️ DEPRECATED**: 2025-06-01
> **출처**: ADR-015 (Deprecated)
> **대체**: ADR-045 (New logging solution)
> **마이그레이션**: docs/migration/logging-v2.md

[기존 내용은 남겨둠 - 레거시 코드 참고용]
```

### 6-4. Accepted → Superseded

**Trigger**: 더 나은 방법으로 대체

**Actions**:
1. 새 ADR 작성 (ADR-045)
2. 구 ADR status 변경: `Accepted` → `Superseded by ADR-045`
3. Standards 업데이트:
   - Before/After 섹션 추가
   - 마이그레이션 가이드 추가

**Example**:

**ADR-015 변경**:
```markdown
# ADR-015: Use structlog for Logging

- **Status**: Accepted ~~Superseded by ADR-045~~
+ **Status**: Superseded by ADR-045
+ **Superseded Date**: 2025-06-01
```

**ADR-045 작성** (새 ADR):
```markdown
# ADR-045: Use Python logging with JSON Formatter

**Status**: Accepted
**Date**: 2025-06-01
**Supersedes**: ADR-015

## Context
structlog 성능 문제 (대용량 로그 처리 시 병목):
- 초당 10K+ events → 50% CPU 사용
- GIL 경합 (Python logging은 C로 구현)

## Decision
표준 logging 모듈 + JSON formatter 사용.
[...]
```

**Standards 업데이트** (01_logging.md):
```markdown
# 01. Logging Standards

> **출처**: ADR-045 (Python logging + JSON)
> **이전**: ADR-015 (structlog) - Superseded 2025-06-01

## Before/After (Migration Guide)

**Before** (ADR-015, structlog):
```python
from structlog import get_logger
logger = get_logger()
logger.info("user_login", user_id=user.id)
```

**After** (ADR-045, logging + JSON):
```python
import logging
from pythonjsonlogger import jsonlogger

logger = logging.getLogger(__name__)
logger.info("user_login", extra={"user_id": user.id})
```

**마이그레이션**: docs/migration/structlog-to-logging.md

---

## 1. Import and Setup (Line 1-30) ← UPDATED!

**Mandatory Import**:
```python
import logging
from pythonjsonlogger import jsonlogger

logger = logging.getLogger(__name__)
```

[나머지 업데이트된 내용...]
```

### 6-5. Rejected ADR

**Trigger**: 제안이 거부됨

**Actions**:
1. ADR status 변경: `Proposed` → `Rejected`
2. Notes에 거부 이유 상세 기록
3. Standards 생성 ❌ (거부되었으므로)

**Example**:
```markdown
# ADR-018: Use loguru for Logging

**Status**: Rejected
**Date Proposed**: 2025-01-10
**Date Rejected**: 2025-01-15

## Context
structlog 대안으로 loguru 검토.

## Decision
loguru 사용 제안.

## Why Rejected
1. 생태계가 작음 (structlog 대비)
2. 팀이 이미 structlog 학습 완료
3. 마이그레이션 비용이 이득보다 큼

## Notes
- 논의 내용: `docs/meetings/2025-01-15-logging.md`
- 대신 ADR-015 (structlog) 승인
```

---

## 7. 다음 단계 연결

### 7-1. 문서 흐름에서 ADR의 위치

```
ADR_GUIDE.md (이 문서)
    ↓ 작성 방법 학습
Individual ADR documents (ADR-001, ADR-015, ...)
    ↓ Accepted ADRs
PROJECT_STANDARDS_GUIDE.md ← 다음 단계!
    ↓ 변환 방법 학습
PROJECT_STANDARDS/ directory (01_logging.md, 07_api.md, ...)
    ↓ 적용
BLUEPRINT_GUIDE.md
    ↓
TASK_BREAKDOWN_GUIDE.md
    ↓
CHECKLIST_GUIDE.md
```

### 7-2. 다음 단계: PROJECT_STANDARDS_GUIDE.md

**다음 가이드에서 배울 내용**:
1. Standards 파일 구조 (5개 섹션, Line 범위)
2. Mandatory 5 standards vs Optional standards
3. 파일 분리 전략 (150-200 lines per file)
4. Progressive accumulation (프로젝트 초기 vs 중후반)
5. ADR → Standards 상세 변환 절차
6. Standards → Blueprint 연결

**지금 ADR_GUIDE.md에서 배운 것**:
- ✅ ADR 5가지 유형
- ✅ ADR 7개 섹션 (특히 Compliance!)
- ✅ Good vs Bad ADR
- ✅ ADR → Standards 변환 개념

**다음 가이드로 이동**: `PROJECT_STANDARDS_GUIDE.md`

---

## 부록: Quick Reference

### ADR 템플릿 (Copy-Paste)

```markdown
# ADR-XXX: [Title]

**Date**: YYYY-MM-DD
**Status**: Proposed

## Context
[현재 문제점, 제약사항, 검토한 대안]

## Decision
[구체적인 선택, 적용 범위, 금지 사항]

## Consequences
✅ **Easier**:
- [이점 1]
- [이점 2]

❌ **Harder**:
- [Trade-off 1]
- [Trade-off 2]

## Compliance
1. **Automated**: [도구, hook, CI]
2. **Semi-automated**: [체크리스트, contract test]
3. **Manual**: [리뷰, 감사]

## Notes
[마이그레이션 가이드, 교육 계획, 참고자료, 예외사항]
```

### Compliance 체크리스트

작성한 ADR의 Compliance 섹션을 검증:

- [ ] Automated 검증이 최소 1개 이상 있는가?
- [ ] Pre-commit hook에 연결되어 있는가?
- [ ] CI pipeline에서 검증하는가?
- [ ] Quality Gates (Phase 5B)와 연결되어 있는가?
- [ ] Semi-automated 체크리스트가 구체적인가?
- [ ] Manual 검증의 주기가 명시되어 있는가?

**모두 ✅면 좋은 ADR!**

---

**이 가이드 완료!** 다음: `PROJECT_STANDARDS_GUIDE.md`


================================================================================
# End of 03G-00_adr_guide.md
================================================================================



================================================================================
# 📄 4. 04G-00_dna_planning_guide.md
================================================================================

# Stage 4: DNA 시스템 계획 가이드

> **목적**: 11개 DNA 시스템 구축을 위한 청사진, 작업 분해, 체크리스트 작성
> **버전**: v1.0 (2025-11-13)
> **소요 시간**: 2-4시간

---

## 🎯 이 Stage의 목표

**DNA 시스템 구축을 위한 완전한 계획 수립**

- DNA 청사진: 11개 시스템의 파일 구조와 인터페이스
- DNA 작업 분해: 구체적인 하위 작업 목록
- DNA 체크리스트: 통합 체크리스트 1개

---

## 🧬 DNA 시스템이란?

**DNA 시스템 = 모든 소프트웨어의 기본 설계도**

생명의 DNA가 모든 생물의 기초이듯, 11개 DNA 시스템은 모든 소프트웨어 프로젝트의 기초입니다.

### 특징
- ✅ 언어, 프레임워크, 도메인 무관
- ✅ 11개 모두 필수 (선택 없음)
- ✅ 자동 강제 (지키지 않으면 빌드/실행 실패)
- ✅ 일관성 필수 (한 곳만 다르면 전체 혼란)

### 왜 필요한가?
```
❌ 문서로 알려주기 → AI가 안 읽음/잊어버림
❌ 체크리스트 작성 → AI가 안 지킴
❌ 지시/설명 반복 → 매 세션마다 반복

✅ 해결: "환경"을 만들어서 잘못할 수 없게!
```

### 11개 DNA 시스템 목록

**기반 DNA (1-6)** - 코드 작성 전 필수:
1. Type System (타입 체커)
2. Observability System (로깅/메트릭/추적)
3. Testing System (테스트 프레임워크)
4. Code Quality System (포맷터/린터)
5. Architecture Enforcement (Layer 경계)
6. Configuration System (환경 변수 + 의존성)

**도메인 DNA (7-11)** - 기능 구현과 함께:
7. Error Handling System (Result/Either)
8. Performance System (벤치마크/프로파일링)
9. API System (인터페이스)
10. Data System (저장/조회)
11. Security System (인증/암호화)

---

## 📥 입력 문서 (Stage 3에서 받은 것)

### 필수
- **`03A-001~011_*.md`** (DNA 시스템 ADR 11개)
  - 각 DNA 시스템별 기술 선택 결정
  - 예: 03A-001_type_system.md (mypy vs TypeScript strict)
  - 예: 03A-002_observability.md (structlog vs winston)

### 참조
- **`DNA_Systems_11_Complete_Guide.md`**
  - 11개 DNA 시스템 상세 설명
  - Kent Beck 검증 사례
  - 체크리스트 템플릿

---

## 📋 작업 단계

### Step 1: DNA 청사진 작성 (1-2시간)

#### 1.1 디렉토리 구조 설계

**목표**: src/core/ 디렉토리 구조 결정

**작업**:
```markdown
# 04D-01_dna_blueprint.md 예시

## 디렉토리 구조

```
src/
├── core/                  # DNA 시스템 공통 모듈
│   ├── __init__.py
│   ├── logger.py         # Observability (DNA 2)
│   ├── error.py          # Error Handling (DNA 7)
│   ├── config.py         # Configuration (DNA 6)
│   └── types.py          # Type definitions (DNA 1)
├── api/                  # API System (DNA 9)
│   ├── __init__.py
│   └── routes.py
├── database/             # Data System (DNA 10)
│   ├── __init__.py
│   └── models.py
└── security/             # Security System (DNA 11)
    ├── __init__.py
    └── auth.py

tests/
├── core/                 # DNA 시스템 테스트
│   ├── test_logger.py
│   ├── test_error.py
│   └── test_config.py
└── integration/

benchmarks/               # Performance (DNA 8)
├── benchmark_core.py
└── profiles/

pyproject.toml            # Configuration + Type + Testing + Quality (DNA 1,3,4,6)
.pre-commit-config.yaml   # Code Quality (DNA 4)
mypy.ini                  # Type System (DNA 1)
ruff.toml                 # Code Quality (DNA 4)
```
```

#### 1.2 각 DNA 시스템별 파일 목록

**목표**: 11개 DNA 각각 어떤 파일을 만들지 명시

**작업**:
```markdown
### DNA 1: Type System
- [ ] pyproject.toml에 mypy 설정
- [ ] mypy.ini 파일 생성
- [ ] src/core/types.py (공통 타입 정의)

### DNA 2: Observability System
- [ ] src/core/logger.py
  - get_logger() 함수
  - trace_id 전파 로직
  - 구조화된 로깅 설정
- [ ] tests/core/test_logger.py

### DNA 3: Testing System
- [ ] pyproject.toml에 pytest 설정
- [ ] tests/conftest.py (공통 fixture)
- [ ] tests/core/ 구조

... (11개 모두 명시)
```

#### 1.3 인터페이스 설계

**목표**: 각 DNA 시스템의 공개 API 정의

**작업**:
```markdown
## DNA 시스템 공개 인터페이스

### Observability (logger.py)
```python
from src.core.logger import get_logger

logger = get_logger(__name__)
logger.info("message", extra={"user_id": 123})
```

### Error Handling (error.py)
```python
from src.core.error import AppError, Result

def process() -> Result[Data, AppError]:
    return Ok(data) or Err(error)
```

### Configuration (config.py)
```python
from src.core.config import config

db_url = config.DATABASE_URL
api_key = config.API_KEY
```

... (11개 모두 명시)
```

---

### Step 2: DNA 작업 분해 (30분-1시간)

#### 2.1 11개 DNA → 하위 작업 분해

**목표**: 각 DNA 시스템을 구체적인 작업으로 분해

**작업**:
```markdown
# 04T-01_dna_tasks.md 예시

## DNA 작업 분해

### DNA 1: Type System (3개 하위 작업)
1. pyproject.toml에 mypy 의존성 추가
2. mypy.ini 설정 파일 작성 (strict mode)
3. src/core/types.py 공통 타입 정의

### DNA 2: Observability System (5개 하위 작업)
1. structlog 의존성 추가
2. src/core/logger.py 기본 구조 작성
3. get_logger() 함수 구현
4. trace_id 전파 로직 구현
5. tests/core/test_logger.py 작성

... (11개 DNA → 총 30-50개 하위 작업)
```

#### 2.2 우선순위 결정

**목표**: 기반 DNA 6개 → 도메인 DNA 5개 순서 확정

**작업**:
```markdown
## 우선순위

### Phase 1: 기반 DNA (1-6) - 먼저 구축
- DNA 1: Type System
- DNA 2: Observability System
- DNA 3: Testing System
- DNA 4: Code Quality System
- DNA 5: Architecture Enforcement
- DNA 6: Configuration System

→ 이 6개가 완성되면 개발 환경 완성!

### Phase 2: 도메인 DNA (7-11) - 기능과 함께
- DNA 7: Error Handling System
- DNA 8: Performance System
- DNA 9: API System
- DNA 10: Data System
- DNA 11: Security System
```

#### 2.3 의존성 파악

**목표**: 작업 간 의존 관계 명시

**작업**:
```markdown
## 의존성

- Testing (DNA 3) → Type (DNA 1) 필요
  - 이유: 테스트에서 타입 체크 필요

- Observability (DNA 2) → Configuration (DNA 6) 필요
  - 이유: 로그 레벨 설정 필요

- Error Handling (DNA 7) → Type (DNA 1) 필요
  - 이유: Result<T, E> 타입 정의
```

---

### Step 3: DNA 체크리스트 작성 (30분)

#### 3.1 통합 체크리스트 작성

**목표**: 1개 파일로 11개 DNA 전체 관리

**작업**:
```markdown
# 04L-01_dna_checklist.md

## DNA 시스템 11개 구축 체크리스트

### [ ] DNA 1: Type System
  - [ ] pyproject.toml에 mypy 추가
    ```bash
    uv add --dev mypy
    ```
  - [ ] mypy.ini 작성 (strict mode)
    ```ini
    [mypy]
    strict = True
    warn_return_any = True
    ```
  - [ ] src/core/types.py 작성
  - [ ] mypy 실행 확인
    ```bash
    mypy src/
    ```

### [ ] DNA 2: Observability System
  - [ ] structlog 추가
    ```bash
    uv add structlog
    ```
  - [ ] src/core/logger.py 작성
  - [ ] get_logger() 구현
  - [ ] trace_id 전파 구현
  - [ ] tests/core/test_logger.py 작성
  - [ ] 테스트 실행
    ```bash
    pytest tests/core/test_logger.py
    ```

... (11개 DNA 모두)

### [ ] 전체 검증
  - [ ] 모든 DNA 시스템 동작 확인
  - [ ] 테스트 커버리지 95%+ 확인
  - [ ] ruff/mypy 0 violations 확인
```

**핵심**:
- ✅ 1개 파일로 전체 진행 상황 확인
- ✅ 11개 섹션 (DNA별)
- ✅ 하위 작업은 체크박스로
- ✅ 실행 명령어 포함 (복붙 가능)

---

## 📤 출력 문서 (이 Stage에서 생성해야 할 문서)

### 1. **`04D-01_dna_blueprint.md`** (DNA 청사진)

**내용**:
- 전체 디렉토리 구조
- 각 DNA 시스템별 파일 목록
- 공개 인터페이스 (사용 예시 포함)
- 설정 파일 구조

**예시 구조**:
```markdown
# DNA 시스템 청사진

## 1. 디렉토리 구조
[전체 tree 구조]

## 2. DNA 시스템별 파일
### DNA 1: Type System
[파일 목록]

### DNA 2: Observability System
[파일 목록]

... (11개)

## 3. 공개 인터페이스
### Observability
[코드 예시]

### Error Handling
[코드 예시]

... (11개)

## 4. 설정 파일
### pyproject.toml
[내용]

### mypy.ini
[내용]
```

---

### 2. **`04T-01_dna_tasks.md`** (DNA 작업 분해)

**내용**:
- 11개 DNA → 30-50개 하위 작업
- 우선순위 (Phase 1/2)
- 의존성

**예시 구조**:
```markdown
# DNA 작업 분해

## 전체 작업 개요
- 총 작업 수: 42개
- Phase 1 (기반 DNA): 24개
- Phase 2 (도메인 DNA): 18개

## Phase 1: 기반 DNA (1-6)

### DNA 1: Type System
1. [작업 1]
2. [작업 2]
...

### DNA 2: Observability System
...

## Phase 2: 도메인 DNA (7-11)
...

## 의존성 그래프
[의존 관계 명시]
```

---

### 3. **`04L-01_dna_checklist.md`** (DNA 체크리스트)

**내용**:
- 통합 체크리스트 1개
- 11개 섹션 (DNA별)
- 실행 가능한 명령어 포함

**예시 구조**:
```markdown
# DNA 시스템 구축 체크리스트

## 진행 상황
- [ ] Phase 1: 기반 DNA (0/6)
- [ ] Phase 2: 도메인 DNA (0/5)
- [ ] 전체 검증 (0/3)

## DNA 시스템 구축

### [ ] DNA 1: Type System
  - [ ] [하위 작업 1]
    ```bash
    [실행 명령어]
    ```
  - [ ] [하위 작업 2]
  ...

### [ ] DNA 2: Observability System
...

## 전체 검증
- [ ] 모든 DNA 동작 확인
- [ ] 테스트 커버리지 95%+
- [ ] 품질 검사 0 violations
```

---

## 🔄 다음 Stage로 전달되는 것

**Stage 4 → Stage 5**:
- ✅ DNA 청사진 (04D-01) → 파일 구조와 인터페이스 설계
- ✅ DNA 작업 분해 (04T-01) → 구체적인 작업 목록
- ✅ DNA 체크리스트 (04L-01) → 실행 가능한 체크리스트

**Stage 5에서 사용**:
- 체크리스트 따라 실제 구현
- 청사진의 인터페이스 준수
- 작업 분해 순서대로 진행

---

## ⚠️ 주의사항

### 1. 언어별 차이 반영
- Python: pyproject.toml + uv
- TypeScript: package.json + pnpm
- Rust: Cargo.toml
- Go: go.mod

→ ADR에서 결정된 언어에 맞게 작성!

### 2. 체크리스트는 1개!
- ❌ DNA별로 11개 파일 만들지 말 것
- ✅ 1개 파일에 11개 섹션

### 3. 실행 가능한 명령어 필수
- 체크리스트에 복붙 가능한 명령어 포함
- 예: `uv add --dev mypy`, `pytest tests/`

### 4. Kent Beck 검증 목표
- 11개 중 10개 이상 달성 목표
- Observability는 최소화 가능 (라이브러리 특성상)

---

## 📚 참고 자료

### 필수
- `DNA_Systems_11_Complete_Guide.md` - 11개 DNA 상세 설명
- `03A-001~011_*.md` - DNA 시스템 ADR

### 참고
- Kent Beck BPlusTree 프로젝트 구조
- 다른 Stage 가이드 (입출력 형식 참조)

---

## ✅ 완료 기준

이 Stage는 다음 조건을 모두 만족하면 완료:

- [ ] **04D-01_dna_blueprint.md** 작성 완료
  - [ ] 디렉토리 구조 명시
  - [ ] 11개 DNA 파일 목록
  - [ ] 공개 인터페이스 정의

- [ ] **04T-01_dna_tasks.md** 작성 완료
  - [ ] 30-50개 하위 작업 분해
  - [ ] 우선순위 (Phase 1/2)
  - [ ] 의존성 명시

- [ ] **04L-01_dna_checklist.md** 작성 완료
  - [ ] 통합 체크리스트 1개
  - [ ] 11개 섹션
  - [ ] 실행 명령어 포함

- [ ] **검증**
  - [ ] 3개 문서 간 일관성 확인
  - [ ] ADR과 청사진 일치 확인
  - [ ] 파일명 규칙 준수 (04D-01, 04T-01, 04L-01)

---

**마지막 업데이트**: 2025-11-13
**다음 검토**: Stage 5 가이드 작성 시 연계성 확인


================================================================================
# End of 04G-00_dna_planning_guide.md
================================================================================



================================================================================
# 📄 5. 05G-00_dna_implementation_guide.md
================================================================================

# Stage 5: DNA 시스템 구축 가이드

> **목적**: 11개 DNA 시스템 실제 구현 및 검증
> **버전**: v1.0 (2025-11-13)
> **소요 시간**: 4-8시간

---

## 🎯 이 Stage의 목표

**11개 DNA 시스템 실제 구축 및 동작 검증**

- DNA 구현 표준 작성: 통일성 규칙 정의
- 실제 구현: 체크리스트 따라 파일/코드 작성
- 통합 검증: Kent Beck 수준 (10/11개) 달성

---

## 📥 입력 문서 (Stage 4에서 받은 것)

### 필수
- **`04D-01_dna_blueprint.md`** (DNA 청사진)
  - 디렉토리 구조
  - 각 DNA 시스템별 파일 목록
  - 공개 인터페이스

- **`04T-01_dna_tasks.md`** (DNA 작업 분해)
  - 30-50개 하위 작업
  - 우선순위 (Phase 1/2)
  - 의존성

- **`04L-01_dna_checklist.md`** (DNA 체크리스트)
  - 통합 체크리스트 1개
  - 11개 섹션
  - 실행 명령어

### 참조
- **`DNA_Systems_11_Complete_Guide.md`**
- **`03A-001~011_*.md`** (DNA 시스템 ADR)

---

## 📋 작업 단계

### Step 1: DNA 구현 표준 작성 (1-2시간)

#### 1.1 파일 구조 규칙

**목표**: src/core/ 구조 통일

**작업**:
```markdown
# 05S-01_dna_standards.md 예시

## 1. 파일 구조 규칙

### 디렉토리 구조
```
src/core/           # DNA 시스템 공통 모듈
├── __init__.py     # 공개 API export
├── logger.py       # Observability (DNA 2)
├── error.py        # Error Handling (DNA 7)
├── config.py       # Configuration (DNA 6)
└── types.py        # Type definitions (DNA 1)

tests/core/         # DNA 시스템 테스트
├── __init__.py
├── test_logger.py
├── test_error.py
└── test_config.py
```

### 파일 네이밍
- 모듈 파일: snake_case (logger.py, error.py)
- 테스트 파일: test_*.py
- 설정 파일: 도구별 표준 (pyproject.toml, mypy.ini)
```

#### 1.2 네이밍 규칙

**목표**: 코드 일관성 확보

**작업**:
```markdown
## 2. 네이밍 규칙

### 클래스
- PascalCase
- 예: `AppConfig`, `CustomError`, `LoggerConfig`

### 함수
- snake_case
- 동사로 시작
- 예: `get_logger()`, `handle_error()`, `load_config()`

### 상수
- UPPER_SNAKE_CASE
- 예: `LOG_LEVEL`, `MAX_RETRIES`, `DEFAULT_TIMEOUT`

### 변수
- snake_case
- 명확한 이름
- 예: `user_id`, `error_message`, `config_path`

### Private
- 앞에 언더스코어 1개
- 예: `_internal_method()`, `_cache`
```

#### 1.3 Import 규칙

**목표**: 명확한 의존성 관리

**작업**:
```markdown
## 3. Import 규칙

### DNA 시스템 Import
- DNA 시스템은 항상 `src.core`에서 import
- 절대 경로 사용

```python
# ✅ 올바른 방법
from src.core.logger import get_logger
from src.core.error import AppError
from src.core.config import config

# ❌ 잘못된 방법
from core.logger import get_logger  # 상대 경로
from ..core.logger import get_logger  # 상대 import
```

### Import 순서
1. 표준 라이브러리
2. 서드파티 라이브러리
3. 로컬 모듈

```python
# 표준 라이브러리
import os
from typing import Optional

# 서드파티
import structlog
from pydantic import BaseModel

# 로컬
from src.core.logger import get_logger
from src.core.config import config
```
```

#### 1.4 테스트 규칙

**목표**: 95%+ 커버리지 달성

**작업**:
```markdown
## 4. 테스트 규칙

### 테스트 파일 위치
- DNA 시스템: `tests/core/test_*.py`
- 각 모듈당 1개 테스트 파일
- 예: `src/core/logger.py` → `tests/core/test_logger.py`

### 테스트 함수 네이밍
- `test_` 접두사 필수
- 기능을 명확히 설명
- 예: `test_get_logger_returns_configured_logger()`

### 테스트 구조 (Given-When-Then)
```python
def test_get_logger_with_name():
    # Given
    logger_name = "test.module"

    # When
    logger = get_logger(logger_name)

    # Then
    assert logger.name == logger_name
    assert isinstance(logger, structlog.BoundLogger)
```

### 커버리지 목표
- 단위 테스트: 95%+ 필수
- 각 DNA 시스템별 개별 확인
- 예외 경로도 테스트

```bash
# 커버리지 확인
pytest --cov=src/core --cov-report=term-missing tests/core/
```
```

#### 1.5 문서화 규칙

**목표**: 자기 설명적 코드

**작업**:
```markdown
## 5. 문서화 규칙

### Docstring 필수
- 모든 공개 함수/클래스
- Google 스타일

```python
def get_logger(name: str) -> structlog.BoundLogger:
    """구조화된 로거를 반환합니다.

    Args:
        name: 로거 이름 (일반적으로 __name__ 사용)

    Returns:
        설정된 structlog BoundLogger 인스턴스

    Example:
        ```python
        logger = get_logger(__name__)
        logger.info("message", user_id=123)
        ```
    """
    return structlog.get_logger(name)
```

### Type Hints 100%
- 모든 함수 인자와 반환값
- mypy strict mode 통과 필수

```python
# ✅ 올바른 방법
def process_data(data: dict[str, Any]) -> Result[Data, AppError]:
    ...

# ❌ 잘못된 방법
def process_data(data):  # 타입 없음
    ...
```

### 주석 최소화
- 코드로 설명
- 복잡한 로직만 주석
- "왜"를 설명 (무엇을 아님)
```

---

### Step 2: DNA 시스템 구현 (3-5시간)

#### 2.1 Phase 1: 기반 DNA 6개 구현

**목표**: 개발 환경 완성

**순서**:
1. Configuration System (6) 먼저 - 다른 DNA가 의존
2. Type System (1)
3. Observability System (2)
4. Testing System (3)
5. Code Quality System (4)
6. Architecture Enforcement (5)

**예시 - DNA 2: Observability System 구현**:

```python
# src/core/logger.py

"""구조화된 로깅 시스템 (DNA 2: Observability)"""

import structlog
from typing import Any

from src.core.config import config


def get_logger(name: str) -> structlog.BoundLogger:
    """구조화된 로거를 반환합니다.

    Args:
        name: 로거 이름 (일반적으로 __name__ 사용)

    Returns:
        설정된 structlog BoundLogger 인스턴스

    Example:
        ```python
        logger = get_logger(__name__)
        logger.info("user login", user_id=123, action="login")
        ```
    """
    structlog.configure(
        processors=[
            structlog.processors.add_log_level,
            structlog.processors.TimeStamper(fmt="iso"),
            structlog.processors.JSONRenderer()
        ],
        context_class=dict,
        logger_factory=structlog.PrintLoggerFactory(),
    )

    return structlog.get_logger(name)


# 전역 로거 (편의성)
logger = get_logger(__name__)
```

**테스트**:
```python
# tests/core/test_logger.py

"""Observability System 테스트 (DNA 2)"""

import structlog
from src.core.logger import get_logger


def test_get_logger_returns_bound_logger():
    """get_logger가 structlog BoundLogger를 반환하는지 확인"""
    # Given
    logger_name = "test.module"

    # When
    logger = get_logger(logger_name)

    # Then
    assert isinstance(logger, structlog.BoundLogger)


def test_get_logger_with_different_names():
    """서로 다른 이름으로 로거를 생성할 수 있는지 확인"""
    # Given
    name1, name2 = "module1", "module2"

    # When
    logger1 = get_logger(name1)
    logger2 = get_logger(name2)

    # Then
    assert logger1.name == name1
    assert logger2.name == name2


def test_logger_info_logs_correctly(caplog):
    """로거가 info 레벨 로그를 올바르게 기록하는지 확인"""
    # Given
    logger = get_logger("test")
    message = "test message"

    # When
    logger.info(message, user_id=123)

    # Then
    assert message in caplog.text
    assert "user_id" in caplog.text
```

**체크리스트 체크**:
```markdown
### [x] DNA 2: Observability System
  - [x] structlog 추가 (`uv add structlog`)
  - [x] src/core/logger.py 작성
  - [x] get_logger() 구현
  - [x] tests/core/test_logger.py 작성 (3개 테스트)
  - [x] 테스트 실행 (`pytest tests/core/test_logger.py`)
  - [x] 커버리지 95%+ 확인
```

#### 2.2 Phase 2: 도메인 DNA 5개 구현

**목표**: 기능 구현 준비 완료

**순서**:
7. Error Handling System (7)
8. API System (9) - 프로젝트에 따라 순서 변경 가능
9. Data System (10)
10. Performance System (8)
11. Security System (11)

**예시 - DNA 7: Error Handling System 구현**:

```python
# src/core/error.py

"""에러 처리 시스템 (DNA 7: Error Handling)"""

from typing import TypeVar, Generic, Union
from dataclasses import dataclass


T = TypeVar('T')
E = TypeVar('E')


@dataclass
class Ok(Generic[T]):
    """성공 결과"""
    value: T

    def is_ok(self) -> bool:
        return True

    def is_err(self) -> bool:
        return False

    def unwrap(self) -> T:
        return self.value


@dataclass
class Err(Generic[E]):
    """에러 결과"""
    error: E

    def is_ok(self) -> bool:
        return False

    def is_err(self) -> bool:
        return True

    def unwrap(self) -> None:
        raise ValueError(f"Called unwrap on Err: {self.error}")


Result = Union[Ok[T], Err[E]]


class AppError(Exception):
    """애플리케이션 기본 에러"""

    def __init__(self, message: str, code: str = "UNKNOWN"):
        self.message = message
        self.code = code
        super().__init__(self.message)
```

---

### Step 3: 통합 검증 (1시간)

#### 3.1 전체 DNA 시스템 동작 확인

**목표**: 11개 DNA 모두 작동하는지 확인

**작업**:
```bash
# 1. Type System 검증
mypy src/

# 2. Code Quality 검증
ruff check src/
black --check src/

# 3. Testing System 검증
pytest tests/ --cov=src --cov-report=term-missing

# 4. Architecture Enforcement 검증
# (import-linter 등 실행)

# 5. 모든 DNA 통합 확인
pytest tests/core/  # 모든 DNA 테스트 실행
```

#### 3.2 Kent Beck 검증

**목표**: 10/11개 이상 달성

**작업**:
```markdown
# 05-검증보고서.md (선택적)

## DNA 시스템 검증 결과

| DNA               | 구현 완료 | 테스트 | 동작 확인 | 비고 |
| ----------------- | --------- | ------ | --------- | ---- |
| 1. Type           | ✅         | ✅      | ✅         | mypy strict 통과 |
| 2. Observability  | ✅         | ✅      | ✅         | structlog 설정 완료 |
| 3. Testing        | ✅         | ✅      | ✅         | pytest 95%+ 커버리지 |
| 4. Code Quality   | ✅         | ✅      | ✅         | ruff + black |
| 5. Architecture   | ✅         | ✅      | ✅         | import-linter |
| 6. Configuration  | ✅         | ✅      | ✅         | pydantic v2 |
| 7. Error Handling | ✅         | ✅      | ✅         | Result<T,E> 패턴 |
| 8. Performance    | ✅         | ✅      | ✅         | pytest-benchmark |
| 9. API            | ✅         | ✅      | ✅         | FastAPI |
| 10. Data          | ✅         | ✅      | ✅         | SQLAlchemy |
| 11. Security      | ✅         | ✅      | ✅         | bandit + safety |

**결과**: 11/11개 완성 ✅

## Kent Beck 검증
- Kent Beck BPlusTree: 10/11개 (Observability 최소)
- 우리 프로젝트: 11/11개 ✅
```

#### 3.3 품질 검사

**목표**: 0 violations

**작업**:
```bash
# Ruff 검사
ruff check src/ tests/
# Expected: All checks passed!

# Mypy 검사
mypy src/
# Expected: Success: no issues found

# 테스트 커버리지
pytest --cov=src --cov-report=term-missing --cov-fail-under=95
# Expected: Coverage >= 95%

# 보안 스캔
bandit -r src/
safety check
# Expected: No issues found
```

---

## 📤 출력 문서 (이 Stage에서 생성해야 할 것)

### 1. **`05S-01_dna_standards.md`** (DNA 구현 표준)

**내용**:
```markdown
# DNA 시스템 구현 표준

## 1. 파일 구조 규칙
[src/core/ 구조]

## 2. 네이밍 규칙
[클래스, 함수, 상수, 변수]

## 3. Import 규칙
[절대 경로, 순서]

## 4. 테스트 규칙
[95%+ 커버리지, Given-When-Then]

## 5. 문서화 규칙
[Docstring, Type Hints]

## 6. 예시 코드
[각 DNA 시스템별 템플릿]
```

---

### 2. **실제 구현 파일**

#### 설정 파일
- `pyproject.toml` (Type, Testing, Quality, Config)
- `.pre-commit-config.yaml` (Quality)
- `mypy.ini` (Type)
- `ruff.toml` (Quality)

#### DNA 시스템 코드
```
src/core/
├── __init__.py
├── logger.py      # DNA 2: Observability
├── error.py       # DNA 7: Error Handling
├── config.py      # DNA 6: Configuration
└── types.py       # DNA 1: Type definitions

tests/core/
├── __init__.py
├── test_logger.py
├── test_error.py
└── test_config.py
```

#### 기타
- `benchmarks/` (DNA 8: Performance)
- Security 스캔 설정 (DNA 11)

---

### 3. **검증 보고서** (선택적)

**내용**:
- 11개 DNA 시스템 검증 결과
- Kent Beck 비교
- 품질 검사 결과
- 커버리지 리포트

---

## 🔄 다음 Stage로 전달되는 것

**Stage 5 → Stage 6**:
- ✅ 완성된 DNA 시스템 (src/core/)
- ✅ DNA 구현 표준 (05S-01)
- ✅ 검증된 품질 (95%+ 커버리지, 0 violations)

**Stage 6에서 사용**:
- Project Standards에서 DNA 시스템 사용 강제
- "src.core에서 import 필수" 등 규칙 명시

**Stage 7에서 사용**:
- Blueprint에서 DNA 시스템 활용
- `from src.core.logger import get_logger` 등 명시

---

## ⚠️ 주의사항

### 1. TDD 기반 개발
- ❌ 코드 먼저 작성 후 테스트 X
- ✅ 테스트 먼저 작성 → 코드 구현 → 리팩토링

### 2. 한 번에 하나씩
- DNA 1개 완성 → 테스트 → 다음 DNA
- 체크리스트 하나씩 체크하며 진행

### 3. 품질 타협 금지
- 95%+ 커버리지 반드시 달성
- 0 violations 반드시 달성
- "나중에 고치자" 금지

### 4. 문서화 필수
- Docstring 없으면 미완성
- Type Hints 없으면 미완성
- 예시 코드 없으면 미완성

### 5. 실제 사용 확인
- 각 DNA 시스템을 간단한 예제로 테스트
- "만들기만 하고 안 써봄" 금지

---

## 📚 참고 자료

### 필수
- `04D-01_dna_blueprint.md` - 청사진 (파일 구조)
- `04T-01_dna_tasks.md` - 작업 분해
- `04L-01_dna_checklist.md` - 체크리스트
- `DNA_Systems_11_Complete_Guide.md` - 11개 DNA 상세

### 언어별 참고
- Python: pytest, mypy, ruff, structlog
- TypeScript: jest, prettier, eslint, winston
- Rust: cargo test, clippy, tracing
- Go: testing, golangci-lint, zap

---

## ✅ 완료 기준

이 Stage는 다음 조건을 모두 만족하면 완료:

- [ ] **05S-01_dna_standards.md** 작성 완료
  - [ ] 5개 규칙 섹션 모두 작성
  - [ ] 예시 코드 포함

- [ ] **11개 DNA 시스템 구현 완료**
  - [ ] Phase 1 (기반 6개) 완성
  - [ ] Phase 2 (도메인 5개) 완성
  - [ ] 모든 파일 구현 표준 준수

- [ ] **테스트 95%+ 커버리지**
  - [ ] 각 DNA별 테스트 작성
  - [ ] pytest --cov 실행
  - [ ] 커버리지 리포트 확인

- [ ] **품질 검사 0 violations**
  - [ ] ruff check 통과
  - [ ] mypy 통과
  - [ ] bandit 통과

- [ ] **Kent Beck 검증**
  - [ ] 10/11개 이상 달성
  - [ ] 검증 보고서 (선택)

- [ ] **04L-01 체크리스트 완료**
  - [ ] 모든 체크박스 체크
  - [ ] 전체 검증 완료

---

**마지막 업데이트**: 2025-11-13
**다음 검토**: Stage 6에서 DNA 시스템 사용 강제 확인


================================================================================
# End of 05G-00_dna_implementation_guide.md
================================================================================



================================================================================
# 📄 6. 06G-00_project_standards_guide.md
================================================================================

# 프로젝트 표준 문서 작성 가이드

> **목적**: Stage 6 - ADR 결정을 실행 가능한 표준 규칙으로 변환하여 Agent가 따를 수 있는 구체적 가이드를 제공합니다.
>
> **버전**: v2.0 (2025-11-12)
> - v2.0: Stage 6 범위 명시, 입력/출력 문서 추가

---

## 📥 입력 문서 (Stage 3-5에서 받은 것)

Stage 6를 시작하기 전에 다음 문서를 읽어야 합니다:

#### 1. **모든 DNA 시스템 ADR** (필수)
**위치**: `docs/adr/DNA 시스템/03A-001_*.md` ~ `03A-015_*.md`
- 로깅, 에러 처리, 인증, 설정 등 공통 환경 결정
- **활용**: DNA 시스템 표준 규칙 작성

#### 2. **모든 Domain ADR** (필수)
**위치**: `docs/adr/domain/03A-101_*.md` ~ `03A-130_*.md`
- 기술 스택, 데이터 설계, API 설계 등 프로젝트 특화 결정
- **활용**: Domain 표준 규칙 작성

#### 3. **05S-01_dna_standards.md** (참고)
**위치**: `docs/stage5/05S-01_dna_standards.md` (Stage 5에서 작성됨)
- DNA 구현 표준 (파일 구조, 네이밍, Import 규칙, 테스트 규칙, 문서화 규칙)
- **활용**: DNA 시스템 사용 규칙 작성 시 참고

#### 4. **구현된 core/ 모듈** (참고)
**위치**: `src/core/` (Stage 5에서 구현됨)
- 실제 DNA 시스템 코드 (logger.py, error.py, config.py, types.py 등)
- **활용**: 실제 API 확인, 사용 예시 작성

---

## 📤 출력 문서 (이 Stage에서 생성해야 할 문서)

### 필수 문서

#### 1. **`06D-01_project_standards.md`** - 프로젝트 표준 (THE 산출물)
**내용**:
- ADR 결정을 실행 가능한 규칙으로 변환
- Agent가 직접 읽고 따를 수 있는 구체적 가이드
- Mandatory vs Optional 구분

**구조** (5개 섹션):
```markdown
# PROJECT STANDARDS

## 1. Naming Conventions
- File naming: snake_case, max 50 chars
- Variable naming: camelCase
- Class naming: PascalCase
- Examples: ✅ DO / ❌ DON'T

## 2. Code Organization
- Directory structure
- Module boundaries
- Import rules

## 3. Core Modules Usage
- Mandatory: MUST use core.logging
- Examples: ✅ DO / ❌ DON'T

## 4. Quality Standards
- Test coverage: 95%+ unit, 85%+ integration
- Linting: ruff, mypy
- Format: black

## 5. Development Workflow
- Git commit convention
- PR rules
- Review criteria
```

**예시**:
```markdown
## 3. Core Modules Usage

### 3.1 Logging (Mandatory)
**Rule**: MUST use `core.logging.get_logger()`

✅ **DO**:
```python
from core.logging import get_logger
logger = get_logger(__name__)
logger.info("Order created", order_id=order.id)
```

❌ **DON'T**:
```python
import logging  # FORBIDDEN!
logger = logging.getLogger(__name__)
```

**Enforcement**: Pre-commit hook blocks `import logging`
**Reference**: ADR-001 Logging Strategy
```

**특징**:
- ✅ DO / ❌ DON'T 예시 필수
- Enforcement 방법 명시
- ADR 참조 링크

---

## 🔄 다음 Stage로 전달되는 것

Stage 6 → Stage 7:
- ✅ 완성된 프로젝트 표준 문서
- ✅ Mandatory vs Optional 구분
- ✅ Agent가 따를 구체적 규칙
- ✅ Enforcement 방법

Stage 7 (Blueprint)에서는 이를 기반으로:
- 표준 규칙을 적용한 상세 청사진 작성
- 도메인별 구현 가이드에 표준 반영

---

## 목차

1. [프로젝트 표준이란](#1-프로젝트-표준이란)
2. [Mandatory vs Optional Standards](#2-mandatory-vs-optional-standards)
3. [Standards 파일 구조](#3-standards-파일-구조)
4. [ADR → Standards 변환 상세 절차](#4-adr--standards-변환-상세-절차)
5. [Individual Standard 작성하기](#5-individual-standard-작성하기)
6. [Progressive Accumulation 전략](#6-progressive-accumulation-전략)
7. [Standards 생명주기 관리](#7-standards-생명주기-관리)
8. [다음 단계 연결](#8-다음-단계-연결)

---

## 1. 프로젝트 표준이란

### 1-1. 정의

**Project Standards**는 ADR 결정을 구체적인 실행 규칙으로 변환한 문서입니다.

**핵심 개념**:
- **ADR = 결정 (What + Why)**
- **Standards = 실행 (How + Enforcement)**
- **Agent가 직접 읽고 따를 수 있는 수준의 구체성**

### 1-2. ADR vs Standards 비교

| 측면 | ADR | Standards |
|------|-----|-----------|
| **목적** | 아키텍처 결정 기록 | 실행 가이드 제공 |
| **내용** | Decision + Context + Rationale | Rules + Examples + Patterns |
| **독자** | 의사결정자 (Jason, 1호, 2호) | 개발자, Agent |
| **형식** | 서술형 (왜 이렇게 결정했나) | 명령형 (이렇게 하라) |
| **변경** | 불변 (Superseded로 대체) | 업데이트 가능 (패턴 추가) |
| **구조** | 7개 섹션 (flexible) | 5개 섹션 (fixed) |

### 1-3. 정보 흐름에서 Standards의 위치

```
ADR Documents (Decisions)
    ↓ Transformation
PROJECT_STANDARDS (Rules) ← 이 가이드!
    ↓ Applied to
BLUEPRINT (System Design)
    ↓ Broken down
TASK Documents (Work Units)
    ↓ Converted to
CHECKLIST (Agent Instructions)
    ↓ Execute
Agent Implementation
```

**Standards의 역할**:
- ✅ ADR 결정을 코드로 옮기는 **변환 계층**
- ✅ Blueprint 작성 시 **참조할 규칙 집합**
- ✅ Task/Checklist에 **인라인 복사될 내용**
- ✅ Quality Gates의 **검증 기준**

### 1-4. Jason의 방법론에서 Standards의 중요성

**Problem**: ADR만으로는 Agent가 실행 불가

```markdown
❌ ADR-015: "structlog를 사용하기로 결정"
   → Agent: "어떻게 사용하나요? import는? 형식은?"
```

**Solution**: Standards가 구체적 실행 규칙 제공

```markdown
✅ Standards/01_logging.md:
   - Import: `from structlog import get_logger`
   - Format: `logger.info("event_name", key=value)`
   - Forbidden: `print()`, `import logging`
   - Enforcement: pre-commit hook, ruff T201
   → Agent: 명확하게 따라 할 수 있음!
```

**핵심 인사이트**:
- Standards = "Blueprint를 작성하는 사람"이 따를 규칙
- Standards = "Checklist에 인라인 복사"될 내용
- Standards = "Quality Gates가 검증"할 기준

---

## 2. Mandatory vs Optional Standards

### 2-1. Mandatory Standards (필수 5개)

**모든 프로젝트에 필수적인 표준**:

#### 01. Logging (`01_logging.md`)
**Why Mandatory**: 프로덕션 디버깅, 모니터링, 감사 추적 필수

**출처 ADR 예시**:
- ADR-015: structlog 사용
- ADR-016: 로그 레벨 규칙
- ADR-017: 민감 정보 로깅 금지

**주요 내용**:
- Import 규칙
- Event 명명 규칙
- Context binding
- 금지 사항 (print, logging 모듈)
- Enforcement (pre-commit, ruff)

#### 02. Error Handling (`02_error_handling.md`)
**Why Mandatory**: 모든 코드는 에러를 다뤄야 함

**출처 ADR 예시**:
- ADR-020: Custom exception hierarchy
- ADR-021: 에러 로깅 규칙
- ADR-022: User-facing error messages

**주요 내용**:
- Exception 계층 구조
- 에러 발생 패턴 (raise vs return)
- 에러 로깅 규칙
- User-facing vs Internal errors
- Enforcement (mypy, pytest)

#### 03. Configuration (`03_configuration.md`)
**Why Mandatory**: 모든 프로젝트는 설정 관리 필요

**출처 ADR 예시**:
- ADR-025: pydantic-settings 사용
- ADR-026: .env 파일 규칙
- ADR-027: 시크릿 관리 (AWS Secrets Manager)

**주요 내용**:
- Settings class 패턴 (Pydantic)
- 환경별 설정 (.env.dev, .env.prod)
- 시크릿 관리
- 금지 사항 (하드코딩, git commit)
- Enforcement (pre-commit hook)

#### 04. Type Hints (`04_type_hints.md`)
**Why Mandatory**: 타입 안정성은 품질의 기본

**출처 ADR 예시**:
- ADR-030: 100% type hints coverage
- ADR-031: mypy strict mode
- ADR-032: Pydantic for DTOs

**주요 내용**:
- Type hint 규칙 (모든 함수, 클래스)
- Generic types (List, Dict, Optional)
- Pydantic models for data
- 금지 사항 (Any, type: ignore 남용)
- Enforcement (mypy strict)

#### 05. Testing (`05_testing.md`)
**Why Mandatory**: 테스트 없는 코드는 레거시

**출처 ADR 예시**:
- ADR-010: 95% coverage 필수
- ADR-035: pytest 사용
- ADR-036: Given-When-Then 패턴

**주요 내용**:
- Test 구조 (Given-When-Then)
- Fixture 사용법
- Mocking 규칙
- Coverage requirements (95% unit, 85% integration)
- Enforcement (pytest-cov, CI)

### 2-2. Optional Standards (프로젝트 필요에 따라)

#### 06. Database (`06_database.md`)
**When Needed**: DB를 사용하는 프로젝트

**출처 ADR 예시**:
- ADR-040: PostgreSQL 사용
- ADR-041: SQLAlchemy ORM
- ADR-042: Migration with Alembic

**주요 내용**:
- Connection management
- Repository pattern
- Migration 규칙
- Transaction 관리

#### 07. API (`07_api.md`)
**When Needed**: API를 제공하는 프로젝트

**출처 ADR 예시**:
- ADR-025: FastAPI + OpenAPI
- ADR-045: RESTful conventions
- ADR-046: Rate limiting

**주요 내용**:
- Endpoint naming
- HTTP methods, status codes
- Request/Response models (Pydantic)
- Error responses
- Enforcement (OpenAPI validation)

#### 08. Authentication (`08_authentication.md`)
**When Needed**: 사용자 인증이 필요한 프로젝트

**출처 ADR 예시**:
- ADR-050: JWT tokens
- ADR-051: OAuth2 + OIDC
- ADR-052: Session management

#### 09. Performance (`09_performance.md`)
**When Needed**: 성능 최적화가 필요한 프로젝트

**출처 ADR 예시**:
- ADR-055: Redis caching
- ADR-056: async/await 규칙
- ADR-057: DB query optimization

#### 10. Architecture (`10_architecture.md`)
**When Needed**: 복잡한 시스템 (Clean Architecture 등)

**출처 ADR 예시**:
- ADR-001: Clean Architecture
- ADR-002: DDD patterns
- ADR-003: Dependency injection

### 2-3. Universal Standards

#### 99. Common Mistakes (`99_common_mistakes.md`)
**항상 필요**: 모든 Task에 적용되는 범용 실수 집합

**출처**:
- 여러 ADR의 Consequences (harder)
- 과거 프로젝트 경험
- 코드 리뷰에서 발견된 패턴

**구조**:
```markdown
# 99. Common Mistakes

## Category: Imports
**Mistake 1: 상대 import 남용**
❌ from ..domain import User
✅ from src.domain import User

## Category: Error Handling
**Mistake 2: 빈 except**
❌ try: ... except: pass
✅ try: ... except SpecificError as e: logger.error(...)

## Category: Type Hints
**Mistake 3: Any 남용**
❌ def process(data: Any) -> Any
✅ def process(data: dict[str, int]) -> ProcessResult
```

### 2-4. Standards 우선순위

**프로젝트 시작 시** (Week 1):
1. ✅ Mandatory 5개 (01-05) - 즉시 작성
2. ✅ 99_common_mistakes.md - 초기 버전 작성

**필요 시점에 추가**:
- Week 2: API 개발 시작 → 07_api.md 작성
- Week 3: DB 연동 시작 → 06_database.md 작성
- Week 4: 인증 구현 → 08_authentication.md 작성

**나중에 추가** (최적화 단계):
- Month 2: 성능 이슈 발생 → 09_performance.md 작성
- Month 3: 아키텍처 정리 → 10_architecture.md 작성

---

## 3. Standards 파일 구조

### 3-1. 파일 분리 전략

**원칙**: 각 표준은 독립된 파일, 150-200 lines

**디렉토리 구조**:
```
PROJECT_STANDARDS/
├── 00_index.md (100 lines)        # 전체 인덱스, ADR 매핑
├── 01_logging.md (150 lines)      # Mandatory
├── 02_error_handling.md (180 lines)
├── 03_configuration.md (120 lines)
├── 04_type_hints.md (160 lines)
├── 05_testing.md (200 lines)
├── 06_database.md (180 lines)     # Optional
├── 07_api.md (200 lines)
├── 08_authentication.md (150 lines)
├── 09_performance.md (140 lines)
├── 10_architecture.md (220 lines)
└── 99_common_mistakes.md (200 lines)  # Universal
```

**파일 크기 기준**:
- ✅ 150-200 lines: 이상적
- ⚠️ 100-150 lines: 괜찮음 (간단한 표준)
- ⚠️ 200-250 lines: 괜찮음 (복잡한 표준)
- ❌ 250+ lines: 파일 분리 검토 (예: 07_api.md → 07_api_rest.md, 07_api_graphql.md)

### 3-2. Individual File 구조 (5개 섹션)

**모든 Standards 파일은 동일한 5개 섹션 구조**:

```markdown
# XX. [Standard Name]

> **출처**: ADR-XXX, ADR-YYY
> **업데이트**: YYYY-MM-DD

## 1. [Core Section 1] (Line 1-40)
핵심 규칙, import, 기본 패턴

## 2. [Core Section 2] (Line 41-80)
상세 규칙, 고급 패턴

## 3. [Core Section 3] (Line 81-120)
특수 케이스, 예외 처리

## 4. Common Mistakes (Line 121-160)
자주 하는 실수 (❌/✅ Before/After)

## 5. Enforcement (Line 161-200)
검증 메커니즘 (pre-commit, CI, Quality Gates)
```

**Line 범위 표시 이유**:
- Task 문서에서 정확히 참조: "01_logging.md Line 41-80"
- Agent가 읽을 범위 명확: 전체 150 lines가 아닌 40 lines만
- Progressive disclosure: 필요한 부분만

### 3-3. 00_index.md 구조

**목적**: ADR → Standards 매핑, 빠른 네비게이션

```markdown
# 00. Project Standards Index

> **Last Updated**: 2025-01-15
> **Project**: MyProject v1.0

## Standards Overview

### Mandatory Standards (5)
- ✅ 01_logging.md - Logging rules (structlog)
- ✅ 02_error_handling.md - Exception handling
- ✅ 03_configuration.md - Settings management
- ✅ 04_type_hints.md - Type safety
- ✅ 05_testing.md - Testing practices

### Optional Standards (5)
- ✅ 06_database.md - PostgreSQL + SQLAlchemy
- ✅ 07_api.md - FastAPI + OpenAPI
- ⏳ 08_authentication.md - (Planned Week 5)
- ⏳ 09_performance.md - (Planned Month 2)
- ⏳ 10_architecture.md - (Planned Month 3)

### Universal Standards
- ✅ 99_common_mistakes.md - Common pitfalls

---

## ADR → Standards Mapping

| ADR | 제목 | 생성 Standards | 날짜 |
|-----|------|----------------|------|
| ADR-001 | Clean Architecture | 10_architecture.md | 2025-01-05 |
| ADR-010 | 95% Coverage | 05_testing.md Section 4 | 2025-01-10 |
| ADR-015 | structlog 사용 | 01_logging.md 전체 | 2025-01-15 |
| ADR-020 | Domain → Infra 금지 | 10_architecture.md Section 2 | 2025-01-20 |
| ADR-025 | FastAPI + OpenAPI | 07_api.md 전체 | 2025-01-25 |

---

## When to Read Which Standard

**JWT 토큰 생성 구현 시**:
- 01_logging.md Line 31-60 (Event format)
- 02_error_handling.md Line 41-80 (Custom exceptions)
- 04_type_hints.md Line 81-120 (Pydantic models)
- 08_authentication.md Line 1-40 (JWT basics)

**API endpoint 추가 시**:
- 01_logging.md Line 61-90 (Request context)
- 07_api.md Line 1-120 (Endpoint, models, errors)
- 05_testing.md Line 81-120 (API testing)

**Database query 작성 시**:
- 06_database.md Line 1-80 (Repository pattern)
- 02_error_handling.md Line 81-120 (DB errors)
- 09_performance.md Line 41-80 (Query optimization)

---

## Cross-References

**01_logging.md references**:
- 02_error_handling.md: Exception 로깅 규칙
- 07_api.md: Request ID binding

**07_api.md references**:
- 01_logging.md: API 로깅
- 04_type_hints.md: Pydantic models
- 02_error_handling.md: Error responses
```

---

## 4. ADR → Standards 변환 상세 절차

### 4-1. 변환 절차 Overview

```
ADR Document
    ↓ Step 1: 섹션 매핑
Decision → Standards Sections 1-3
Compliance → Standards Section 5
Consequences (harder) → Standards Section 4
    ↓ Step 2: 형식 변환
서술형 (why) → 명령형 (how)
예시 추가 (Good/Bad)
Line 범위 할당
    ↓ Step 3: Enforcement 추가
Pre-commit hooks
CI pipeline
Quality Gates
    ↓ Output
Standards/XX_name.md (150-200 lines)
```

### 4-2. Step 1: ADR 섹션 → Standards 섹션 매핑

#### ADR Decision → Standards Sections 1-3

**ADR Decision 예시** (ADR-015):
```markdown
## Decision
모든 로깅은 structlog 사용.

Import:
```python
from structlog import get_logger
logger = get_logger()
```

Pattern:
```python
logger.info("event_name", key=value)
```

Forbidden:
- print()
- import logging
```

**→ Standards Section 1-3 변환**:

**Section 1: Import and Setup** (Line 1-40)
```markdown
## 1. Import and Setup (Line 1-40)

**Mandatory Import**:
```python
from structlog import get_logger
logger = get_logger()
```

**Configuration** (main.py 또는 settings.py):
```python
import structlog

structlog.configure(
    processors=[
        structlog.stdlib.add_log_level,
        structlog.processors.TimeStamper(fmt="iso"),
        structlog.processors.JSONRenderer(),
    ],
)
```

**Forbidden Imports**:
❌ `import logging` - 표준 logging 모듈 사용 금지
❌ `from logging import getLogger` - 모든 logging 모듈 금지

**Why**: ELK stack 연동을 위해 structlog만 사용
```

**Section 2: Event Format** (Line 41-80)
```markdown
## 2. Event Format (Line 41-80)

**Pattern**: `logger.info("event_name", key=value)`

**Event Naming Rules**:
- snake_case 사용 (user_login, not UserLogin)
- 동사_명사 형태 (token_generated, order_created)
- 과거형 사용 안 함 (user_logged_in ❌)

**Good Examples**:
```python
✅ logger.info("user_login", user_id=user.id, ip=request.ip)
✅ logger.error("token_expired", token_id=token.jti, user_id=user.id)
✅ logger.warning("rate_limit_exceeded", user_id=user.id, limit=100)
```

**Bad Examples**:
```python
❌ logger.info(f"User {user.id} logged in")  # 문자열 포맷 사용
❌ logger.info("login")                       # Context 없음
❌ logger.info("User Login")                  # CamelCase
❌ print(f"User logged in: {user.id}")       # print 사용
```

**Why**:
- ELK stack은 key-value 필요 (문자열 파싱 불가)
- Request ID로 필터링 가능
- 성능 분석 (duration 자동 기록)
```

**Section 3: Context Binding** (Line 81-120)
```markdown
## 3. Context Binding (Line 81-120)

**Request ID Auto-binding** (FastAPI):
```python
from structlog import get_logger
import uuid

@app.middleware("http")
async def bind_request_id(request: Request, call_next):
    request_id = request.headers.get("X-Request-ID", str(uuid.uuid4()))
    logger = get_logger().bind(request_id=request_id)
    # request.state.logger = logger (store for later use)
    response = await call_next(request)
    return response
```

**User Context Binding**:
```python
logger = get_logger().bind(user_id=current_user.id)
logger.info("order_created", order_id=order.id)
# Output: {"event": "order_created", "order_id": 123, "user_id": 456, "request_id": "abc-123", ...}
```

**Exception Logging**:
```python
try:
    token = generate_token(user_id)
except TokenGenerationError as e:
    logger.error("token_generation_failed", user_id=user_id, exc_info=True)
    raise
```

**Why**: Context binding으로 모든 로그에 request_id, user_id 자동 포함
```

#### ADR Consequences (Harder) → Standards Section 4

**ADR Consequences 예시**:
```markdown
## Consequences
❌ **Harder**:
- 초기 설정 복잡도
- 팀 교육 필요 (structlog API)
- Migration 작업 (500+ print() 제거)
```

**→ Standards Section 4: Common Mistakes**:
```markdown
## 4. Common Mistakes (Line 121-160)

**Mistake 1: 문자열 포맷 사용**
```python
❌ Before: logger.info(f"Processing {count} items")
✅ After:  logger.info("processing_items", count=count)
```
**Why**: ELK stack은 key-value 필요, f-string은 파싱 불가
**출처**: ADR-015 Consequences (Migration 작업 중 발견)

**Mistake 2: print() 사용**
```python
❌ Before: print(f"User {user.id} logged in")
✅ After:  logger.info("user_login", user_id=user.id)
```
**Why**: print()는 파일 저장 안 됨, ELK 수집 불가
**출처**: ADR-015 Decision (print 금지)

**Mistake 3: 민감 정보 로깅**
```python
❌ Before: logger.info("auth", password=password, token=token)
✅ After:  logger.info("auth", user_id=user.id)
```
**Why**: 보안 이슈, GDPR 위반, 감사 실패
**출처**: 과거 프로젝트 보안 감사에서 발견

**Mistake 4: Exception 로깅 시 context 누락**
```python
❌ Before: logger.error("Error occurred")
✅ After:  logger.error("token_generation_failed", user_id=user.id, exc_info=True)
```
**Why**: 디버깅을 위한 context 필수, exc_info=True로 스택 트레이스 포함
```

#### ADR Compliance → Standards Section 5

**ADR Compliance 예시**:
```markdown
## Compliance
1. Automated: pre-commit hook (print 차단)
2. Automated: ruff T201
3. Semi-automated: PR 체크리스트
4. Manual: 민감 정보 로깅 리뷰
```

**→ Standards Section 5: Enforcement**:
```markdown
## 5. Enforcement (Line 161-200)

### 5-1. Pre-commit Hook

**설정** (`.pre-commit-config.yaml`):
```yaml
- repo: local
  hooks:
    - id: no-print
      name: Detect print()
      entry: python scripts/check_no_print.py
      language: python
      types: [python]
```

**스크립트** (`scripts/check_no_print.py`):
```python
import sys
import re

def check_file(filename):
    with open(filename) as f:
        content = f.read()
    if re.search(r'\bprint\s*\(', content):
        print(f"❌ {filename}: print() 사용 금지. logger.info() 사용.")
        return False
    return True

if __name__ == "__main__":
    files = sys.argv[1:]
    if not all(check_file(f) for f in files):
        sys.exit(1)
```

### 5-2. Ruff Configuration

**설정** (`pyproject.toml`):
```toml
[tool.ruff]
select = ["T201"]  # Detect print()

[tool.ruff.lint]
ignore = []
```

**실행**:
```bash
ruff check .
# Output: src/main.py:10:5: T201 `print` found
```

### 5-3. CI Pipeline

**GitHub Actions** (`.github/workflows/ci.yml`):
```yaml
name: CI
on: [push, pull_request]

jobs:
  lint:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - name: Install dependencies
        run: pip install ruff
      - name: Check print()
        run: ruff check .
```

### 5-4. Quality Gates (Phase 5B)

**Agent 자가 검증** (`~/.claude/hooks/spark_quality_gates.py`):
```python
def check_logging_standards():
    """Check logging standards compliance."""
    # Ruff check
    result = subprocess.run(["ruff", "check", "."], capture_output=True)
    if result.returncode != 0:
        return False, "Ruff violations (T201 print detected)"

    # Grep check (backup)
    result = subprocess.run(["grep", "-r", "print(", "src/"], capture_output=True)
    if result.returncode == 0:
        return False, "print() detected in src/"

    return True, "Logging standards OK"
```

### 5-5. PR Checklist

**PR Template** (`.github/pull_request_template.md`):
```markdown
## Logging Checklist
- [ ] print() 없음 (logger.info() 사용)
- [ ] logger.info("event", key=value) 형식 준수
- [ ] 민감 정보(password, token) 로깅 없음
- [ ] Exception 로깅 시 exc_info=True 포함
```

### 5-6. Manual Review (주 1회)

**리뷰 항목**:
1. 민감 정보 로깅 여부 (password, token, API key)
2. Event naming convention 준수 (snake_case, 동사_명사)
3. Context binding 적절성 (request_id, user_id)
4. 로그 레벨 적절성 (info vs warning vs error)

**리뷰 주기**: 매주 금요일 오후 2시
```

### 4-3. Step 2: 형식 변환 (서술형 → 명령형)

**ADR Decision (서술형)**:
```markdown
우리는 structlog를 사용하기로 결정했습니다.
이는 ELK stack과의 연동을 위해 JSON 포맷이 필요하기 때문입니다.
```

**→ Standards (명령형)**:
```markdown
**모든 로깅은 structlog 사용.**

```python
from structlog import get_logger
logger = get_logger()
logger.info("event_name", key=value)
```

**Why**: ELK stack 연동 (JSON 포맷 필요)
```

**변환 원칙**:
- ❌ "우리는 ~하기로 결정했습니다" (과거형, 설명)
- ✅ "~하라", "~사용", "~금지" (명령형, 직접적)
- ❌ "이는 ~때문입니다" (이유 중심)
- ✅ "**Why**: ~" (선택적 이유, 짧게)

### 4-4. Step 3: 예시 추가 (Good/Bad)

**ADR에는 예시가 적거나 없을 수 있음**:
```markdown
## Decision
logger.info("event_name", key=value) 형식 사용
```

**→ Standards에는 충분한 예시 필요**:
```markdown
**Good Examples**:
```python
✅ logger.info("user_login", user_id=user.id, ip=request.ip)
✅ logger.error("token_expired", token_id=token.jti, user_id=user.id)
✅ logger.warning("rate_limit_exceeded", user_id=user.id, limit=100)
```

**Bad Examples**:
```python
❌ logger.info(f"User {user.id} logged in")  # 문자열 포맷
❌ logger.info("login")                       # Context 없음
❌ logger.info("User Login")                  # CamelCase
```
```

**예시 작성 원칙**:
- Good 3개, Bad 3개 (최소)
- Bad는 실제로 하기 쉬운 실수
- 각 Bad에 주석으로 이유 설명
- Before/After 쌍으로 제시

### 4-5. Step 4: Line 범위 할당

**각 섹션에 Line 범위 명시**:
```markdown
## 1. Import and Setup (Line 1-40)
[40 lines of content]

## 2. Event Format (Line 41-80)
[40 lines of content]

## 3. Context Binding (Line 81-120)
[40 lines of content]

## 4. Common Mistakes (Line 121-160)
[40 lines of content]

## 5. Enforcement (Line 161-200)
[40 lines of content]
```

**Line 범위 계산**:
- 섹션당 평균 40 lines
- 복잡한 섹션 50-60 lines
- 간단한 섹션 30 lines
- 총합 150-200 lines

**Why Line 범위 필요**:
```markdown
Task 문서에서:
"이 Task에 필요한 Standards:
- 01_logging.md Line 41-80 (Event format만)
- 04_type_hints.md Line 81-120 (Pydantic models만)"

→ Agent는 전체 150 lines가 아닌 40 lines씩만 읽음!
```

---

## 5. Individual Standard 작성하기

### 5-1. 01_logging.md 완성 예시

**전체 구조** (150 lines):
```markdown
# 01. Logging Standards

> **출처**: ADR-015 (structlog 사용)
> **업데이트**: 2025-01-15

## 1. Import and Setup (Line 1-40)
[Mandatory import, configuration, forbidden]

## 2. Event Format (Line 41-80)
[Pattern, naming, good/bad examples]

## 3. Context Binding (Line 81-120)
[Request ID, user context, exception logging]

## 4. Common Mistakes (Line 121-160)
[4-5 mistakes with before/after]

## 5. Enforcement (Line 161-200)
[Pre-commit, ruff, CI, Quality Gates, PR checklist, manual review]
```

### 5-2. 07_api.md 작성 예시 (FastAPI)

**출처 ADR**:
- ADR-025: FastAPI + OpenAPI
- ADR-045: RESTful conventions
- ADR-046: Rate limiting

**Section 1: Endpoint Naming** (Line 1-50):
```markdown
## 1. Endpoint Naming (Line 1-50)

**Pattern**: `/api/v1/{resource}`

**Collection Endpoints**:
```python
@app.get("/api/v1/users")
async def list_users(
    skip: int = 0,
    limit: int = 100,
) -> List[UserResponse]:
    """List all users with pagination."""
    ...

@app.post("/api/v1/users")
async def create_user(user: UserCreateRequest) -> UserResponse:
    """Create a new user."""
    ...
```

**Item Endpoints**:
```python
@app.get("/api/v1/users/{user_id}")
async def get_user(user_id: int) -> UserResponse:
    """Get user by ID."""
    ...

@app.patch("/api/v1/users/{user_id}")
async def update_user(
    user_id: int,
    update: UserUpdateRequest,
) -> UserResponse:
    """Update user (partial)."""
    ...

@app.delete("/api/v1/users/{user_id}")
async def delete_user(user_id: int) -> None:
    """Delete user."""
    ...
```

**Action Endpoints** (non-CRUD):
```python
@app.post("/api/v1/users/{user_id}/activate")
async def activate_user(user_id: int) -> UserResponse:
    """Activate user account."""
    ...

@app.post("/api/v1/users/{user_id}/send-email")
async def send_email(user_id: int, email: EmailRequest) -> None:
    """Send email to user."""
    ...
```

**Forbidden Patterns**:
❌ `/users` - API prefix 누락
❌ `/api/user` - 단수형 (복수형 사용!)
❌ `/api/v1/activate/{user_id}` - Action이 앞에 (뒤에!)
❌ `/api/v1/users/get` - GET 중복 (메서드로 충분)

**Why**: RESTful convention, OpenAPI 자동 생성 최적화
```

**Section 2: Request/Response Models** (Line 51-100):
```markdown
## 2. Request/Response Models (Line 51-100)

**모든 request/response는 Pydantic models 사용.**

**Request Models**:
```python
from pydantic import BaseModel, EmailStr, Field

class UserCreateRequest(BaseModel):
    email: EmailStr
    password: str = Field(min_length=8, max_length=100)
    name: str = Field(min_length=1, max_length=100)

class UserUpdateRequest(BaseModel):
    email: EmailStr | None = None
    name: str | None = None
    # password는 별도 endpoint (PATCH /users/{id}/password)
```

**Response Models**:
```python
from datetime import datetime

class UserResponse(BaseModel):
    id: int
    email: EmailStr
    name: str
    created_at: datetime
    is_active: bool

    class Config:
        from_attributes = True  # SQLAlchemy ORM 지원
```

**Good Examples**:
```python
✅ class UserCreateRequest(BaseModel):
       email: EmailStr  # EmailStr로 validation
       password: str = Field(min_length=8)  # Field로 제약

✅ class UserResponse(BaseModel):
       id: int
       email: EmailStr
       # password 포함 안 함! (보안)
```

**Bad Examples**:
```python
❌ @app.post("/api/v1/users")
   async def create_user(email: str, password: str):  # dict 대신 개별 파라미터
       ...

❌ class UserResponse(BaseModel):
       password_hash: str  # 민감 정보 노출!

❌ async def get_user(user_id: int) -> dict:  # dict 대신 Pydantic model
```

**Why**: 자동 validation, OpenAPI schema 생성, Type safety
```

**Section 3: HTTP Status Codes** (Line 101-140):
```markdown
## 3. HTTP Status Codes (Line 101-140)

**Status Code Rules**:
- **200 OK**: GET, PATCH 성공
- **201 Created**: POST 성공 (생성)
- **204 No Content**: DELETE 성공
- **400 Bad Request**: Client error (validation)
- **401 Unauthorized**: 인증 실패
- **403 Forbidden**: 권한 없음
- **404 Not Found**: 리소스 없음
- **422 Unprocessable Entity**: Pydantic validation 실패
- **500 Internal Server Error**: Server error

**Good Examples**:
```python
✅ @app.post("/api/v1/users", status_code=201)  # 201 Created
   async def create_user(user: UserCreateRequest) -> UserResponse:
       ...

✅ @app.delete("/api/v1/users/{user_id}", status_code=204)
   async def delete_user(user_id: int) -> None:  # None = 204
       ...

✅ @app.get("/api/v1/users/{user_id}")
   async def get_user(user_id: int) -> UserResponse:
       user = await get_user_by_id(user_id)
       if not user:
           raise HTTPException(status_code=404, detail="User not found")
       return user
```

**Bad Examples**:
```python
❌ @app.post("/api/v1/users")  # status_code 누락 (200 리턴됨)
   async def create_user(...) -> UserResponse:

❌ @app.delete("/api/v1/users/{user_id}")
   async def delete_user(...) -> dict:
       return {"message": "Deleted"}  # 204 대신 200 + body

❌ @app.get("/api/v1/users/{user_id}")
   async def get_user(...) -> UserResponse | None:
       return None  # 404 대신 200 + null
```

**Why**: RESTful convention, Client가 status code로 결과 판단
```

**Section 4: Common Mistakes** (Line 141-180):
```markdown
## 4. Common Mistakes (Line 141-180)

**Mistake 1: dict 사용**
```python
❌ Before:
   @app.post("/api/v1/users")
   async def create_user(data: dict) -> dict:
       email = data["email"]  # KeyError 가능
       ...

✅ After:
   @app.post("/api/v1/users")
   async def create_user(user: UserCreateRequest) -> UserResponse:
       # Pydantic이 자동 validation
```

**Mistake 2: Response에 민감 정보 포함**
```python
❌ Before:
   class UserResponse(BaseModel):
       id: int
       email: EmailStr
       password_hash: str  # 노출됨!

✅ After:
   class UserResponse(BaseModel):
       id: int
       email: EmailStr
       # password 관련 필드 제외
```

**Mistake 3: Error 세부사항 노출**
```python
❌ Before:
   except Exception as e:
       raise HTTPException(500, detail=str(e))  # 스택 트레이스 노출

✅ After:
   except SpecificError as e:
       logger.error("user_creation_failed", exc_info=True)
       raise HTTPException(500, detail="Internal server error")
```

**Mistake 4: status_code 누락**
```python
❌ Before:
   @app.post("/api/v1/users")  # 200 리턴
   async def create_user(...):

✅ After:
   @app.post("/api/v1/users", status_code=201)
   async def create_user(...):
```
```

**Section 5: Enforcement** (Line 181-220):
```markdown
## 5. Enforcement (Line 181-220)

### 5-1. OpenAPI Schema Validation

**자동 생성**:
```python
# FastAPI가 자동으로 /docs endpoint 생성
# http://localhost:8000/docs
```

**Schema export**:
```bash
# OpenAPI spec export
python scripts/export_openapi.py > openapi.json
```

**Validation** (CI):
```yaml
# .github/workflows/ci.yml
- name: OpenAPI Schema Diff
  run: |
    python scripts/export_openapi.py > openapi_new.json
    openapi-diff openapi_old.json openapi_new.json
```

### 5-2. Pydantic Validation (Runtime)

**자동 검증** (FastAPI가 자동으로 실행):
```python
class UserCreateRequest(BaseModel):
    email: EmailStr  # 자동 email validation
    password: str = Field(min_length=8)  # 자동 length validation

# Client가 잘못된 요청 보내면:
# → 422 Unprocessable Entity (자동)
```

### 5-3. PR Checklist

```markdown
## API Checklist
- [ ] Endpoint naming: /api/v1/{resource}
- [ ] Pydantic models for request/response
- [ ] status_code 명시 (201 for POST, 204 for DELETE)
- [ ] 민감 정보(password) response에 없음
- [ ] Error는 HTTPException 사용
- [ ] OpenAPI docs 확인 (/docs)
```

### 5-4. Manual Review

**리뷰 항목**:
1. API 설계 일관성 (naming, status codes)
2. Pydantic model 적절성
3. 민감 정보 노출 여부
4. Error handling 적절성

**리뷰 주기**: 새 endpoint 추가 시 (PR에서)
```

---

## 6. Progressive Accumulation 전략

### 6-1. 프로젝트 시작 시 (Week 1)

**Mandatory 5개 작성**:
```
PROJECT_STANDARDS/
├── 00_index.md (50 lines) - 초기 버전
├── 01_logging.md (150 lines) - ADR-015
├── 02_error_handling.md (180 lines) - ADR-020, ADR-021
├── 03_configuration.md (120 lines) - ADR-025
├── 04_type_hints.md (160 lines) - ADR-030
├── 05_testing.md (200 lines) - ADR-010, ADR-035
└── 99_common_mistakes.md (100 lines) - 초기 버전 (10개 실수)
```

**작성 우선순위**:
1. 01_logging.md - 모든 코드에 필요
2. 04_type_hints.md - mypy 설정 전 필요
3. 02_error_handling.md - Exception 패턴 통일
4. 05_testing.md - TDD 시작 전 필요
5. 03_configuration.md - 설정 관리 통일

### 6-2. API 개발 시작 (Week 2-3)

**Optional 추가**:
```
PROJECT_STANDARDS/
├── [기존 Mandatory 5개]
├── 07_api.md (200 lines) - NEW! ADR-025, ADR-045
└── 99_common_mistakes.md (150 lines) - 업데이트 (API 실수 추가)
```

**00_index.md 업데이트**:
```markdown
## Optional Standards (1)
- ✅ 07_api.md - FastAPI + OpenAPI (Added 2025-01-20)

## ADR → Standards Mapping
| ADR-025 | FastAPI + OpenAPI | 07_api.md 전체 | 2025-01-20 |
```

### 6-3. DB 연동 시작 (Week 3-4)

**Optional 추가**:
```
PROJECT_STANDARDS/
├── [기존 Mandatory 5개 + 07_api.md]
├── 06_database.md (180 lines) - NEW! ADR-040, ADR-041, ADR-042
└── 99_common_mistakes.md (180 lines) - 업데이트 (DB 실수 추가)
```

### 6-4. 인증 구현 (Week 4-5)

```
PROJECT_STANDARDS/
├── [기존 6개]
├── 08_authentication.md (150 lines) - NEW! ADR-050, ADR-051
└── 99_common_mistakes.md (200 lines) - 최종 (50개 실수)
```

### 6-5. Progressive Accumulation 원칙

**원칙 1: 필요한 시점에 추가**
- ❌ 프로젝트 시작 시 10개 파일 모두 작성
- ✅ Week 1: Mandatory 5개
- ✅ Week 2-3: API 시작하면 07_api.md
- ✅ Week 3-4: DB 시작하면 06_database.md

**원칙 2: 버전 관리**
```bash
# Week 1: Mandatory 5개
git tag standards-v1.0

# Week 2: API 추가
git tag standards-v1.1

# Week 4: DB + Auth 추가
git tag standards-v2.0
```

**원칙 3: 99_common_mistakes.md는 지속 업데이트**
- Week 1: 10개 실수
- Week 2: 20개 (API 실수 추가)
- Week 4: 30개 (DB 실수 추가)
- Month 2: 50개 (최종)

---

## 7. Standards 생명주기 관리

### 7-1. Standards 업데이트 트리거

**Trigger 1: ADR Accepted**
→ 새 Standard 파일 생성 또는 기존 파일에 Section 추가

**Trigger 2: ADR Superseded**
→ Standard 업데이트 (Before/After 표시)

**Trigger 3: 코드 리뷰에서 새로운 패턴 발견**
→ 99_common_mistakes.md 업데이트

**Trigger 4: 버그 발생**
→ Common Mistakes에 추가

### 7-2. ADR Accepted → Standards 생성

**Example**: ADR-055 (Redis caching) 승인

**Step 1**: 09_performance.md 생성
```markdown
# 09. Performance Standards

> **출처**: ADR-055 (Redis caching)
> **업데이트**: 2025-02-01

## 1. Caching Strategy (Line 1-40)
[Redis caching 규칙]

## 2. Cache Keys (Line 41-80)
[Key naming, TTL]

## 3. Cache Invalidation (Line 81-120)
[Invalidation 패턴]

## 4. Common Mistakes (Line 121-160)
[Caching 실수]

## 5. Enforcement (Line 161-200)
[Cache hit rate monitoring]
```

**Step 2**: 00_index.md 업데이트
```markdown
## Optional Standards (6)
- ✅ 09_performance.md - Redis caching (Added 2025-02-01)

## ADR → Standards Mapping
| ADR-055 | Redis caching | 09_performance.md | 2025-02-01 |
```

### 7-3. ADR Superseded → Standards 업데이트

**Example**: ADR-015 (structlog) → ADR-065 (Python logging)

**Step 1**: 01_logging.md 업데이트
```markdown
# 01. Logging Standards

> **출처**: ADR-065 (Python logging + JSON)
> **이전**: ADR-015 (structlog) - Superseded 2025-03-01

## Before/After (Migration Guide)

**Before** (ADR-015):
```python
from structlog import get_logger
logger = get_logger()
logger.info("user_login", user_id=user.id)
```

**After** (ADR-065):
```python
import logging
from pythonjsonlogger import jsonlogger

logger = logging.getLogger(__name__)
logger.info("user_login", extra={"user_id": user.id})
```

[나머지 섹션은 ADR-065 기준으로 업데이트]
```

**Step 2**: 00_index.md 업데이트
```markdown
| ADR-065 | Python logging | 01_logging.md 전체 (업데이트) | 2025-03-01 |
| ~~ADR-015~~ | ~~structlog~~ | ~~Superseded by ADR-065~~ | ~~2025-01-15~~ |
```

### 7-4. 새로운 패턴 발견 → 99_common_mistakes.md 업데이트

**Trigger**: 코드 리뷰에서 동일한 실수 3번 발견

**Step 1**: 실수 분석
```
User A: async 함수에서 sync DB 호출 → 블로킹
User B: 동일한 실수
User C: 동일한 실수
→ Common mistake!
```

**Step 2**: 99_common_mistakes.md에 추가
```markdown
# 99. Common Mistakes

## Category: Async/Await

**Mistake 15: async 함수에서 sync DB 호출** (Added 2025-02-15)
```python
❌ Before:
   async def get_user(user_id: int):
       user = session.query(User).filter_by(id=user_id).first()  # Blocking!
       return user

✅ After:
   async def get_user(user_id: int):
       async with async_session() as session:
           result = await session.execute(select(User).filter_by(id=user_id))
           return result.scalar_one_or_none()
```
**Why**: sync DB 호출은 event loop 블로킹
**출처**: 코드 리뷰 3건 (2025-02-10 ~ 2025-02-15)
```

---

## 8. 다음 단계 연결

### 8-1. 문서 흐름에서 Standards의 위치

```
ADR_GUIDE.md
    ↓ 결정 기록
Individual ADR documents
    ↓ 변환 (이 가이드!)
PROJECT_STANDARDS_GUIDE.md (이 문서)
    ↓ 표준 규칙
PROJECT_STANDARDS/ directory
    ↓ 적용
BLUEPRINT_GUIDE.md ← 다음 단계!
    ↓
TASK_BREAKDOWN_GUIDE.md
    ↓
CHECKLIST_GUIDE.md
```

### 8-2. 다음 단계: BLUEPRINT_GUIDE.md

**다음 가이드에서 배울 내용**:
1. ADR + Standards를 사용하여 Blueprint 작성
2. 기능 단위 명세 (30-50 lines per feature)
3. Level 3 구현 힌트 (40 lines 스켈레톤)
4. Blueprint 파일 분리 (500 lines per system)
5. Blueprint → Task 연결

**지금 PROJECT_STANDARDS_GUIDE.md에서 배운 것**:
- ✅ ADR → Standards 변환 절차
- ✅ Mandatory 5개 vs Optional standards
- ✅ Standards 파일 구조 (5개 섹션, Line 범위)
- ✅ Progressive accumulation 전략
- ✅ Standards 생명주기 관리

**Standards가 Blueprint에 어떻게 사용되나**:

**Blueprint 작성 시**:
```markdown
# blueprints/01_auth_system.md

## 2.1 JWT 토큰 생성 (Line 51-100)

**프로젝트 표준 적용**:
- 01_logging.md Line 31-60: Event format
- 02_error_handling.md Line 41-80: TokenGenerationError
- 04_type_hints.md Line 81-120: Pydantic for payload

**구현 힌트** (Level 3 스켈레톤):
```python
# 01_logging.md Line 31-60 적용
from structlog import get_logger
logger = get_logger()

# 04_type_hints.md Line 81-120 적용
from pydantic import BaseModel
class TokenPayload(BaseModel):
    user_id: int
    exp: datetime

def create_token(user_id: int) -> str:
    payload = TokenPayload(user_id=user_id, exp=...)
    secret_key = config.get_secret("JWT_SECRET_KEY")
    token = jwt.encode(payload.dict(), secret_key, algorithm="HS256")
    logger.info("token_generated", user_id=user_id)  # 01_logging.md
    return token
```

→ Blueprint는 Standards를 참조하여 작성됨!
```

**다음 가이드로 이동**: `BLUEPRINT_GUIDE.md`

---

## 부록: Quick Reference

### Standards 파일 템플릿

```markdown
# XX. [Standard Name]

> **출처**: ADR-XXX, ADR-YYY
> **업데이트**: YYYY-MM-DD

## 1. [Core Section 1] (Line 1-40)
**Mandatory**: [필수 import, 기본 패턴]

**Good Examples**:
```python
✅ [예시 코드]
```

**Bad Examples**:
```python
❌ [나쁜 예시]
```

**Forbidden**:
❌ [금지 사항]

**Why**: [이유]

---

## 2. [Core Section 2] (Line 41-80)
[상세 규칙, 고급 패턴]

---

## 3. [Core Section 3] (Line 81-120)
[특수 케이스, 예외 처리]

---

## 4. Common Mistakes (Line 121-160)

**Mistake 1: [실수 제목]**
```python
❌ Before: [나쁜 코드]
✅ After:  [좋은 코드]
```
**Why**: [이유]
**출처**: [ADR 또는 코드 리뷰]

[3-4개 더...]

---

## 5. Enforcement (Line 161-200)

### 5-1. Pre-commit Hook
[설정, 스크립트]

### 5-2. Ruff/Mypy Configuration
[pyproject.toml 설정]

### 5-3. CI Pipeline
[GitHub Actions]

### 5-4. Quality Gates
[Phase 5B 검증]

### 5-5. PR Checklist
[체크리스트 항목]

### 5-6. Manual Review
[리뷰 항목, 주기]
```

### ADR → Standards 체크리스트

ADR을 Standards로 변환할 때:

- [ ] Decision → Sections 1-3 매핑 완료
- [ ] Compliance → Section 5 매핑 완료
- [ ] Consequences (harder) → Section 4 매핑 완료
- [ ] 서술형 → 명령형 변환 완료
- [ ] Good/Bad 예시 각 3개 이상
- [ ] Line 범위 할당 (각 섹션 30-50 lines)
- [ ] 총 길이 150-200 lines
- [ ] Pre-commit hook 추가
- [ ] CI pipeline 추가
- [ ] Quality Gates 연결
- [ ] 00_index.md 업데이트

**모두 ✅면 완성!**

---

**이 가이드 완료!** 다음: `BLUEPRINT_GUIDE.md`


================================================================================
# End of 06G-00_project_standards_guide.md
================================================================================



================================================================================
# 📄 7. 07G-00_blueprint_guide.md
================================================================================

# Blueprint (청사진) 작성 가이드

> **목적**: Stage 7 - ADR과 프로젝트 표준을 바탕으로 전체 시스템 설계를 초상세하게 구체화
>
> **버전**: v2.0 (2025-11-12)
> - v2.0: Stage 7 범위 명시, 입력/출력 문서 추가

---

## 📥 입력 문서 (Stage 6에서 받은 것)

#### 1. **`06D-01_project_standards.md`** (필수)
- 프로젝트 표준 규칙
- **활용**: 청사진에 표준 반영

#### 2. **모든 ADR** (참고)
- DNA 시스템 ADR, Domain ADR
- **활용**: 결정의 근거 확인

#### 3. **Stage 2 산출물** (참고)
**위치**: `docs/stage2/02S-01_architecture_diagrams.md`, `02S-02_data_schema.md`, `02S-03_api_design.md`
- 아키텍처 다이어그램, 데이터 스키마, API 설계
- **활용**: 청사진 상세화의 시각적 기반
- **이유**: Stage 3-6은 텍스트 기반 결정 기록, 다이어그램과 상세 스키마는 Stage 2에만 존재

---

## 📤 출력 문서 (이 Stage에서 생성해야 할 문서)

### 필수 문서

#### 1. **`07B-01_project_blueprint.md`** - 프로젝트 청사진 (THE 산출물)
**내용**:
- 초상세 전체 시스템 청사진
- 도메인별 구현 가이드
- 모든 컴포넌트, API, 데이터 흐름

**구조**:
```markdown
# PROJECT BLUEPRINT

## 1. System Architecture
- 전체 시스템 구조
- 레이어별 구조
- 컴포넌트 다이어그램

## 2. Domain Structure
- 도메인 모델
- 도메인별 경계
- 도메인 간 관계

## 3. Data Layer
- 전체 데이터 스키마 (상세)
- 테이블 관계
- 인덱스 전략

## 4. API Layer
- 모든 엔드포인트 (상세)
- 요청/응답 스키마
- WebSocket 프로토콜

## 5. Domain Implementation Guides
### 5.1 Order Domain
- 구현해야 할 기능 목록
- 기술 스택 활용 방법
- 최신 기법 적용

### 5.2 Portfolio Domain
...
```

#### 2. **`07S-01_domain_diagrams/`** (선택적)
- 도메인별 상세 다이어그램

---

## 🔄 다음 Stage로 전달되는 것

Stage 7 → Stage 8:
- ✅ 초상세 청사진
- ✅ 도메인별 구현 가이드
- ✅ 모든 컴포넌트, API, 데이터 설계

Stage 8 (Task Breakdown)에서는:
- 청사진을 AI가 집중 구현할 크기로 분할
- 4시간 이내 완료 가능한 작업 단위

---

## 1. 개요

### 청사진이란?

**청사진 (Blueprint)**은 ADR (Architecture Decision Records)의 결정사항들을 구체적인 구현 설계로 풀어낸 문서입니다.

```
ADR들 (아키텍처 결정)
    ↓
청사진 (구체적 설계)
    ↓
작업분해 (Task 단위)
    ↓
체크리스트 (실행 단계)
```

### 청사진의 역할

**입력**:
- ADR 문서들: "왜" 이런 결정을 내렸는가
- 범용 표준 문서들: 프로젝트 전체 규칙
- 요구사항: 비즈니스 요구사항

**출력**:
- 구체적인 기능 목록 (100개 기능 → 100개 Task)
- 각 기능의 입출력, 제약조건, 아키텍처
- 기능 간 의존성 및 조립 순서

**청사진의 특징**:
- **"무엇을"에 집중**: 어떤 기능을 만들 것인가
- **"어떻게"는 최소**: 세부 구현은 Task에서
- **Line 단위로 명확히 구분**: 각 기능 30-50 lines
- **파일로 분리**: 각 파일 최대 1,500 lines 내외

---

## 2. 청사진 크기와 파일 분리 ⭐

### 2-1. 왜 5,000 lines인가?

```python
# 전체 시스템
기능_개수 = 100  # 중소규모 시스템
기능당_설명 = 50 lines  # 각 기능 상세 설명

총_크기 = 100 * 50 = 5,000 lines

# 예시
Auth 시스템: 10개 기능 × 50 lines = 500 lines
Payment 시스템: 15개 기능 × 50 lines = 750 lines
Notification 시스템: 8개 기능 × 50 lines = 400 lines
...
```

### 2-2. 파일 분리 전략 (필수!)

**❌ 단일 파일 (5,000 lines)**:
```
BLUEPRINT.md (5,000 lines)
→ 너무 길어서 관리 불가능
→ 어디에 뭐가 있는지 찾기 어려움
→ Git conflict 지옥
```

**✅ 시스템별 파일 분리** (각 500 lines):
```
blueprints/
├── 00_overview.md (200 lines)
│   ├── 전체 시스템 구조
│   ├── 기술 스택
│   ├── 표준 문서 목록
│   └── 파일 인덱스
│
├── 01_auth_system.md (500 lines)
│   ├── Line 1-50: 개요
│   ├── Line 51-150: JWT 토큰 관리 (3개 기능)
│   ├── Line 151-250: 인증 엔드포인트 (3개 기능)
│   ├── Line 251-350: 권한 관리 (3개 기능)
│   └── Line 351-500: 세션 관리 (2개 기능)
│
├── 02_payment_system.md (750 lines)
│   ├── Line 1-50: 개요
│   ├── Line 51-200: 결제 처리 (4개 기능)
│   ├── Line 201-400: PG 연동 (5개 기능)
│   ├── Line 401-600: 환불 처리 (4개 기능)
│   └── Line 601-750: 정산 (2개 기능)
│
├── 03_notification_system.md (400 lines)
├── 04_user_management.md (600 lines)
├── 05_admin_panel.md (550 lines)
...
```

**파일 분리 기준**:
- 시스템별 (Auth, Payment, Notification 등)
- 각 파일 최대 1,500 lines, 평균 1,000 lines
- 한 파일 = 하나의 bounded context
- Git conflict 최소화

---

## 3. 청사진 문서 구조

### 3-1. Overview 파일 (필수)

```markdown
# blueprints/00_overview.md

## 1. 프로젝트 개요
- 프로젝트명: E-Commerce Platform
- 목적: B2C 온라인 쇼핑몰
- 규모: 중규모 (예상 100개 Task)

## 2. 전체 시스템 구조

### 2.1 시스템 목록
1. **Auth System** (01_auth_system.md)
   - 사용자 인증/인가
   - 11개 기능, 500 lines

2. **Payment System** (02_payment_system.md)
   - 결제 처리
   - 15개 기능, 750 lines

3. **Notification System** (03_notification_system.md)
   - 알림 발송
   - 8개 기능, 400 lines

...

## 3. 기술 스택

### 3.1 Backend
- **언어**: Python 3.11+
- **프레임워크**: FastAPI
- **DB**: PostgreSQL 15
- **캐시**: Redis 7
- **메시지큐**: RabbitMQ

### 3.2 라이브러리 (주요)
- **인증**: PyJWT
- **DB ORM**: SQLAlchemy 2.0
- **로깅**: structlog
- **설정**: pydantic-settings
- **테스트**: pytest

## 4. 표준 문서 참조

### 4.1 프로젝트 표준
- `standards/01_logging.md` - structlog 로깅 패턴
- `standards/02_configuration.md` - Pydantic 설정 관리
- `standards/03_error_handling.md` - 에러 처리 규칙
- `standards/04_database.md` - DB 접근 패턴
- `standards/05_architecture.md` - 계층 구조 규칙

### 4.2 ADR (Architecture Decision Records)
- `adr/001_use_fastapi.md` - FastAPI 선택 이유
- `adr/002_postgres_over_mysql.md` - PostgreSQL 선택
- `adr/003_jwt_authentication.md` - JWT 인증 방식
- `adr/004_hexagonal_architecture.md` - 헥사고날 아키텍처

## 5. 파일 인덱스

| 파일 | 시스템 | 기능 수 | Lines |
|------|--------|---------|-------|
| 01_auth_system.md | 인증/인가 | 11 | 500 |
| 02_payment_system.md | 결제 | 15 | 750 |
| 03_notification_system.md | 알림 | 8 | 400 |
| 04_user_management.md | 사용자 관리 | 12 | 600 |
| 05_admin_panel.md | 관리자 패널 | 10 | 550 |
| ... | ... | ... | ... |
| **총합** | - | **100** | **5,200** |
```

---

### 3-2. 시스템별 파일 구조

각 시스템 파일 (예: `01_auth_system.md`)은 다음 구조를 따릅니다:

```markdown
# Auth System Blueprint

## 1. 시스템 개요 (Line 1-50)

### 목적
사용자 인증 및 인가 시스템 구현

### 포함 기능 (11개)
1. JWT 토큰 생성 (Line 51-100)
2. JWT 토큰 검증 (Line 101-150)
3. JWT 토큰 갱신 (Line 151-200)
4. Login 엔드포인트 (Line 201-250)
5. Logout 엔드포인트 (Line 251-300)
6. Refresh 엔드포인트 (Line 301-350)
7. 비밀번호 해싱 (Line 351-400)
8. Redis 세션 관리 (Line 401-450)
9. 권한 검증 미들웨어 (Line 451-500)
...

### 의존성
- **선행 시스템**: 없음 (독립 시스템)
- **후속 시스템**: 모든 보호된 API (이 시스템 사용)

### 관련 ADR
- `adr/003_jwt_authentication.md`
- `adr/005_redis_session_store.md`

### 관련 표준
- `standards/01_logging.md` Line 12-25 (로깅)
- `standards/02_configuration.md` Line 30-45 (설정)
- `standards/03_error_handling.md` Line 50-68 (에러)

---

## 2. 기능 상세 설명

### 2.1 JWT 토큰 생성 (Line 51-100)

**기능 ID**: F-AUTH-001

**목적**: 사용자 인증 성공 시 JWT access token 생성

**입력**:
- `user_id: str` - 사용자 고유 ID (UUID)
- `user_role: str` - 사용자 권한 (admin/user/guest)

**출력**:
- `token: str` - JWT access token (HS256 알고리즘)
- TTL: 1시간 (3600초)

**아키텍처**:
- **위치**: `src/auth/token_generator.py`
- **인터페이스**: `ITokenGenerator` 구현
- **계층**: Domain Layer (Infrastructure 의존 금지)

**기술 제약**:
- HS256 알고리즘 사용 (adr/003 참조)
- Payload 구조: `{user_id, user_role, exp, iat, jti}`
- Secret Key는 `config.get_secret("JWT_SECRET_KEY")` 사용
- 모든 토큰 생성 이벤트 structlog로 로깅

**연관 기능**:
- **사용처**: F-AUTH-004 (Login), F-AUTH-006 (Refresh)
- **의존**: 없음 (독립 기능)

**완성 기준**:
- [ ] `create_token(user_id, user_role)` 함수 작동
- [ ] 생성된 토큰이 유효한 JWT 형식
- [ ] Payload에 5개 필드 모두 포함
- [ ] TTL 정확히 1시간
- [ ] pytest 테스트 5개 통과
- [ ] structlog로 이벤트 기록
- [ ] ruff 0, mypy 0, import-linter 0

**구현 힌트 (스켈레톤)**:
```python
import jwt
from datetime import datetime, timedelta
from uuid import uuid4

def create_token(user_id: str, user_role: str) -> str:
    """JWT access token 생성."""
    payload = {
        "user_id": user_id,
        "user_role": user_role,
        "exp": datetime.utcnow() + timedelta(hours=1),
        "iat": datetime.utcnow(),
        "jti": str(uuid4())
    }

    secret_key = config.get_secret("JWT_SECRET_KEY")
    token = jwt.encode(payload, secret_key, algorithm="HS256")

    logger.info("token_generated", user_id=user_id, jti=payload["jti"])

    return token
```

**예상 작업 시간**: 2-3 hours

**우선순위**: High (다른 기능의 의존성)

---

### 2.2 JWT 토큰 검증 (Line 101-150)

**기능 ID**: F-AUTH-002

**목적**: 요청된 JWT 토큰의 유효성 검증

**입력**:
- `token: str` - JWT access token

**출력**:
- `payload: dict` - 검증된 payload
- OR `None` - 유효하지 않은 경우

**아키텍처**:
- **위치**: `src/auth/token_validator.py`
- **인터페이스**: `ITokenValidator` 구현
- **계층**: Domain Layer

**기술 제약**:
- 만료 시간 검증 필수
- 알고리즘 검증 (HS256만 허용)
- Secret Key 일치 확인
- 에러 발생 시 None 반환 (예외 던지지 않음)

**연관 기능**:
- **사용처**: F-AUTH-005 (Logout), F-AUTH-006 (Refresh), 모든 보호된 API
- **의존**: 없음

**완성 기준**:
- [ ] 유효한 토큰 → payload 반환
- [ ] 만료된 토큰 → None 반환
- [ ] 잘못된 signature → None 반환
- [ ] 잘못된 알고리즘 → None 반환
- [ ] pytest 테스트 6개 통과

**구현 힌트**:
```python
import jwt

def validate_token(token: str) -> dict | None:
    """JWT 토큰 검증."""
    try:
        secret_key = config.get_secret("JWT_SECRET_KEY")
        payload = jwt.decode(
            token,
            secret_key,
            algorithms=["HS256"]
        )
        return payload
    except jwt.ExpiredSignatureError:
        logger.warning("token_expired")
        return None
    except jwt.InvalidSignatureError:
        logger.warning("token_invalid_signature")
        return None
    except Exception as e:
        logger.error("token_validation_error", error=str(e))
        return None
```

**예상 작업 시간**: 2 hours

**우선순위**: High

---

### 2.3 JWT 토큰 갱신 (Line 151-200)

(계속해서 각 기능을 30-50 lines씩 설명)

---

... (중략)

---

## 3. 시스템 간 의존성

### 3.1 의존성 그래프

```
Auth System (독립)
    ↓ (사용)
User Management System
Payment System
Notification System
Admin Panel
    ↓ (사용)
...
```

### 3.2 구현 순서

**Phase 1: 기반 시스템** (병렬 가능)
1. Auth System (01_auth_system.md)
2. User Management (04_user_management.md)

**Phase 2: 핵심 비즈니스** (순차)
3. Payment System (02_payment_system.md)
4. Notification System (03_notification_system.md)

**Phase 3: 부가 기능** (병렬 가능)
5. Admin Panel (05_admin_panel.md)
...

---

## 4. 품질 기준 (전체 시스템)

### 4.1 코드 품질
- ruff check: 0 violations
- mypy --strict: 0 errors
- import-linter: 0 violations
- pytest coverage: 95%+ (unit), 85%+ (integration)

### 4.2 성능
- API 응답 시간: < 200ms (p95)
- DB 쿼리: < 50ms (p95)
- 동시 사용자: 1,000명 지원

### 4.3 보안
- OWASP Top 10 대응
- SQL Injection 방지 (ORM 사용)
- XSS 방지 (입력 sanitization)
- CSRF 방지 (token 사용)
```

---

## 4. 기능 설명 템플릿

각 기능은 다음 항목들을 포함합니다 (30-50 lines):

```markdown
### {기능 번호}. {기능명} (Line {시작}-{끝})

**기능 ID**: F-{SYSTEM}-{NUMBER}

**목적**: {한 줄 설명}

**입력**:
- `{param}: {type}` - {설명}

**출력**:
- `{return}: {type}` - {설명}

**아키텍처**:
- **위치**: `{파일 경로}`
- **인터페이스**: `{인터페이스명}` 구현
- **계층**: {Domain/Application/Infrastructure} Layer

**기술 제약**:
- {제약사항 1}
- {제약사항 2}

**연관 기능**:
- **사용처**: {이 기능을 사용하는 기능들}
- **의존**: {이 기능이 의존하는 기능들}

**완성 기준**:
- [ ] {기준 1}
- [ ] {기준 2}

**구현 힌트 (스켈레톤)**:
```python
{핵심 로직 구조 - 40 lines}
```

**예상 작업 시간**: {시간}

**우선순위**: {High/Medium/Low}
```

---

## 5. 청사진 작성 절차

### 5-1. ADR에서 결정사항 추출

```markdown
# 예시: adr/003_jwt_authentication.md 읽기

결정사항:
- HS256 알고리즘 사용 (대칭키, 빠름)
- Access token TTL: 1시간
- Refresh token TTL: 7일
- Payload: user_id, user_role, exp, iat, jti

→ 청사진 F-AUTH-001에 반영
  - 알고리즘: HS256
  - TTL: 1시간
  - Payload 구조: 정확히 5개 필드
```

### 5-2. 범용 표준에서 규칙 참조

```markdown
# standards/01_logging.md 읽기

규칙:
- 모든 중요 이벤트 structlog 로깅
- logger.info("event_name", key=value) 형식

→ 청사진 F-AUTH-001에 반영
  - "모든 토큰 생성 이벤트 structlog로 로깅"
  - 구현 힌트에 logger.info("token_generated", ...) 포함
```

### 5-3. 기능 목록 작성

```markdown
1. 전체 시스템 기능 나열 (100개)
2. 시스템별로 그룹화 (Auth: 11개, Payment: 15개...)
3. 각 기능에 ID 부여 (F-AUTH-001, F-PAY-001...)
4. 의존성 파악 (어느 기능이 어느 기능을 사용?)
5. 구현 순서 결정 (의존성 기반)
```

### 5-4. 각 기능 상세화 (템플릿 사용)

```markdown
기능당 30-50 lines:
1. 기능 ID, 목적
2. 입출력 명세
3. 아키텍처 (위치, 계층)
4. 기술 제약 (ADR 반영)
5. 연관 기능 (의존성)
6. 완성 기준 (검증 가능하게)
7. 구현 힌트 (스켈레톤 40 lines)
8. 예상 시간, 우선순위
```

### 5-5. 파일로 분리 및 인덱스 작성

```markdown
1. 시스템별로 파일 분리 (각 500 lines)
2. 00_overview.md에 전체 인덱스 작성
3. 각 파일 상단에 Line 인덱스 작성
4. 크로스 레퍼런스 (F-AUTH-001 → F-AUTH-004 사용)
```

---

## 6. 청사진 작성 시 주의사항

### 6-1. "무엇을" vs "어떻게"

**✅ 청사진에 포함** ("무엇을"):
- 기능의 목적과 입출력
- 아키텍처 제약 (어느 계층, 어느 파일)
- 기술 제약 (HS256, 1시간 TTL 등)
- 구현 힌트 스켈레톤 (40 lines)

**❌ 청사진에 포함 안 함** ("어떻게"):
- 전체 구현 코드 (200+ lines)
- 모든 에러 처리 로직
- 세밀한 validation 로직
- 엣지 케이스 처리

**이유**:
- 청사진 = 설계 문서
- 세부 구현 = Task 문서 + Checklist

### 6-2. Line 참조 가능성

```markdown
✅ 좋은 예:
### 2.1 JWT 토큰 생성 (Line 51-100)
(정확히 50 lines 사용)

### 2.2 JWT 토큰 검증 (Line 101-150)
(정확히 50 lines 사용)

→ Task 작성자가 "Line 51-100만 읽어"라고 명확히 참조 가능

❌ 나쁜 예:
### 2.1 JWT 토큰 생성
(Line 번호 없음, 길이 불명확)

→ Task 작성자가 어디부터 어디까지 읽어야 할지 모름
```

### 6-3. 파일 크기 적정성

```markdown
✅ 적정 크기:
01_auth_system.md (500 lines)
- 11개 기능 × 45 lines = 495 lines
- 관리 가능, Line 참조 쉬움

❌ 너무 큼:
01_auth_system.md (2,000 lines)
- Line 참조 어려움
- Git conflict 위험
- 파일 열기 느림

❌ 너무 작음:
01_jwt_token_generation.md (50 lines)
- 파일 개수 너무 많음 (100개 기능 = 100개 파일?)
- 관리 복잡
```

**권장**: 파일당 200-800 lines (평균 500 lines)

### 6-4. 스켈레톤 수준 유지

```markdown
✅ Level 3 스켈레톤 (40 lines):
def create_token(user_id: str, user_role: str) -> str:
    payload = {
        "user_id": user_id,
        "user_role": user_role,
        "exp": datetime.utcnow() + timedelta(hours=1),
        "iat": datetime.utcnow(),
        "jti": str(uuid4())
    }
    token = jwt.encode(payload, secret_key, algorithm="HS256")
    logger.info("token_generated", user_id=user_id)
    return token

→ 구조 명확, 세부사항은 Task에서

❌ Level 4 전체 구현 (200+ lines):
def create_token(user_id: str, user_role: str) -> str:
    try:
        if not user_id:
            raise ValueError(...)
        if not isinstance(user_id, str):
            raise TypeError(...)
        # ... 100+ lines validation
        # ... 50+ lines error handling
    except Exception as e:
        # ... 50+ lines exception handling

→ 청사진이 아니라 구현 코드!
```

---

## 7. 청사진 검증 체크리스트

### 파일 구조 검증
- [ ] 00_overview.md 파일 존재 (전체 인덱스)
- [ ] 시스템별로 파일 분리 (각 200-800 lines)
- [ ] 파일명이 일관성 있음 (01_*, 02_*, ...)
- [ ] 각 파일 상단에 기능 목록 (Line 인덱스)

### 기능 설명 검증
- [ ] 모든 기능이 템플릿 준수
- [ ] 각 기능 30-50 lines
- [ ] Line 번호가 정확 (Line 51-100, Line 101-150 ...)
- [ ] 기능 ID 부여 (F-{SYSTEM}-{NUMBER})

### 입출력 명세 검증
- [ ] 모든 입력 파라미터 타입 명시
- [ ] 모든 출력 타입 명시
- [ ] 엣지 케이스 (None, 빈 값 등) 처리 명시

### 아키텍처 검증
- [ ] 모든 기능의 파일 위치 명시
- [ ] 계층 (Domain/Application/Infrastructure) 명시
- [ ] 인터페이스 정의 여부 명시

### 기술 제약 검증
- [ ] ADR 결정사항 반영
- [ ] 범용 표준 규칙 반영
- [ ] 구체적인 제약 (알고리즘, TTL 등) 명시

### 의존성 검증
- [ ] "사용처" 명시 (어느 기능이 이걸 사용?)
- [ ] "의존" 명시 (이 기능이 뭘 사용?)
- [ ] 순환 의존 없음
- [ ] 구현 순서 명시 (Phase 1, 2, 3...)

### 완성 기준 검증
- [ ] 체크 가능한 기준
- [ ] 숫자로 표현 (테스트 3개, coverage 95%+)
- [ ] 품질 기준 명시 (ruff 0, mypy 0)

### 구현 힌트 검증
- [ ] Level 3 스켈레톤 (40 lines)
- [ ] 실행 가능한 수준
- [ ] DNA 시스템 환경 사용 (core.*)
- [ ] 전체 코드 아님 (에러 처리 등 제외)

### 전체 완성도 검증
- [ ] 모든 비즈니스 요구사항이 기능으로 분해됨
- [ ] 누락된 기능 없음
- [ ] 총 기능 수가 적정 (50-150개)
- [ ] 총 크기가 적정 (3,000-8,000 lines)

---

## 8. 청사진 → Task 문서 변환 예시

### 청사진 (F-AUTH-001, Line 51-100)

```markdown
### 2.1 JWT 토큰 생성 (Line 51-100)

**기능 ID**: F-AUTH-001
**목적**: 사용자 인증 성공 시 JWT access token 생성
**입력**: user_id: str, user_role: str
**출력**: token: str (JWT, HS256, 1시간 TTL)

**아키텍처**:
- 위치: src/auth/token_generator.py
- 인터페이스: ITokenGenerator
- 계층: Domain Layer

**기술 제약**:
- HS256 알고리즘
- Payload: {user_id, user_role, exp, iat, jti}
- Secret Key: config.get_secret("JWT_SECRET_KEY")
- structlog 로깅

**연관 기능**:
- 사용처: F-AUTH-004, F-AUTH-006
- 의존: 없음

**완성 기준**:
- [ ] create_token() 함수 작동
- [ ] 유효한 JWT 형식
- [ ] pytest 5개 통과
- [ ] ruff 0, mypy 0

**구현 힌트**: (40 lines 스켈레톤)
...
```

### → Task 문서 (T2.1.1)

```markdown
# Task T2.1.1: JWT 토큰 생성 모듈

## 1. 청사진 참조
**blueprints/01_auth_system.md Line 51-100**: F-AUTH-001

핵심 내용:
- HS256 알고리즘
- Payload 5개 필드
- 1시간 TTL

## 2. 프로젝트 표준 참조 (필터링됨)

#### 로깅 (standards/01_logging.md Line 12-25)
- logger.info("event_name", key=value) 형식
- print() 금지

#### 설정 (standards/02_configuration.md Line 30-45)
- config.get_secret("KEY_NAME") 사용

## 3. 사용 도구
- PyJWT
- structlog
- pytest

## 4. 입출력
**입력**: user_id: str, user_role: str
**출력**: token: str

## 5. 조립 정보
**사용처**: T2.2.1 (Login), T2.2.3 (Refresh)
**의존**: 없음

## 6. 완성 기준 + 자주 하는 실수
(청사진 완성 기준 + 실수 패턴 추가)

## 7. 구현 힌트
(청사진 스켈레톤 그대로 복사)

## 8. 예상 시간
2-3 hours

## 9. 메타정보
- 우선순위: High
- 태그: #auth #jwt
```

**핵심**:
- 청사진 Line 51-100 (50 lines) → Task 문서 (150 lines)
- 청사진 내용 + 필터링된 표준 + 실수 패턴
- "Necessary Information Only" 원칙

---

## 9. 실전 팁

### 9-1. 점진적 작성

```markdown
❌ 한 번에 5,000 lines 작성
→ 압도적, 실수 많음, 수정 어려움

✅ 시스템 단위로 점진적 작성:
1. 00_overview.md 작성 (200 lines)
2. 01_auth_system.md 작성 (500 lines)
   - 실제 Task 1개 만들어보기
   - 피드백 반영
3. 02_payment_system.md 작성 (750 lines)
   - 반복
4. ...
```

### 9-2. 팀 협업

```markdown
시스템별로 담당자 분리:
- Alice: Auth System (01_auth_system.md)
- Bob: Payment System (02_payment_system.md)
- Charlie: Notification (03_notification_system.md)

병렬 작업 가능!
Git conflict 최소 (파일 분리됨)
```

### 9-3. 문서 유지보수

```markdown
기능 추가 시:
1. 해당 시스템 파일 열기
2. 새 기능 추가 (30-50 lines)
3. Line 인덱스 업데이트
4. 00_overview.md 인덱스 업데이트

기능 삭제 시:
1. 해당 기능 섹션 삭제
2. 연관 기능의 "사용처" 업데이트
3. Line 인덱스 재정렬
```

---

## 10. 참고

- **이전 단계**: ADR 작성 → 아키텍처 결정
- **다음 단계**: [TASK_BREAKDOWN_GUIDE.md](./TASK_BREAKDOWN_GUIDE.md) - 청사진 → Task 분해
- **관련 문서**: [CORE_METHODOLOGY.md](./CORE_METHODOLOGY.md) Stage 4

---

**핵심 원칙 요약**:
- ✅ **파일 분리**: 시스템별 200-800 lines
- ✅ **Line 참조**: 각 기능 30-50 lines, 정확한 Line 번호
- ✅ **스켈레톤 수준**: Level 3 (40 lines), 전체 코드 아님
- ✅ **"무엇을" 집중**: 세부 "어떻게"는 Task에서
- ✅ **ADR 반영**: 모든 기술 결정 추적 가능
- ✅ **범용 표준 참조**: 어느 표준 어느 부분 사용할지 명시

Happy blueprinting! 🏗️


================================================================================
# End of 07G-00_blueprint_guide.md
================================================================================



================================================================================
# 📄 8. 08G-00_task_breakdown_guide.md
================================================================================

# Task Breakdown 작성 가이드

> **목적**: Stage 8 - Blueprint(초상세)를 AI가 집중 구현 가능한 Task 단위로 분해
>
> **버전**: v2.0 (2025-11-12)
> - v2.0: Stage 8 범위 명시, 입력/출력 문서 추가

---

## 📥 입력 문서 (Stage 7에서 받은 것)

#### 1. **`07B-01_project_blueprint.md`** (필수)
- 초상세 프로젝트 청사진 (수천 줄)
- **활용**: 작업 분해의 기반

#### 2. **`06D-01_project_standards.md`** (참고)
- 프로젝트 표준
- **활용**: 작업별 표준 반영

---

## 📤 출력 문서 (이 Stage에서 생성해야 할 문서)

### 필수 문서

#### 1. **`08T-01_task_breakdown.md`** - 작업 분해 (THE 산출물)
**내용**:
- AI가 4시간 이내 완료 가능한 작업 단위
- 독립적으로 테스트 가능
- Necessary Information Only

**구조**:
```markdown
# TASK BREAKDOWN

## Task 001: Order Entity 구현
**목표**: Order 엔티티 클래스 및 DB 모델 구현
**예상 시간**: 2-3시간
**의존성**: 없음

### 입력
- ADR-116: Order Schema Design
- 표준: Naming, Validation 규칙

### 출력
- `src/domains/order/models.py`
- 단위 테스트 (95%+ 커버리지)

### 제약
- MUST use Pydantic BaseModel
- UUID for primary key

### 참고
- Blueprint Section 3.2

---

## Task 002: Order Repository 구현
**목표**: Order CRUD 작업
**예상 시간**: 3-4시간
**의존성**: Task 001

...
```

**특징**:
- 1개 Task = 1개 파일 또는 1개 기능
- 4시간 이내 완료 크기
- 독립 테스트 가능
- 명확한 입력/출력

---

## 🔄 다음 Stage로 전달되는 것

Stage 8 → Stage 9:
- ✅ 작업 목록 (Task 001~N)
- ✅ 각 작업의 목표, 시간, 의존성
- ✅ 우선순위

Stage 9 (Checklist)에서는:
- 각 Task마다 TDD 9-Step 체크리스트 생성
- 단계별 실행 가이드

---

## 1. 개요

### 왜 작업분해가 필요한가?

```python
# 문제
Blueprint = 5000줄  # AI가 한 번에 처리 불가
→ 컨텍스트 초과, 집중력 저하, 실수 증가

# 해결
Task = 100줄씩 분해  # AI가 처리 가능한 단위
→ 명확한 집중, 높은 품질, 검증 가능
```

### 작업분해의 목표

1. **정보 압축**: Blueprint 5000줄 → Task 100줄씩
2. **Necessary Information Only**: 이 Task에 필요한 것만
3. **완전한 레고블럭**: 독립적으로 테스트 가능한 기능 단위

### 두 가지 완성 조건

**일관성 (Consistency)**:
- 모든 Task가 같은 도구 사용 (DNA 시스템 환경 기반)
- 모든 Task가 같은 패턴 따름
- 모든 Task가 같은 표준 준수

**누락없음 (No Omissions)**:
- Blueprint의 모든 기능이 Task로 분해됨
- Task 목록 = Blueprint 기능 목록
- 빠진 Task 없음

---

## 2. Task 분할 방식 선택 ⭐

### Case 1: 모듈화 분할 (수평 분할)

**특징**: 재사용 가능한 독립 모듈을 먼저 만들고, 나중에 조립

**언제 사용**:
- ✅ 재사용성이 높은 경우
- ✅ 복잡한 로직
- ✅ 팀 협업 (여러 사람이 동시 작업)

**예시: Auth 시스템**
```
Task T2.1.1: JWT 생성 모듈 (create_token)
  → 입력: user_id
  → 출력: token
  → 의존성: 없음 (독립 모듈)

Task T2.1.2: JWT 검증 모듈 (validate_token)
  → 입력: token
  → 출력: user_id or None
  → 의존성: 없음 (독립 모듈)

Task T2.2.1: Login 엔드포인트
  → 입력: email, password
  → 출력: token
  → 의존성: T2.1.1 (create_token 사용)

Task T2.2.2: Logout 엔드포인트
  → 의존성: T2.1.2 (validate_token 사용)

Task T2.2.3: Refresh 엔드포인트
  → 의존성: T2.1.1, T2.1.2 (둘 다 사용)
```

**장점**:
- 모듈 재사용 가능
- 병렬 작업 가능 (T2.1.1과 T2.1.2를 동시에)
- 테스트 독립적

**단점**:
- 초기 설계 복잡
- 조립 단계 필요

---

### Case 2: 단계별 구현 (수직 분할)

**특징**: 전체 기능을 하나씩 완성

**언제 사용**:
- ✅ 빠른 배포 필요
- ✅ 단순한 기능
- ✅ 학습 곡선 (새로운 기술 학습 중)

**예시: Auth 시스템**
```
Task T2.1.1: Login 기능 전체
  → JWT 생성 로직 포함
  → JWT 검증 로직 포함
  → Login 엔드포인트 완성
  → ✅ Login 완전 작동!

Task T2.2.1: Logout 기능 전체
  → JWT 검증 로직 재구현 (또는 복사)
  → Logout 엔드포인트 완성
  → ✅ Logout 완전 작동!

Task T2.3.1: Refresh 기능 전체
  → JWT 검증 + 생성 로직 재구현
  → Refresh 엔드포인트 완성
  → ✅ Refresh 완전 작동!
```

**장점**:
- 빠른 결과 확인
- 각 기능이 완전히 작동
- 간단한 구조

**단점**:
- 코드 중복 가능
- 병렬 작업 어려움

---

### 분할 방식 선택 가이드

```
┌─ 재사용성이 높은가?
│  ├─ Yes → Case 1 (모듈화)
│  └─ No
│      └─ 빠른 배포가 중요한가?
│          ├─ Yes → Case 2 (단계별)
│          └─ No
│              └─ 복잡도가 높은가?
│                  ├─ Yes → Case 1 (모듈화)
│                  └─ No → Case 2 (단계별)
```

**실용적 판단 기준**:
- **5회 이상 재사용** 예상 → Case 1
- **2-3회 재사용** → Case 2 (나중에 리팩토링)
- **1회만 사용** → Case 2

---

## 3. Task 나누기 4가지 질문

### Q1: 200K 컨텍스트로 가능한가?

**체크 항목**:
```python
컨텍스트_사용량 = {
    "Task 문서": "~100줄 (2K 토큰)",
    "Blueprint 참조": "~30줄 (0.6K 토큰)",
    "Standards 참조": "~50줄 (1K 토큰)",
    "구현 코드": "~200줄 (4K 토큰)",
    "테스트 코드": "~150줄 (3K 토큰)",
    "총합": "~10K 토큰"
}

# ✅ 200K 중 10K → 안전
```

**너무 큰 Task 신호**:
- Blueprint 참조가 100줄 이상
- 구현 코드 예상이 500줄 이상
- 3개 이상의 표준 문서 참조

→ **해결**: Task를 2-3개로 분할

---

### Q2: 이 Task만으로 의미있는 기능인가?

**✅ 의미있는 Task**:
```python
# Task T2.1.1: JWT 생성 모듈
def create_token(user_id: str) -> str:
    """JWT 액세스 토큰 생성"""
    # ✅ 완전히 작동
    # ✅ 단독 테스트 가능
    # ✅ 의존성 없음
    return token
```

**❌ 의미없는 Task**:
```python
# Task X: User 클래스 정의만
class User:
    id: str
    email: str
    # ❌ 동작하지 않음
    # ❌ 테스트 불가능
    # ❌ 불완전한 블럭
```

**판단 기준**:
- 이 Task가 완료되면 무언가가 **작동**하는가?
- 단독으로 **테스트**할 수 있는가?
- 명확한 **입력/출력**이 있는가?

---

### Q3: 다른 Task와 일관성이 있나?

**체크 항목**:

**도구 일관성**:
```python
# ✅ 모든 Task가 같은 도구
Task T2.1.1: structlog, Pydantic, pytest
Task T2.2.1: structlog, Pydantic, pytest
Task T2.3.1: structlog, Pydantic, pytest

# ❌ Task마다 다른 도구
Task T2.1.1: structlog
Task T2.2.1: logging  # ❌ 다름!
Task T2.3.1: print()  # ❌ 완전히 다름!
```

**패턴 일관성**:
- 모든 API는 FastAPI + Pydantic
- 모든 설정은 pydantic-settings
- 모든 테스트는 Given-When-Then

**DNA 시스템 환경 기반**:
```python
# ✅ DNA 시스템 환경 사용
from core.logging import get_logger
from core.config import settings

# ❌ 커스텀 구현
import logging  # DNA 시스템에 없음!
```

---

### Q4: 청사진에서 누락된 Task는 없나?

**검증 방법**:

**1. Blueprint 기능 목록 추출**:
```markdown
# Blueprint: Auth 시스템
1. JWT 토큰 생성
2. JWT 토큰 검증
3. Login 엔드포인트
4. Logout 엔드포인트
5. Refresh 엔드포인트
6. 비밀번호 해싱
7. Redis 세션 관리
```

**2. Task 목록과 비교**:
```markdown
# Task 목록
✅ T2.1.1: JWT 생성
✅ T2.1.2: JWT 검증
✅ T2.2.1: Login 엔드포인트
✅ T2.2.2: Logout 엔드포인트
✅ T2.2.3: Refresh 엔드포인트
❌ 비밀번호 해싱 → 누락!
❌ Redis 세션 관리 → 누락!
```

**3. 누락 Task 추가**:
```markdown
추가:
- T2.1.3: 비밀번호 해싱 모듈
- T2.1.4: Redis 세션 관리 모듈
```

---

## 4. Task 문서 9-Section 템플릿

### 템플릿 구조

```markdown
# Task T{domain}.{module}.{number}: {Task 이름}

## 1. 📘 청사진 참조
**Blueprint Line {start}-{end}**: {참조 내용 요약}

## 2. 📋 프로젝트 표준 참조
**PROJECT_STANDARDS.md Line {start}-{end}**: {참조 표준}
**ARCHITECTURE.md Line {start}-{end}**: {참조 아키텍처}

## 3. 🔧 사용 도구
- **{도구명}**: {용도}

## 4. 📦 입력/출력
**입력**: {타입} - {설명}
**출력**: {타입} - {설명}

## 5. 🔗 조립 정보
**이 블럭을 사용하는 Task**: T{x.x.x}
**이 블럭이 사용하는 Task**: T{a.a.a} (또는 "없음")

## 6. 🎯 완성 기준
- [ ] {기능 동작 확인}
- [ ] {테스트 통과}

## 7. 💡 구현 힌트
```python
{실제 코드 예시}
```

## 8. ⏱️ 예상 작업 시간
총 예상: {시간}

## 9. 📌 메타정보
- 우선순위: {High/Medium/Low}
- 의존성: {선행 Task}
```

---

### 각 섹션 작성 가이드

#### Section 1: 청사진 참조

**목적**: Necessary Information Only - 이 Task에 필요한 Blueprint 부분만

**작성법**:
```markdown
## 1. 📘 청사진 참조
**Blueprint Line 145-178**: JWT 알고리즘 및 토큰 구조

핵심 내용:
- HS256 알고리즘 사용
- Payload: {user_id, exp, iat}
- TTL: 1시간 (3600초)
```

**주의**:
- ❌ Blueprint 전체 링크만 제공
- ✅ 정확한 Line 번호 + 핵심 내용 요약

---

#### Section 2: 프로젝트 표준 참조

**목적**: DNA 시스템 환경의 어떤 부분을 사용하는가

**핵심**: 800 lines 전체가 아닌, "이 Task 관련" 부분만 필터링!

**작성법**:
```markdown
## 2. 📋 프로젝트 표준 참조 (이 Task 관련만!)

#### 로깅 (standards/01_logging.md Line 12-25)
- `logger.info("event_name", key=value)` 형식 사용
- `print()` 절대 금지
- 모든 주요 작업 (생성, 수정, 삭제) 로깅 필수
- 에러는 `logger.error()` 또는 `logger.exception()` 사용

#### 설정 (standards/02_configuration.md Line 30-45)
- 모든 SECRET은 `config.get_secret("KEY_NAME")` 사용
- 하드코딩 절대 금지
- `.env` 파일에서 환경변수 관리
- Pydantic Settings 클래스 사용

#### 아키텍처 (standards/05_architecture.md Line 89-102)
- Domain Layer는 Infrastructure 의존 금지
- interfaces.py로 추상화
- import-linter로 검증
```

**파일 분리 예시**:
```
큰 문서는 파일로 분리하세요!

❌ Before:
PROJECT_STANDARDS.md (800 lines)
→ 너무 길어서 어디 읽어야 할지 모름

✅ After:
standards/
├── 01_logging.md (150 lines)
├── 02_configuration.md (120 lines)
├── 03_error_handling.md (180 lines)
├── 04_database.md (200 lines)
├── 05_architecture.md (150 lines)

각 파일이 200-500 lines로 적정!
Line 참조하기도 쉬움!
```

**필터링 절차**:
1. **이 Task가 무엇을 하나?** → JWT 토큰 생성
2. **필요한 표준 식별**:
   - 로깅? YES (토큰 생성 이벤트 기록)
   - 설정? YES (SECRET_KEY 가져오기)
   - DB? NO (JWT는 DB 안 씀)
   - 에러처리? NO (이 Task는 간단)
3. **필요한 부분만 읽기**:
   - standards/01_logging.md Line 12-25 읽기
   - standards/02_configuration.md Line 30-45 읽기
4. **Task Section 2에 요약 + Line 참조**

**주의**:
- ❌ "프로젝트 표준을 따른다" (추상적)
- ❌ "PROJECT_STANDARDS.md 전체 참조" (800 lines!)
- ✅ 구체적인 파일명 + Line 번호 + 핵심 내용 요약 (30 lines)
- ✅ "이 Task에 필요한" 부분만 필터링

**표준 문서가 없는 경우**:
```markdown
## 2. 📋 프로젝트 표준 (이 Task에서 정의)

프로젝트 초반이라 표준 문서가 없는 경우,
이 Task에서 사용할 패턴을 직접 정의하세요:

#### 로깅 (이 Task에서 정의)
- structlog 사용
- logger.info("event_name", key=value) 형식
- print() 금지

#### 설정 (이 Task에서 정의)
- config.get_secret("KEY_NAME") 패턴
- Pydantic Settings 사용

→ 나중에 이 패턴들이 반복되면
  standards/ 폴더로 추출 고려
```

---

#### Section 3: 사용 도구

**목적**: 이 Task에서 사용할 라이브러리/도구 명시

**작성법**:
```markdown
## 3. 🔧 사용 도구
- **PyJWT**: JWT 토큰 생성/검증
- **structlog**: 구조화된 로깅
- **pytest**: 테스트 프레임워크
```

**주의**:
- DNA 시스템에 설치된 도구만 사용
- 새로운 도구가 필요하면 DNA 시스템 재검토

---

#### Section 4: 입력/출력

**목적**: 이 레고블럭의 인터페이스 정의

**작성법**:
```markdown
## 4. 📦 입력/출력
**입력**: user_id: str - 사용자 고유 ID
**출력**: token: str - JWT 액세스 토큰 (HS256, 1시간 TTL)
```

**주의**:
- 타입 명시 (Pydantic 타입)
- 설명 간결하게

---

#### Section 5: 조립 정보

**목적**: Task 간 의존성 및 조립 순서

**작성법**:
```markdown
## 5. 🔗 조립 정보
**이 블럭을 사용하는 Task**: T2.2.1 (Login), T2.2.3 (Refresh)
**이 블럭이 사용하는 Task**: 없음 (독립 블럭)
```

**Case 1 (모듈화)에서 중요**:
- 어떤 Task가 이 블럭을 사용하는가?
- 이 블럭은 어떤 Task에 의존하는가?

**Case 2 (단계별)에서는**:
- 보통 "없음" 또는 간단한 의존성

---

#### Section 6: 완성 기준 + 자주 하는 실수

**목적**: 이 Task가 완료되었다는 기준 + 흔한 실수 방지

**작성법**:
```markdown
## 6. 🎯 완성 기준

### 기능 검증
- [ ] create_token(user_id) 함수 완전 작동
- [ ] 생성된 토큰이 유효한 JWT 형식
- [ ] Payload에 user_id, exp, iat 포함
- [ ] TTL 정확히 1시간 (3600초)

### 테스트 검증
- [ ] pytest 테스트 3개 통과:
  - 정상 토큰 생성
  - user_id 검증
  - 만료 시간 검증
- [ ] pytest coverage 95%+ 달성

### 품질 검증
- [ ] ruff check 0 violations
- [ ] mypy --strict 0 errors
- [ ] import-linter 0 violations
- [ ] structlog로 토큰 생성 이벤트 기록

### 자주 하는 실수 (이 Task 특화)

**실수 1: exp를 초 단위로 제공**
```python
❌ payload["exp"] = 3600  # 1970년 1월 1일 1시간 후!
✅ payload["exp"] = datetime.utcnow() + timedelta(hours=1)
```

**실수 2: SECRET_KEY 하드코딩**
```python
❌ SECRET_KEY = "my-secret-key-123"
✅ secret_key = config.get_secret("JWT_SECRET_KEY")
```

**실수 3: print() 사용**
```python
❌ print(f"Token generated for {user_id}")
✅ logger.info("token_generated", user_id=user_id)
```
```

**자주 하는 실수 작성 가이드**:

**출처**:
1. 범용 실수 (모든 Task 적용):
   - `standards/99_common_mistakes.md` 참조
   - print() 사용, 하드코딩 등
2. 도메인별 실수 (JWT, DB, API 등):
   - 과거 비슷한 Task 경험
   - 기술 스택별 known issues
3. Task별 고유 실수:
   - 구현 후 회고에서 발견
   - 다음 비슷한 Task에 적용

**큐레이션 절차**:
1. 범용 실수집에서 이 Task 관련만 선택
2. 도메인 실수 (JWT 관련) 추가
3. 3-5개로 제한 (핵심만)
4. ❌/✅ Before/After 형식으로

**주의**:
- 체크 가능한 명확한 기준
- 숫자로 표현 가능하면 숫자로 (예: "3개 통과")
- 자주 하는 실수 3-5개 (너무 많으면 안 읽음)

---

#### Section 7: 구현 힌트 (스켈레톤 수준!)

**목적**: 핵심 로직 구조 제시 (전체 코드 아님!)

**핵심**: Level 3 스켈레톤 - 40 lines 정도

**작성법**:
```markdown
## 7. 💡 구현 힌트 (스켈레톤)

### 함수 시그니처
```python
def create_token(user_id: str) -> str:
    """JWT 액세스 토큰 생성.

    Args:
        user_id: 사용자 고유 ID

    Returns:
        JWT 토큰 문자열 (1시간 유효)

    Raises:
        ValueError: user_id가 빈 문자열인 경우
    """
```

### 핵심 로직 구조
```python
# src/auth/token.py
import jwt
from datetime import datetime, timedelta
from core.config import settings
from core.logging import get_logger

logger = get_logger(__name__)

def create_token(user_id: str) -> str:
    """JWT 액세스 토큰 생성."""
    # 1. Payload 구성
    payload = {
        "user_id": user_id,
        "exp": datetime.utcnow() + timedelta(hours=1),
        "iat": datetime.utcnow()
    }

    # 2. SECRET_KEY 가져오기
    secret_key = config.get_secret("JWT_SECRET_KEY")

    # 3. 토큰 생성
    token = jwt.encode(payload, secret_key, algorithm="HS256")

    # 4. 로깅
    logger.info("token_generated", user_id=user_id)

    return token
```

**Agent가 추가해야 할 것**:
- user_id validation (빈 문자열 체크)
- 에러 처리 (try-except)
- 추가 payload 필드 (jti 등)

### 테스트 스켈레톤 (Given-When-Then)
```python
# tests/auth/test_token.py
def test_create_token_success():
    """Given: 유효한 user_id
       When: create_token 호출
       Then: 유효한 JWT 토큰 반환"""
    # Given
    user_id = "test-user-123"

    # When
    token = create_token(user_id)

    # Then
    assert isinstance(token, str)
    decoded = jwt.decode(token, SECRET_KEY, algorithms=["HS256"])
    assert decoded["user_id"] == user_id
    assert "exp" in decoded
    # Agent가 exp 시간 검증 등 추가
```
```

**스켈레톤 수준 가이드**:

**Level 1: 인터페이스만** (20 lines) - **불충분** ❌
```python
def create_token(user_id: str) -> str:
    """JWT 토큰 생성."""
    pass
```
→ Agent가 구조를 모름

**Level 2: 주석 의사코드** (30 lines) - **부족** ❌
```python
def create_token(user_id: str) -> str:
    # 1. payload 만들기
    # 2. jwt로 인코딩하기
    # 3. 로깅하기
    # 4. 반환하기
```
→ 구체성 부족

**Level 3: 핵심 로직 스켈레톤** (40 lines) - **균형점!** ✅
```python
def create_token(user_id: str) -> str:
    payload = {"user_id": user_id, "exp": ...}
    secret_key = config.get_secret("JWT_SECRET_KEY")
    token = jwt.encode(payload, secret_key, algorithm="HS256")
    logger.info("token_generated", user_id=user_id)
    return token
```
→ 구조는 명확, 세부사항은 Agent가 채움 (TDD 가능!)

**Level 4: 전체 구현** (200+ lines) - **과함!** ❌
```python
def create_token(user_id: str) -> str:
    try:
        if not user_id:
            raise ValueError(...)
        if not isinstance(user_id, str):
            raise TypeError(...)
        # ... 100+ lines of validation
        # ... 50+ lines of edge cases
        # ... 50+ lines of error handling
    except Exception as e:
        logger.exception(...)
        raise
```
→ Agent가 복붙만 함. TDD 불가능.

**선택: Level 3 (스켈레톤)** - 이유:
- 핵심 로직 구조 명확
- Agent가 validation, 에러 처리 추가
- TDD 가능 (테스트 실패 → 수정 반복)
- "Necessary Information Only" 준수

**주의**:
- ✅ 실행 가능한 수준 (import 정확, 함수 호출 가능)
- ✅ DNA 시스템 환경 사용 (core.*)
- ✅ 핵심 로직만 (40 lines)
- ❌ 전체 에러 처리 포함 (Agent가 추가)
- ❌ 모든 엣지 케이스 (Agent가 추가)
- ✅ 주석으로 단계 설명

---

#### Section 8: 예상 작업 시간

**목적**: Task 일정 계획

**작성법**:
```markdown
## 8. ⏱️ 예상 작업 시간
- 구현: 30분
- 테스트 작성: 30분
- 품질 검증: 10분
- 문서화: 10분
- 총 예상: 1시간 20분
```

---

#### Section 9: 메타정보

**목적**: 프로젝트 관리 정보

**작성법**:
```markdown
## 9. 📌 메타정보
- 우선순위: High (다른 Task의 의존성)
- 의존성: 없음
- 태그: #auth #jwt #core
```

---

## 5. 실전 예시: Auth 시스템 분해

### Blueprint (요약)

```markdown
# Auth 시스템 Blueprint (1000줄 중 요약)

## 기능 목록
1. JWT 토큰 관리
   - 생성 (HS256, 1시간 TTL)
   - 검증 (만료, 형식 체크)
2. Login 엔드포인트
   - POST /auth/login
   - 5회 실패 → 30분 잠금
3. Logout 엔드포인트
   - POST /auth/logout
4. Refresh 엔드포인트
   - POST /auth/refresh

## 기술 스택
- PyJWT
- structlog
- Redis (세션 관리)
- FastAPI
```

---

### Case 1: 모듈화 분할 결과

```markdown
# Auth 시스템 Task 목록 (Case 1)

## 모듈 레이어
- Task T2.1.1: JWT 생성 모듈
- Task T2.1.2: JWT 검증 모듈
- Task T2.1.3: 비밀번호 해싱 모듈
- Task T2.1.4: Redis 세션 관리 모듈

## API 레이어 (모듈 사용)
- Task T2.2.1: Login 엔드포인트 (T2.1.1, T2.1.3, T2.1.4 사용)
- Task T2.2.2: Logout 엔드포인트 (T2.1.2, T2.1.4 사용)
- Task T2.2.3: Refresh 엔드포인트 (T2.1.1, T2.1.2 사용)
```

**조립 순서**:
1. 모듈 레이어 병렬 구현 (T2.1.1 ~ T2.1.4)
2. API 레이어 순차 구현 (T2.2.1 → T2.2.2 → T2.2.3)

---

### Case 2: 단계별 구현 결과

```markdown
# Auth 시스템 Task 목록 (Case 2)

- Task T2.1.1: Login 기능 전체 (JWT 생성 포함)
- Task T2.2.1: Logout 기능 전체 (JWT 검증 포함)
- Task T2.3.1: Refresh 기능 전체 (JWT 생성+검증 포함)
```

**구현 순서**:
1. Login 완전 구현 → ✅ 로그인 작동
2. Logout 완전 구현 → ✅ 로그아웃 작동
3. Refresh 완전 구현 → ✅ 토큰 갱신 작동

---

### Task T2.1.1 전체 예시 (Case 1)

````markdown
# Task T2.1.1: JWT 토큰 생성 모듈

## 1. 📘 청사진 참조
**Blueprint Line 145-178**: JWT 알고리즘 및 토큰 구조

핵심 내용:
- HS256 알고리즘 사용
- Payload: {user_id, exp, iat}
- TTL: 1시간 (3600초)
- Secret key는 환경 설정에서 로드

## 2. 📋 프로젝트 표준 참조
**PROJECT_STANDARDS.md Line 12-25**: structlog 로깅 패턴
- 모든 토큰 생성 이벤트 기록
- user_id 포함한 구조화된 로그

**PROJECT_STANDARDS.md Line 45-58**: Pydantic 모델 규칙
- 환경 설정은 pydantic-settings 사용

## 3. 🔧 사용 도구
- **PyJWT**: JWT 토큰 생성/검증 표준 라이브러리
- **structlog**: 구조화된 로깅
- **pydantic-settings**: 환경 설정 관리
- **pytest**: 테스트 프레임워크

## 4. 📦 입력/출력
**입력**: user_id: str - 사용자 고유 ID
**출력**: token: str - JWT 액세스 토큰 (HS256, 1시간 TTL)

## 5. 🔗 조립 정보
**이 블럭을 사용하는 Task**:
- T2.2.1 (Login 엔드포인트)
- T2.2.3 (Refresh 엔드포인트)

**이 블럭이 사용하는 Task**: 없음 (독립 블럭)

## 6. 🎯 완성 기준
- [ ] create_token(user_id) 함수 완전 작동
- [ ] 생성된 토큰이 유효한 JWT 형식
- [ ] Payload에 user_id, exp, iat 포함
- [ ] TTL 정확히 1시간 (3600초)
- [ ] pytest 테스트 3개 통과:
  - 정상 토큰 생성
  - user_id 검증
  - 만료 시간 검증
- [ ] structlog로 토큰 생성 이벤트 기록
- [ ] mypy --strict 0 errors
- [ ] ruff check 0 violations

## 7. 💡 구현 힌트
```python
# src/auth/token.py
import jwt
from datetime import datetime, timedelta
from core.config import settings
from core.logging import get_logger

logger = get_logger(__name__)

def create_token(user_id: str) -> str:
    """JWT 액세스 토큰 생성

    Args:
        user_id: 사용자 고유 ID

    Returns:
        JWT 토큰 문자열 (HS256, 1시간 TTL)
    """
    payload = {
        "user_id": user_id,
        "exp": datetime.utcnow() + timedelta(hours=1),
        "iat": datetime.utcnow()
    }

    token = jwt.encode(
        payload,
        settings.jwt_secret,
        algorithm="HS256"
    )

    logger.info("token_created", user_id=user_id)

    return token
    
# tests/auth/test_token.py
import jwt
from datetime import datetime, timedelta
from auth.token import create_token

def test_create_token_정상():
    """Given: user_id가 주어졌을 때
    When: create_token을 호출하면
    Then: 유효한 JWT 토큰이 생성된다
    """
    # Given
    user_id = "user123"

    # When
    token = create_token(user_id)

    # Then
    decoded = jwt.decode(token, settings.jwt_secret, algorithms=["HS256"])
    assert decoded["user_id"] == user_id
    assert "exp" in decoded
    assert "iat" in decoded

def test_create_token_TTL():
    """Given: 토큰을 생성했을 때
    When: exp를 확인하면
    Then: 정확히 1시간 후로 설정되어 있다
    """
    # Given & When
    token = create_token("user123")
    decoded = jwt.decode(token, settings.jwt_secret, algorithms=["HS256"])

    # Then
    exp = datetime.fromtimestamp(decoded["exp"])
    iat = datetime.fromtimestamp(decoded["iat"])
    assert (exp - iat).total_seconds() == 3600
```

## 8. ⏱️ 예상 작업 시간

- 구현: 30분
- 테스트 작성: 30분
- 품질 검증: 10분
- 문서화: 10분
- 총 예상: 1시간 20분

## 9. 📌 메타정보

- 우선순위: High (다른 Task의 의존성)
- 의존성: 없음 (첫 번째 구현 가능)
- 태그: #auth #jwt #core #module
````

---

## 6. 작업분해 완료 검증

### 분할 방식 검증
- [ ] Case 1 vs Case 2 선택 근거가 명확한가?
- [ ] 모든 Task가 같은 방식으로 분할되었는가?
- [ ] Case 1인 경우, 모듈 레이어와 API 레이어가 구분되었는가?

### Task 품질 검증
- [ ] 각 Task는 200K 컨텍스트 내인가?
- [ ] 각 Task는 의미있는 기능 단위인가? (독립 테스트 가능)
- [ ] 모든 Task가 DNA 시스템 환경 기반인가?
- [ ] 모든 Task가 9-section을 갖추었는가?

### 완성도 검증
- [ ] Blueprint의 모든 기능이 Task로 분해되었는가?
- [ ] Task 간 의존성이 명확한가? (Section 5)
- [ ] 조립 순서가 정의되었는가?
- [ ] 누락된 Task가 없는가? (Q4 체크)

### 일관성 검증
- [ ] 모든 Task가 같은 도구를 사용하는가?
- [ ] 모든 Task가 같은 표준을 따르는가?
- [ ] 청사진 참조가 정확한가? (Line 번호 확인)
- [ ] 프로젝트 표준 참조가 정확한가?

### 템플릿 준수 검증
- [ ] Section 1: 청사진 참조 (Line 번호 + 요약)
- [ ] Section 2: 표준 참조 (Line 번호 + 요약)
- [ ] Section 3: 사용 도구 명시
- [ ] Section 4: 입력/출력 타입 명시
- [ ] Section 5: 조립 정보 명시
- [ ] Section 6: 완성 기준 체크리스트
- [ ] Section 7: 구현 힌트 코드 예시
- [ ] Section 8: 예상 작업 시간
- [ ] Section 9: 메타정보

---

## 참고

- **기반 문서**: [CORE_METHODOLOGY.md](./CORE_METHODOLOGY.md)
- **다음 단계**: [CHECKLIST_GUIDE.md](./CHECKLIST_GUIDE.md) - Task → 9-Step 체크리스트 변환
- **실행 가이드**: Stage 5 (작업분해) → Stage 6 (체크리스트) → Stage 7 (구현)


================================================================================
# End of 08G-00_task_breakdown_guide.md
================================================================================



================================================================================
# 📄 9. 09G-00_checklist_guide.md
================================================================================

# Checklist 작성 가이드

> **목적**: Stage 9 - TDD 기반 9-Step Checklist로 모든 기능 구현, 0 violations, 95%+ coverage 보장
>
> **버전**: v2.0 (2025-11-12)
> - v2.0: Stage 9 범위 명시, 입력/출력 문서 추가

---

## 📥 입력 문서 (Stage 8에서 받은 것)

#### 1. **`08T-01_task_breakdown.md`** (필수)
- 작업 목록 (Task 001~N)
- **활용**: 각 Task마다 Checklist 생성

#### 2. **`06D-01_project_standards.md`** (참고)
- 프로젝트 표준
- **활용**: Checklist에 표준 반영

---

## 📤 출력 문서 (이 Stage에서 생성해야 할 문서)

### 필수 문서

각 Task마다 1개씩 Checklist 생성:

#### 1. **`09L-01_task_001_checklist.md`**
#### 2. **`09L-02_task_002_checklist.md`**
#### 3. **`09L-03_task_003_checklist.md`**
...

**내용** (TDD 9-Step):
```markdown
# Task 001 Checklist: Order Entity 구현

## Step 1: 목표 이해 ✅
- [ ] Task 문서 읽기 (08T-01 Task 001)
- [ ] ADR-116 읽기
- [ ] 표준 확인 (Naming, Validation)
- [ ] 성공 기준 명확히

## Step 2: 테스트 작성 ✅
- [ ] `tests/test_order_entity.py` 생성
- [ ] 실패하는 테스트 작성
- [ ] pytest 실행 → RED 확인

## Step 3: 구현 ✅
- [ ] `src/domains/order/models.py` 생성
- [ ] Order 클래스 작성
- [ ] pytest 실행 → GREEN 확인

## Step 4: 정적 검증 ✅
- [ ] ruff check . (0 violations)
- [ ] mypy . (0 errors)

## Step 5: 단위 테스트 실행 ✅
- [ ] pytest tests/test_order_entity.py
- [ ] coverage report (95%+)

## Step 6: 리팩토링 ✅
- [ ] 중복 코드 제거
- [ ] 명명 개선
- [ ] 테스트 재실행

## Step 7: 종합 테스트 ✅
- [ ] 통합 테스트 (필요시)
- [ ] E2E 테스트 (필요시)

## Step 8: 문서화 ✅
- [ ] Docstring 작성
- [ ] README 업데이트 (필요시)

## Step 9: 커밋 ✅
- [ ] git add .
- [ ] git commit -m "..."
- [ ] PR 생성 (필요시)
```

**특징**:
- AI가 체크박스 하나씩 완료
- 0 violations 보장
- 95%+ coverage 보장

---

## 🔄 다음 Stage로 전달되는 것

Stage 9 → 구현:
- ✅ 작업별 체크리스트
- ✅ TDD 9-Step 실행 가이드
- ✅ 품질 보장 메커니즘

구현 단계에서는:
- Checklist를 따라 단계별 구현
- 모든 검증 통과 확인
- 완성된 코드 + 테스트 + 문서

---

## 1. 개요

### 목적
**Task 문서 (100줄) → 9-Step Checklist (실행 가능한 작업 지시서)**

Task 문서는 "무엇을" 만들지 정의하고, Checklist는 "어떻게" 만들지 실행 단계를 제공합니다.

### Checklist의 역할
```
Task 문서 (설계도)
    ↓
Checklist (작업 지시서)
    ↓
AI 에이전트 실행 (구현)
    ↓
완성된 코드 + 테스트 + 문서
```

### 완성 기준
- ✅ **실행 가능성**: AI가 이 Checklist만으로 Task를 완수할 수 있어야 함
- ✅ **자급자족성**: Task 문서 + Checklist만 있으면 Blueprint 없이도 작업 가능
- ✅ **검증 가능성**: 각 Step의 완료 여부를 명확히 확인 가능

---

## 2. 정보 밀도 균형점 ⚖️

### 2-1. 왜 500 lines인가?

**너무 많으면 (1,400+ lines)**:
```markdown
❌ 전체 구현 코드 400 lines 포함
❌ 전체 테스트 코드 200 lines 포함
❌ 모든 에러 처리, 엣지 케이스 포함
→ Agent가 읽기 부담스러움
→ 복붙만 하게 되어 TDD 불가능
```

**너무 적으면 (200 lines)**:
```markdown
❌ "Task 문서 Section 7 참조하세요"
❌ "PROJECT_STANDARDS.md 읽어보세요"
→ Agent가 문서 왕복하며 읽어야 함
→ 집중력 분산, 비효율적
```

**균형점 (500 lines)**: ✅
```markdown
✅ 구현 스켈레톤 (40 lines) - 핵심 로직 구조만
✅ 테스트 스켈레톤 (30 lines/케이스) - Given-When-Then + 기본 assert
✅ 자주 하는 실수 (15 lines/패턴) - ❌/✅ Before/After
✅ 프로젝트 표준 인라인 (30 lines) - 이 Task 관련만
→ Agent가 체크리스트만 보고 작업 완료
→ 스켈레톤이라 Agent가 채우며 TDD 가능
```

---

### 2-2. 구현 코드는 얼마나?

**Level 1: 인터페이스 계약** (20 lines) - **필수**
```python
def create_token(user_id: str) -> str:
    """JWT 액세스 토큰 생성.

    Args:
        user_id: 사용자 ID
    Returns:
        JWT 토큰 (1시간 유효)
    Raises:
        ValueError: user_id 빈 문자열
    """
```
→ "무엇을" 만들지 정의. Agent가 추측 불가능.

**Level 2: 아키텍처 제약** (10 lines) - **필수**
```python
# PyJWT 라이브러리 사용
# HS256 알고리즘만
# config.get_secret("JWT_SECRET_KEY") 사용
# structlog로 로깅
```
→ 프로젝트별 제약. Agent가 추측하면 틀림.

**Level 3: 구현 스켈레톤** (40 lines) - **균형점!** ✅
```python
def create_token(user_id: str) -> str:
    payload = {"user_id": user_id, "exp": datetime.utcnow() + timedelta(hours=1)}
    secret_key = config.get_secret("JWT_SECRET_KEY")
    token = jwt.encode(payload, secret_key, algorithm="HS256")
    logger.info("token_generated", user_id=user_id)
    return token
```
→ 핵심 로직 구조만. Agent가 에러 처리, validation 추가.

**Level 4: 전체 구현** (200+ lines) - **과함!** ❌
```python
def create_token(user_id: str) -> str:
    try:
        if not user_id:
            raise ValueError("user_id cannot be empty")
        if not isinstance(user_id, str):
            raise TypeError("user_id must be string")
        # ... 100+ lines of error handling
        # ... 50+ lines of edge case handling
    except Exception as e:
        logger.exception("unexpected_error")
        raise
```
→ 모든 엣지 케이스 포함. Agent가 복붙만 함. TDD 불가능.

**선택: Level 3 (스켈레톤)** - 이유:
- Agent가 스스로 채우며 구현 (학습 효과)
- TDD 가능 (테스트 실패 → 수정 → 통과 반복)
- "Necessary Information Only" 원칙 준수

---

### 2-3. 테스트 코드는 얼마나?

**Level 1: Given-When-Then 시나리오만** (10 lines) - **불충분** ❌
```python
def test_create_token_success():
    """Given: 유효한 user_id
       When: create_token 호출
       Then: JWT 토큰 반환"""
```
→ 구체적인 assert 없음. Agent가 어떻게 검증할지 모름.

**Level 2: 테스트 스켈레톤** (30 lines) - **균형점!** ✅
```python
def test_create_token_success():
    """Given: 유효한 user_id
       When: create_token 호출
       Then: JWT 토큰 반환"""
    # Given
    user_id = "test-user-123"
    generator = TokenGenerator()

    # When
    token = generator.create_token(user_id)

    # Then
    assert isinstance(token, str)
    decoded = jwt.decode(token, SECRET_KEY, algorithms=["HS256"])
    assert decoded["user_id"] == user_id
    # Agent가 exp 검증 등 추가
```
→ 기본 assert 구조 제공. Agent가 세밀한 검증 추가.

**Level 3: 완전한 테스트** (100+ lines) - **과함!** ❌
```python
def test_create_token_success():
    # ... 50 lines of setup
    # ... 30 lines of execution
    # ... 20 lines of verification
```
→ 모든 검증 포함. Agent가 복붙만 함.

**선택: Level 2 (스켈레톤)** - 이유:
- Given-When-Then 구조 명확
- 기본 assert로 방향 제시
- Agent가 세밀한 검증 추가 (TDD)

---

### 2-4. 자주 하는 실수는?

**Level 1: 항목만 나열** (5 lines) - **불충분** ❌
```
실수 1: exp를 초 단위로 제공
실수 2: SECRET_KEY 하드코딩
```
→ 뭐가 잘못됐는지만. 어떻게 고쳐야 할지 모름.

**Level 2: ❌/✅ Before/After** (15 lines) - **균형점!** ✅
```python
실수 1: exp를 초 단위로 제공
❌ payload["exp"] = 3600
✅ payload["exp"] = datetime.utcnow() + timedelta(hours=1)

실수 2: SECRET_KEY 하드코딩
❌ SECRET_KEY = "my-secret-123"
✅ secret_key = config.get_secret("JWT_SECRET_KEY")
```
→ 명확한 대비. Agent가 즉시 이해.

**Level 3: 이유 + 디버깅** (30+ lines) - **과함!** ❌
```
실수 1: exp를 초 단위로 제공

❌ 잘못된 코드: ...
왜 잘못됐나? ...
어떻게 발견하나? ...
✅ 올바른 코드: ...
추가 고려사항: ...
```
→ 너무 장황. Agent가 읽기 부담.

**선택: Level 2 (Before/After)** - 이유:
- 3-5 lines로 간결
- 즉시 비교 가능
- 패턴 명확

---

### 2-5. 프로젝트 표준은 어떻게?

**Option 1: 범용 문서 참조** ❌
```markdown
## Step 3: 구현
**프로젝트 표준**: PROJECT_STANDARDS.md 참조하세요
```
→ Agent가 800 lines 문서를 언제 읽나?

**Option 2: 인라인 복사** ✅ (균형점!)
```markdown
## Step 3: 구현

### 3.1 이 Task의 프로젝트 표준

#### 로깅 (PROJECT_STANDARDS.md Line 12-25)
- logger.info("event_name", key=value) 형식
- print() 금지
- 모든 주요 작업 로깅

#### 설정 (PROJECT_STANDARDS.md Line 30-45)
- config.get_secret("KEY_NAME") 사용
- 하드코딩 금지
- 환경변수로 관리

#### 에러 (PROJECT_STANDARDS.md Line 50-68)
- CustomError 상속
- structlog로 로깅
- 사용자에게 명확한 메시지
```
→ 체크리스트에 인라인. Agent가 왕복 불필요.
→ Line 참조 유지 (추적 가능성)
→ "이 Task 관련" 부분만 (Necessary Information Only)

**선택: Option 2 (인라인)** - 이유:
- 체크리스트만으로 자급자족
- 다른 문서 참조 불필요
- 30 lines 정도로 적정

---

### 2-6. 체크리스트 크기 계산

```
Step 1: 목표 이해 (50 lines)
  - Task 목표, 입출력, 성공 기준

Step 2: 테스트 작성 (100 lines)
  - Given-When-Then 시나리오 3-5개
  - 테스트 스켈레톤 (각 20-30 lines)

Step 3: 구현 (200 lines) ← 가장 많음
  - 3.1 프로젝트 표준 인라인 (30)
  - 3.2 함수 시그니처 (20)
  - 3.3 구현 스켈레톤 (40)
  - 3.4 자주 하는 실수 (60)
  - 3.5 구현 위치 (10)

Step 4: 정적 검증 (30 lines)
  - ruff, mypy, import-linter 명령어
  - 예상 출력

Step 5: 테스트 실행 (40 lines)
  - pytest + coverage 명령어
  - 예상 출력

Step 6-9: 리팩토링/재테스트/문서화/커밋 (80 lines)

총합: 50 + 100 + 200 + 30 + 40 + 80 = 500 lines
```

---

### 2-7. 파일 분리와 Line 참조

**큰 문서 = 문제 아님!**

```markdown
# 청사진이 5,000 lines? 괜찮아!

blueprints/
├── 01_auth_system.md (500 lines)
├── 02_payment_system.md (600 lines)
├── 03_notification_system.md (450 lines)
...

# Task 작성 시:
청사진 참조: blueprints/01_auth_system.md Line 145-178
→ 500 lines 문서의 33 lines만 읽으면 됨!

# Checklist 작성 시:
그 33 lines를 인라인으로 복사
→ Agent는 체크리스트만 읽음!
```

**PROJECT_STANDARDS.md가 800 lines? 괜찮아!**

```markdown
standards/
├── 01_logging.md (150 lines)
├── 02_configuration.md (120 lines)
├── 03_error_handling.md (180 lines)
├── 04_database.md (200 lines)
...

# Task 작성 시:
표준 참조: standards/01_logging.md Line 12-25
→ 150 lines 문서의 13 lines만!

# Checklist 작성 시:
그 13 lines를 Step 3.1에 인라인
→ Agent는 체크리스트만 읽음!
```

**핵심**:
- 큰 문서는 파일로 분리 (각 200-500 lines)
- Line 참조로 정확한 부분만 지정
- 체크리스트에 인라인 복사
- Agent는 최종적으로 체크리스트 500 lines만 읽음

---

## 3. 9-Step 구조 이해

### 전체 흐름
```
┌─────────────────────────────────────────────┐
│ Phase 1: 이해 + 테스트 설계 (Step 1-2)          │
│ - 목표 명확화                                  │
│ - 테스트 케이스 작성 (TDD)                      │
├─────────────────────────────────────────────┤
│ Phase 2: 구현 + 1차 검증 (Step 3-4)            │
│ - 핵심 로직 구현                               │
│ - 정적 검증 (ruff, mypy, import-linter)       │
├─────────────────────────────────────────────┤
│ Phase 3: 테스트 + 품질 개선 (Step 5-7)          │
│ - 테스트 실행 (pytest 95%+ coverage)          │
│ - 리팩토링                                    │
│ - 재테스트                                    │
├─────────────────────────────────────────────┤
│ Phase 4: 문서화 + 제출 (Step 8-9)             │
│ - Docstring + 사용 예시                       │
│ - Git commit                                │
└─────────────────────────────────────────────┘
```

### 핵심 원칙

**TDD (Test-Driven Development)**
- Step 2에서 테스트 먼저 작성
- Step 3에서 구현
- Step 5에서 테스트 실행

**Zero-Tolerance Quality**
- Step 4: ruff 0, mypy 0, import-linter 0
- Step 5: pytest 95%+ coverage
- Step 6-7: 품질 개선 + 재검증

**Documentation First**
- Step 8: Docstring (Google 스타일)
- 사용 예시 코드 포함

---

## 3. 9-Step 상세 가이드

### Step 1: 목표 이해

**질문**: "이 Task로 무엇을 만들 것인가?"

**산출물**:
- Task 목표 명확화
- 성공 기준 정의
- Task 문서 완전 이해

**Checklist 작성법**:
```markdown
## Step 1: 목표 이해

### Task 목표
{Task 문서의 Section 4 입력/출력을 그대로 복사}

예시:
- **입력**: user_id: str
- **출력**: token: str (JWT 액세스 토큰, 1시간 유효)

### 성공 기준
{Task 문서의 Section 6 완성 기준을 그대로 복사}

예시:
- [ ] create_token(user_id) 함수 완전 작동
- [ ] pytest 테스트 3개 통과 (성공/만료/잘못된 시크릿)
- [ ] ruff 0, mypy 0, coverage 95%+
```

**도구**: Task 문서

---

### Step 2: 테스트 작성

**질문**: "어떻게 동작을 검증할 것인가?"

**산출물**:
- Given-When-Then 테스트 케이스
- 성공/실패/엣지 케이스 포함
- pytest 파일 생성

**Checklist 작성법**:
````markdown
## Step 2: 테스트 작성

### 테스트 케이스

**성공 케이스**:

```python
def test_create_token_success():
    # Given: 유효한 사용자 ID
    user_id = "user123"

    # When: 토큰 생성
    token = create_token(user_id)

    # Then: 유효한 JWT 토큰 반환
    assert isinstance(token, str)
    decoded = jwt.decode(token, settings.jwt_secret, algorithms=["HS256"])
    assert decoded["user_id"] == user_id
```

**실패 케이스**:

```python
def test_create_token_expired():
    # Given: 만료된 토큰
    token = create_expired_token("user123")

    # When: 토큰 검증
    # Then: ExpiredSignatureError 발생
    with pytest.raises(jwt.ExpiredSignatureError):
        jwt.decode(token, settings.jwt_secret, algorithms=["HS256"])
```

**엣지 케이스**:

```python
def test_create_token_invalid_secret():
    # Given: 잘못된 시크릿
    token = create_token("user123")

    # When: 잘못된 시크릿으로 검증
    # Then: InvalidSignatureError 발생
    with pytest.raises(jwt.InvalidSignatureError):
        jwt.decode(token, "wrong_secret", algorithms=["HS256"])
```
### 파일 생성

- `tests/test_jwt_token.py` 생성
- 위 테스트 케이스 3개 작성
````

**도구**: pytest, Task 문서 Section 6 (완성 기준)

---

### Step 3: 구현

**질문**: "핵심 로직을 어떻게 구현할 것인가?"

**산출물**:

- 실제 구현 코드 (스켈레톤 수준)
- Type hints 포함
- 프로젝트 표준 인라인 복사

**Checklist 작성법**:

````markdown
## Step 3: 구현

### 3.1 이 Task의 프로젝트 표준 (인라인 복사!)

{Task 문서 Section 6의 프로젝트 표준을 그대로 복사}

예시:

#### 로깅 (PROJECT_STANDARDS_01_로깅.md Line 12-25)
- `logger.info("event_name", key=value)` 형식 사용
- `print()` 절대 금지
- 모든 주요 작업 (생성, 수정, 삭제) 로깅 필수
- 에러는 `logger.error()` 또는 `logger.exception()` 사용

#### 설정 (PROJECT_STANDARDS_02_설정.md Line 30-45)
- 모든 SECRET은 `config.get_secret("KEY_NAME")` 사용
- 하드코딩 절대 금지
- `.env` 파일에서 환경변수 관리
- Pydantic Settings 클래스 사용

#### 에러 처리 (PROJECT_STANDARDS_03_에러.md Line 50-68)
- 프로젝트 CustomError 클래스 상속
- 모든 예외 structlog로 로깅
- 사용자에게 명확한 에러 메시지 전달

### 3.2 함수 시그니처

{Task 문서 Section 7의 함수 시그니처}

```python
def create_token(user_id: str) -> str:
    """JWT 액세스 토큰 생성.

    Args:
        user_id: 사용자 고유 ID

    Returns:
        JWT 토큰 문자열 (1시간 유효)

    Raises:
        ValueError: user_id가 빈 문자열인 경우
    """
```

### 3.3 구현 힌트 (스켈레톤!)

{Task 문서 Section 7의 구현 힌트를 Level 3 스켈레톤으로}

**핵심**: 전체 코드 아니고 40 lines 스켈레톤만!

```python
from datetime import datetime, timedelta
import jwt
from src.config import settings

def create_token(user_id: str) -> str:
    """JWT 액세스 토큰 생성."""
    # 1. Payload 구성
    payload = {
        "user_id": user_id,
        "exp": datetime.utcnow() + timedelta(hours=1),
    }

    # 2. SECRET_KEY 가져오기
    secret_key = config.get_secret("JWT_SECRET_KEY")

    # 3. 토큰 생성
    token = jwt.encode(payload, secret_key, algorithm="HS256")

    # 4. 로깅
    logger.info("token_generated", user_id=user_id)

    return token
```

**Agent가 추가해야 할 것**:
- user_id validation (빈 문자열 체크)
- 에러 처리 (try-except)
- 추가 payload 필드 (iat, jti 등)

### 3.4 자주 하는 실수 (이 Task 특화)

{Task 문서 Section 8의 실수 패턴을 ❌/✅ 형식으로}

**실수 1: exp를 초 단위로 제공**
```python
❌ payload["exp"] = 3600  # 1970년 1월 1일 1시간 후로 해석됨!
✅ payload["exp"] = datetime.utcnow() + timedelta(hours=1)
```

**실수 2: SECRET_KEY 하드코딩**
```python
❌ SECRET_KEY = "my-secret-key-123"
✅ secret_key = config.get_secret("JWT_SECRET_KEY")
```

**실수 3: print() 사용**
```python
❌ print(f"Token generated for {user_id}")
✅ logger.info("token_generated", user_id=user_id)
```

**실수 4: algorithm 파라미터 누락**
```python
❌ jwt.encode(payload, secret_key)  # 알고리즘 기본값 변경될 수 있음
✅ jwt.encode(payload, secret_key, algorithm="HS256")
```

### 3.5 구현 위치

{Task 문서 Section 7의 구현 위치}

- **파일**: `src/auth/jwt.py`
- **함수**: `create_token(user_id: str) -> str`
- **테스트**: `tests/auth/test_jwt_token.py`
````

**도구**: Task 문서 Section 6, 7, 8

---

### Step 4: 정적 검증

**질문**: "코드 품질이 표준을 만족하는가?"

**산출물**:
- ruff 0 violations
- mypy 0 errors
- import-linter 0 violations

**Checklist 작성법**:

````markdown
## Step 4: 정적 검증

### 검증 명령어

```bash
# 1. Ruff 검사 (코드 스타일)
ruff check src/auth/jwt.py tests/test_jwt_token.py
# 기대: All checks passed!

# 2. MyPy 검사 (타입 안전성)
mypy src/auth/jwt.py tests/test_jwt_token.py
# 기대: Success: no issues found

# 3. Import Linter 검사 (아키텍처 규칙)
import-linter
# 기대: All contracts passed!
```

### 위반 발견 시 조치

**Ruff 위반**:

```bash
ruff check --fix src/auth/jwt.py
```

**MyPy 에러**:

- Type hints 추가 또는 수정
- `# type: ignore` 사용 금지

**Import Linter 위반**:

- 계층 위반 수정 (domain → infrastructure 금지)
````

**도구**: ruff, mypy, import-linter

---

### Step 5: 테스트 실행

**질문**: "테스트가 통과하고 커버리지가 충분한가?"

**산출물**:
- 모든 테스트 통과
- 95%+ test coverage
- pytest 리포트

**Checklist 작성법**:

````markdown
## Step 5: 테스트 실행

### 테스트 실행 명령어

```bash
# 전체 테스트 실행 + 커버리지
pytest tests/test_jwt_token.py \
    --cov=src/auth/jwt \
    --cov-report=term-missing \
    --cov-fail-under=95
```

### 기대 결과

```
tests/test_jwt_token.py::test_create_token_success PASSED
tests/test_jwt_token.py::test_create_token_expired PASSED
tests/test_jwt_token.py::test_create_token_invalid_secret PASSED

---------- coverage: platform darwin, python 3.11 ----------
Name                Stmts   Miss  Cover   Missing
-------------------------------------------------
src/auth/jwt.py        12      0   100%
-------------------------------------------------
TOTAL                  12      0   100%
```

### 커버리지 부족 시 조치

- Missing 라인 확인
- 추가 테스트 케이스 작성
- 95% 이상 달성할 때까지 반복
````

**도구**: pytest, pytest-cov

---

### Step 6: 리팩토링

**질문**: "코드를 더 명확하고 유지보수 가능하게 개선할 수 있는가?"

**산출물**:
- 개선된 코드 구조
- 중복 제거
- 명확한 변수명

**Checklist 작성법**:

````markdown
## Step 6: 리팩토링

### 리팩토링 체크리스트

**코드 구조**:
- [ ] 함수 길이 50줄 이하
- [ ] 중첩 depth 3 이하
- [ ] 하나의 함수는 하나의 책임만

**가독성**:
- [ ] 변수명이 명확한가? (`t` → `token`, `u` → `user_id`)
- [ ] 매직 넘버 제거 (3600 → `HOUR_IN_SECONDS`)
- [ ] 복잡한 조건문 함수로 추출

**중복 제거**:
- [ ] 반복되는 코드 함수로 추출
- [ ] 공통 상수 별도 정의

### 리팩토링 예시

**Before**:
```python
def create_token(user_id: str) -> str:
    p = {"user_id": user_id, "exp": datetime.utcnow() + timedelta(hours=1)}
    return jwt.encode(p, settings.jwt_secret, algorithm="HS256")
```

**After**:

```python
TOKEN_EXPIRY_HOURS = 1
JWT_ALGORITHM = "HS256"

def create_token(user_id: str) -> str:
    """JWT 액세스 토큰 생성."""
    payload = _create_payload(user_id)
    return jwt.encode(payload, settings.jwt_secret, algorithm=JWT_ALGORITHM)

def _create_payload(user_id: str) -> dict:
    """JWT payload 생성."""
    return {
        "user_id": user_id,
        "exp": datetime.utcnow() + timedelta(hours=TOKEN_EXPIRY_HOURS),
    }
```
````

**도구**: ruff (자동 리팩토링), IDE refactoring tools

---

### Step 7: 재테스트

**질문**: "리팩토링 후에도 모든 테스트가 통과하는가?"

**산출물**:
- 리팩토링 후 테스트 통과 확인
- 회귀 버그 없음 검증

**Checklist 작성법**:

```markdown
## Step 7: 재테스트

### 전체 검증 재실행

```bash
# 1. 정적 검증
ruff check src/auth/jwt.py tests/test_jwt_token.py
mypy src/auth/jwt.py tests/test_jwt_token.py
import-linter

# 2. 테스트 + 커버리지
pytest tests/test_jwt_token.py \
    --cov=src/auth/jwt \
    --cov-report=term-missing \
    --cov-fail-under=95

### 최종 확인

- [ ] ruff 0 violations
- [ ] mypy 0 errors
- [ ] import-linter 0 violations
- [ ] pytest 모든 테스트 통과
- [ ] coverage 95%+ 달성

### 실패 시 조치

- Step 6 리팩토링 재검토
- 깨진 테스트 수정
- 모든 검증 통과할 때까지 Step 6-7 반복
```

**도구**: ruff, mypy, import-linter, pytest

---

### Step 8: 문서화

**질문**: "다른 개발자가 이 코드를 쉽게 사용할 수 있는가?"

**산출물**:
- Google 스타일 docstring
- 사용 예시 코드
- 필요 시 README 업데이트

**Checklist 작성법**:

````markdown
## Step 8: 문서화

### Docstring 작성 (Google 스타일)

```python
def create_token(user_id: str) -> str:
    """JWT 액세스 토큰을 생성합니다.

    Args:
        user_id: 사용자 고유 ID (UUID 또는 문자열)

    Returns:
        JWT 토큰 문자열. 1시간 후 만료됩니다.

    Raises:
        ValueError: user_id가 빈 문자열인 경우

    Example:
        >>> token = create_token("user123")
        >>> print(token)
        'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...'

        >>> # 토큰 검증
        >>> decoded = jwt.decode(token, settings.jwt_secret, algorithms=["HS256"])
        >>> print(decoded["user_id"])
        'user123'
    """
    if not user_id:
        raise ValueError("user_id cannot be empty")

    payload = _create_payload(user_id)
    return jwt.encode(payload, settings.jwt_secret, algorithm=JWT_ALGORITHM)
```

### 사용 예시 (README.md 또는 별도 파일)

## JWT 토큰 생성 사용법

### 기본 사용

```python
from src.auth.jwt import create_token

# 토큰 생성
token = create_token("user123")

# API 응답에 포함
response = {
    "access_token": token,
    "token_type": "Bearer",
    "expires_in": 3600,
}
```

### 주의사항
- 토큰은 1시간 후 자동 만료됩니다
- settings.jwt_secret은 환경변수로 설정해야 합니다
- Production에서는 반드시 HTTPS 사용
````

**도구**: Task 문서 Section 4 (입력/출력)

---

### Step 9: 커밋

**질문**: "변경사항을 Git에 안전하게 기록할 준비가 되었는가?"

**산출물**:
- Git commit with conventional commit message
- Pre-commit hooks 통과

**Checklist 작성법**:

````markdown
## Step 9: 커밋

### 커밋 전 최종 확인

```bash
# 변경된 파일 확인
git status

# 예상 결과:
# modified:   src/auth/jwt.py
# new file:   tests/test_jwt_token.py
```

### Git 커밋

```bash
# 파일 추가
git add src/auth/jwt.py tests/test_jwt_token.py

# Conventional Commit 메시지로 커밋
git commit -m "feat(auth): Add JWT token generation module

- Implement create_token() function with HS256 algorithm
- Add 3 test cases (success/expired/invalid secret)
- Achieve 100% test coverage
- Add comprehensive docstring with usage examples

Closes T2.1.1"
```

### Pre-commit Hook 검증

Pre-commit hooks가 자동 실행됩니다:

- ✅ ruff check
- ✅ mypy
- ✅ import-linter
- ✅ pytest --cov-fail-under=95

**모든 hook 통과 시**: 커밋 성공
**Hook 실패 시**: Step 4-7 재실행

### Conventional Commit 형식

- `feat`: 새 기능
- `fix`: 버그 수정
- `refactor`: 리팩토링
- `test`: 테스트 추가
- `docs`: 문서화
````

**도구**: git, pre-commit hooks

---

## 4. Checklist 템플릿

아래 템플릿을 복사해서 각 Task마다 Checklist를 작성하세요.

````markdown
# Checklist: {Task ID} - {Task 이름}

> **Task 문서**: `docs/tasks/{Task_ID}.md`
> **생성일**: YYYY-MM-DD
> **예상 소요**: {Task 문서 Section 8 참조}

---

## Step 1: 목표 이해

### Task 목표
{Task 문서 Section 4: 입력/출력}

### 성공 기준
{Task 문서 Section 6: 완성 기준}

---

## Step 2: 테스트 작성

### 테스트 케이스

**성공 케이스**:

```python
def test_{function_name}_success():
    # Given:

    # When:

    # Then:
```

**실패 케이스**:

```python
def test_{function_name}_failure():
    # Given:

    # When:

    # Then:
```

**엣지 케이스**:

```python
def test_{function_name}_edge():
    # Given:

    # When:

    # Then:
```

### 파일 생성

- `tests/test_{module}.py` 생성

---

## Step 3: 구현

### 구현 위치

{Task 문서 Section 7: 구현 힌트}

### 구현 코드

```python
{실제 구현 코드}
```

### 프로젝트 표준 준수

{Task 문서 Section 2: 프로젝트 표준 참조}

---

## Step 4: 정적 검증

### 검증 명령어

```bash
ruff check {파일 경로}
mypy {파일 경로}
import-linter
```

### 기대 결과

- [ ] ruff 0 violations
- [ ] mypy 0 errors
- [ ] import-linter 0 violations

---

## Step 5: 테스트 실행

### 테스트 실행 명령어

```bash
pytest {테스트 파일} \
    --cov={모듈 경로} \
    --cov-report=term-missing \
    --cov-fail-under=95
```

### 기대 결과

- [ ] 모든 테스트 통과
- [ ] Coverage 95%+ 달성

---

## Step 6: 리팩토링

### 리팩토링 체크리스트

- [ ] 함수 길이 50줄 이하
- [ ] 중첩 depth 3 이하
- [ ] 변수명 명확
- [ ] 매직 넘버 제거
- [ ] 중복 코드 제거

---

## Step 7: 재테스트

### 전체 검증 재실행

```bash
ruff check {파일들}
mypy {파일들}
import-linter
pytest {테스트 파일} --cov={모듈} --cov-fail-under=95
```

### 최종 확인

- [ ] ruff 0 violations
- [ ] mypy 0 errors
- [ ] import-linter 0 violations
- [ ] pytest 모든 테스트 통과
- [ ] coverage 95%+ 달성

---

## Step 8: 문서화

### Docstring (Google 스타일)

```python
def {function_name}({args}):
    """{한 줄 요약}.

    Args:
        {arg}: {설명}

    Returns:
        {반환값 설명}

    Raises:
        {예외}: {발생 조건}

    Example:
        >>> {사용 예시}
    """
```

### 사용 예시

```python
{실제 사용 예시 코드}
```

---

## Step 9: 커밋

### Git 커밋

```bash
git add {파일들}

git commit -m "feat({scope}): {요약}

- {변경사항 1}
- {변경사항 2}

Closes {Task ID}"
```

### Pre-commit Hook 검증

- [ ] ruff check 통과
- [ ] mypy 통과
- [ ] import-linter 통과
- [ ] pytest 통과

---

## 완료 확인

- [ ] 9 Steps 모두 완료
- [ ] 모든 품질 기준 만족
- [ ] Git commit 성공
````

---

## 5. 실전 예시: Task T2.1.1 → Checklist

Task 문서에서 Checklist로 변환하는 과정을 보여드립니다.

### Task 문서 (요약)

```
# Task T2.1.1: JWT 토큰 생성 모듈

## 1. 📘 청사진 참조
Blueprint Line 145-178

## 2. 📋 프로젝트 표준 참조
PROJECT_STANDARDS.md Line 12-25 (structlog)
PROJECT_STANDARDS.md Line 45-58 (Pydantic Settings)

## 3. 🔧 사용 도구
- PyJWT

## 4. 📦 입력/출력
**입력**: user_id: str
**출력**: token: str - JWT 액세스 토큰

## 5. 🔗 조립 정보
**이 블럭을 사용하는 Task**: T2.2.1, T2.2.3
**이 블럭이 사용하는 Task**: 없음

## 6. 🎯 완성 기준
- [ ] create_token(user_id) 함수 완전 작동
- [ ] pytest 테스트 3개 통과
- [ ] ruff 0, mypy 0, coverage 95%+

## 7. 💡 구현 힌트
```python
def create_token(user_id: str) -> str:
    payload = {
        "user_id": user_id,
        "exp": datetime.utcnow() + timedelta(hours=1),
    }
    return jwt.encode(payload, settings.jwt_secret, algorithm="HS256")

## 8. ⏱️ 예상 작업 시간

2-3 hours
```

### Checklist (완성본)

````markdown
# Checklist: T2.1.1 - JWT 토큰 생성 모듈

> **Task 문서**: `docs/tasks/T2.1.1_JWT_Token_Generation.md`
> **생성일**: 2025-01-09
> **예상 소요**: 2-3 hours

---

## Step 1: 목표 이해

### Task 목표
- **입력**: `user_id: str` - 사용자 고유 ID
- **출력**: `token: str` - JWT 액세스 토큰 (1시간 유효)

### 성공 기준
- [ ] `create_token(user_id)` 함수 완전 작동
- [ ] pytest 테스트 3개 통과 (성공/만료/잘못된 시크릿)
- [ ] ruff 0, mypy 0, coverage 95%+

---

## Step 2: 테스트 작성

### 테스트 케이스

**성공 케이스**:
```python
def test_create_token_success():
    # Given: 유효한 사용자 ID
    user_id = "user123"

    # When: 토큰 생성
    token = create_token(user_id)

    # Then: 유효한 JWT 토큰 반환
    assert isinstance(token, str)
    decoded = jwt.decode(token, settings.jwt_secret, algorithms=["HS256"])
    assert decoded["user_id"] == user_id
    assert "exp" in decoded
```
**실패 케이스**:

```python
def test_create_token_expired():
    # Given: 만료된 토큰
    with freeze_time("2025-01-01 12:00:00"):
        token = create_token("user123")

    # When: 1시간 후 검증
    with freeze_time("2025-01-01 13:00:01"):
        # Then: ExpiredSignatureError 발생
        with pytest.raises(jwt.ExpiredSignatureError):
            jwt.decode(token, settings.jwt_secret, algorithms=["HS256"])
```

**엣지 케이스**:

```python
def test_create_token_invalid_secret():
    # Given: 유효한 토큰
    token = create_token("user123")

    # When: 잘못된 시크릿으로 검증
    # Then: InvalidSignatureError 발생
    with pytest.raises(jwt.InvalidSignatureError):
        jwt.decode(token, "wrong_secret", algorithms=["HS256"])
```

### 파일 생성

- `tests/auth/test_jwt_token.py` 생성
- 위 테스트 케이스 3개 작성

---

## Step 3: 구현

### 구현 위치

- **파일**: `src/auth/jwt.py`
- **함수**: `create_token(user_id: str) -> str`

### 구현 코드

```python
"""JWT 토큰 생성 및 검증 모듈."""
from datetime import datetime, timedelta
import jwt
from src.config import settings

# 상수 정의
TOKEN_EXPIRY_HOURS = 1
JWT_ALGORITHM = "HS256"


def create_token(user_id: str) -> str:
    """JWT 액세스 토큰을 생성합니다.

    Args:
        user_id: 사용자 고유 ID

    Returns:
        JWT 토큰 문자열 (1시간 유효)

    Raises:
        ValueError: user_id가 빈 문자열인 경우
    """
    if not user_id:
        raise ValueError("user_id cannot be empty")

    payload = _create_payload(user_id)
    return jwt.encode(payload, settings.jwt_secret, algorithm=JWT_ALGORITHM)


def _create_payload(user_id: str) -> dict:
    """JWT payload를 생성합니다.

    Args:
        user_id: 사용자 고유 ID

    Returns:
        JWT payload 딕셔너리
    """
    return {
        "user_id": user_id,
        "exp": datetime.utcnow() + timedelta(hours=TOKEN_EXPIRY_HOURS),
    }
```

### 프로젝트 표준 준수

**참조**: Task 문서 Section 2

- ✅ **structlog**: 에러 발생 시 structlog 사용 (이 모듈은 에러 로깅 불필요)
- ✅ **Pydantic Settings**: `settings.jwt_secret` 사용
- ✅ **Type hints**: 100% 타입 힌트 적용

---

## Step 4: 정적 검증

### 검증 명령어

```bash
# 1. Ruff 검사
ruff check src/auth/jwt.py tests/auth/test_jwt_token.py

# 2. MyPy 검사
mypy src/auth/jwt.py tests/auth/test_jwt_token.py

# 3. Import Linter 검사
import-linter
```

### 기대 결과

- [ ] ruff 0 violations
- [ ] mypy 0 errors
- [ ] import-linter 0 violations (auth 모듈은 domain 계층 의존성 없음)

### 위반 발견 시 조치

**Ruff 위반 예시**:

```bash
# 자동 수정
ruff check --fix src/auth/jwt.py
```

**MyPy 에러 예시**:

```python
# ❌ Before
def create_token(user_id):
    return jwt.encode(...)

# ✅ After
def create_token(user_id: str) -> str:
    return jwt.encode(...)
```

---

## Step 5: 테스트 실행

### 테스트 실행 명령어

```bash
pytest tests/auth/test_jwt_token.py \
    --cov=src/auth/jwt \
    --cov-report=term-missing \
    --cov-fail-under=95 \
    -v
```

### 기대 결과

```
tests/auth/test_jwt_token.py::test_create_token_success PASSED         [ 33%]
tests/auth/test_jwt_token.py::test_create_token_expired PASSED         [ 66%]
tests/auth/test_jwt_token.py::test_create_token_invalid_secret PASSED  [100%]

---------- coverage: platform darwin, python 3.11 ----------
Name                Stmts   Miss  Cover   Missing
-------------------------------------------------
src/auth/jwt.py        15      0   100%
-------------------------------------------------
TOTAL                  15      0   100%

Required test coverage of 95% reached. Total coverage: 100.00%
```

### 체크리스트

- [ ] 모든 테스트 통과 (3/3)
- [ ] Coverage 95%+ 달성 (100%)
- [ ] Missing 라인 없음

---

## Step 6: 리팩토링

### 리팩토링 체크리스트

**코드 구조**:

- [x] 함수 길이 50줄 이하 (create_token: 10줄, _create_payload: 5줄)
- [x] 중첩 depth 3 이하 (최대 depth: 1)
- [x] 하나의 함수는 하나의 책임만

**가독성**:

- [x] 변수명이 명확한가? (payload, user_id 모두 명확)
- [x] 매직 넘버 제거 (TOKEN_EXPIRY_HOURS, JWT_ALGORITHM 상수화)
- [x] 복잡한 조건문 함수로 추출 (해당 없음)

**중복 제거**:

- [x] 반복되는 코드 함수로 추출 (_create_payload 분리)
- [x] 공통 상수 별도 정의 (모듈 최상단에 정의)

### 개선 사항

**개선 전** (Task 문서 구현 힌트):

```python
def create_token(user_id: str) -> str:
    payload = {
        "user_id": user_id,
        "exp": datetime.utcnow() + timedelta(hours=1),
    }
    return jwt.encode(payload, settings.jwt_secret, algorithm="HS256")
```

**개선 후** (Step 3 구현):

- ✅ 상수 분리 (`TOKEN_EXPIRY_HOURS`, `JWT_ALGORITHM`)
- ✅ Payload 생성 함수 분리 (`_create_payload`)
- ✅ Validation 추가 (`user_id` 빈 문자열 체크)
- ✅ Docstring 추가 (Google 스타일)

---

## Step 7: 재테스트

### 전체 검증 재실행

```bash
# 1. 정적 검증
ruff check src/auth/jwt.py tests/auth/test_jwt_token.py
mypy src/auth/jwt.py tests/auth/test_jwt_token.py
import-linter

# 2. 테스트 + 커버리지
pytest tests/auth/test_jwt_token.py \
    --cov=src/auth/jwt \
    --cov-report=term-missing \
    --cov-fail-under=95
```

### 최종 확인

- [ ] ruff 0 violations ✅
- [ ] mypy 0 errors ✅
- [ ] import-linter 0 violations ✅
- [ ] pytest 모든 테스트 통과 (3/3) ✅
- [ ] coverage 100% 달성 ✅

### 회귀 테스트

리팩토링으로 인한 동작 변경 없음 확인:

- [ ] `create_token("user123")` 여전히 유효한 토큰 반환
- [ ] 만료 시간 여전히 1시간
- [ ] 알고리즘 여전히 HS256

---

## Step 8: 문서화

### Docstring (Google 스타일)

**이미 Step 3에서 작성 완료**:

```python
def create_token(user_id: str) -> str:
    """JWT 액세스 토큰을 생성합니다.

    Args:
        user_id: 사용자 고유 ID

    Returns:
        JWT 토큰 문자열 (1시간 유효)

    Raises:
        ValueError: user_id가 빈 문자열인 경우
    """
```

### 사용 예시 추가 (Docstring에 Example 섹션)

```python
def create_token(user_id: str) -> str:
    """JWT 액세스 토큰을 생성합니다.

    Args:
        user_id: 사용자 고유 ID

    Returns:
        JWT 토큰 문자열 (1시간 유효)

    Raises:
        ValueError: user_id가 빈 문자열인 경우

    Example:
        >>> from src.auth.jwt import create_token
        >>> token = create_token("user123")
        >>> print(token[:20])  # 토큰 앞부분 출력
        'eyJhbGciOiJIUzI1NiI...'

        >>> # 토큰 검증 예시
        >>> import jwt
        >>> from src.config import settings
        >>> decoded = jwt.decode(token, settings.jwt_secret, algorithms=["HS256"])
        >>> print(decoded["user_id"])
        'user123'
    """
```

### README 업데이트 (필요 시)

`docs/auth/JWT_USAGE.md` 생성:

```markdown
# JWT 토큰 사용 가이드

## 개요
이 모듈은 HS256 알고리즘을 사용하여 JWT 액세스 토큰을 생성합니다.

## 기본 사용법

### 토큰 생성
\```python
from src.auth.jwt import create_token

token = create_token("user123")
print(f"Generated token: {token}")
\```

### 토큰 검증
\```python
import jwt
from src.config import settings

try:
    decoded = jwt.decode(token, settings.jwt_secret, algorithms=["HS256"])
    user_id = decoded["user_id"]
    print(f"Valid token for user: {user_id}")
except jwt.ExpiredSignatureError:
    print("Token expired")
except jwt.InvalidSignatureError:
    print("Invalid token")
\```

## 설정

### 환경 변수
\```bash
# .env 파일
JWT_SECRET=your-secret-key-here
\```

### Settings 클래스
\```python
from pydantic_settings import BaseSettings

class Settings(BaseSettings):
    jwt_secret: str

settings = Settings()
\```

## 주의사항
- ⚠️ `JWT_SECRET`은 최소 32자 이상 강력한 암호를 사용하세요
- ⚠️ Production 환경에서는 반드시 HTTPS를 사용하세요
- ⚠️ 토큰은 1시간 후 자동 만료됩니다 (Refresh token 구현 권장)

## 관련 Task
- **T2.2.1**: JWT 토큰 검증 모듈
- **T2.2.3**: Login 엔드포인트 (이 모듈 사용)
```

---

## Step 9: 커밋

### 커밋 전 최종 확인

```bash
# 변경된 파일 확인
git status

# 예상 결과:
# new file:   src/auth/jwt.py
# new file:   tests/auth/test_jwt_token.py
# new file:   docs/auth/JWT_USAGE.md
```

### Git 커밋

```bash
# 파일 추가
git add src/auth/jwt.py tests/auth/test_jwt_token.py docs/auth/JWT_USAGE.md

# Conventional Commit 메시지로 커밋
git commit -m "feat(auth): Add JWT token generation module

- Implement create_token() function with HS256 algorithm
- Add TOKEN_EXPIRY_HOURS and JWT_ALGORITHM constants
- Extract _create_payload() for better testability
- Add 3 test cases: success, expired, invalid secret
- Achieve 100% test coverage
- Add comprehensive docstring with usage examples
- Create JWT usage guide documentation

Standards compliance:
- ruff 0 violations
- mypy 0 errors
- import-linter 0 violations
- pytest coverage 100%

Closes T2.1.1"
```

### Pre-commit Hook 검증

Pre-commit hooks 자동 실행:

```
[ruff] ................................................ Passed
[mypy] ................................................ Passed
[import-linter] ....................................... Passed
[pytest] .............................................. Passed
  - All tests passed (3/3)
  - Coverage: 100%
[commit-msg] .......................................... Passed
```

### 커밋 성공 확인

```bash
git log -1 --oneline
# f8a9c21 feat(auth): Add JWT token generation module

git show --stat
# 파일 변경 내역 확인
```

---

## 완료 확인

- [x] Step 1: 목표 이해 완료
- [x] Step 2: 테스트 3개 작성 완료
- [x] Step 3: 구현 완료 (create_token, _create_payload)
- [x] Step 4: 정적 검증 통과 (ruff 0, mypy 0, import-linter 0)
- [x] Step 5: 테스트 실행 통과 (100% coverage)
- [x] Step 6: 리팩토링 완료 (상수 분리, 함수 분리)
- [x] Step 7: 재테스트 통과 (모든 검증 재확인)
- [x] Step 8: 문서화 완료 (docstring + README)
- [x] Step 9: Git 커밋 성공

### 최종 산출물

✅ `src/auth/jwt.py` - JWT 토큰 생성 모듈 (100% coverage)
✅ `tests/auth/test_jwt_token.py` - 테스트 3개 (모두 통과)
✅ `docs/auth/JWT_USAGE.md` - 사용 가이드
✅ Git commit `f8a9c21` - Task T2.1.1 완료

**Task T2.1.1 완료! 다음 Task로 진행 가능.**
````

---

## 6. Checklist 작성 완료 검증

```markdown
### 완성도 체크리스트

**기본 요구사항**:

- [ ] 9-Step 모두 포함
- [ ] 각 Step마다 질문, 산출물, 도구 명시
- [ ] Task 문서와 명확히 연결 (Section 참조)

**실행 가능성**:

- [ ] AI가 이 Checklist만으로 작업 가능
- [ ] 모든 명령어가 실행 가능 (복사-붙여넣기 가능)
- [ ] 검증 기준이 명확 (✅/❌ 판단 가능)

**Task 문서 연결**:

- [ ] Section 1 (청사진) → Step 1 목표 이해
- [ ] Section 2 (표준) → Step 3, 4 준수 확인
- [ ] Section 3 (도구) → Step 2-5 사용
- [ ] Section 4 (입출력) → Step 1 목표, Step 8 문서화
- [ ] Section 5 (조립) → Step 1 이해 (의존성 파악)
- [ ] Section 6 (완성 기준) → Step 1, 7 검증
- [ ] Section 7 (구현 힌트) → Step 3 구현
- [ ] Section 8 (예상 시간) → Checklist 메타정보

**품질 검증**:

- [ ] Step 4: ruff, mypy, import-linter 명령어 정확
- [ ] Step 5: pytest coverage 명령어 정확
- [ ] Step 6-7: 리팩토링 후 재검증 포함
- [ ] Step 9: Conventional commit 형식 준수

### 흔한 실수 체크

**❌ 피해야 할 패턴**:

- Step 2에서 테스트 작성 없이 "테스트 작성 예정" 표시
- Step 3 구현이 너무 추상적 (실제 코드 없음)
- Step 4-7 검증 명령어 누락
- Step 8 docstring 없이 "문서화 완료" 표시
- Step 9 커밋 메시지가 Conventional Commit 형식 위반

**✅ 올바른 패턴**:

- 모든 Step에 실제 코드 또는 명령어 포함
- 검증 기준이 숫자로 명확 (ruff 0, coverage 95%+)
- Task 문서 내용을 직접 복사-참조
- 예시 코드가 실행 가능
```

## 7. Checklist와 Task 문서의 관계

### 정보 흐름

```markdown
Blueprint (5000 lines, 전체 설계)
    ↓
Task 문서 (100 lines, 이 작업만)
    ├─ Section 1: 청사진 참조 → "Blueprint Line 145-178만 읽어"
    ├─ Section 2: 표준 참조 → "PROJECT_STANDARDS.md Line 12-25만 읽어"
    ├─ Section 3: 도구 → "PyJWT 사용해"
    ├─ Section 4: 입출력 → "user_id 받아서 token 반환해"
    ├─ Section 5: 조립 → "T2.2.1, T2.2.3이 이걸 사용해"
    ├─ Section 6: 완성 기준 → "함수 작동 + 테스트 3개 + 0 위반"
    ├─ Section 7: 구현 힌트 → "이렇게 만들어"
    └─ Section 8: 예상 시간 → "2-3시간"
    ↓
Checklist (실행 지시서)
    ├─ Step 1: Task 문서 이해
    ├─ Step 2: 테스트 작성 (Given-When-Then)
    ├─ Step 3: 구현 (Section 7 힌트 사용)
    ├─ Step 4: 정적 검증 (ruff, mypy, import-linter)
    ├─ Step 5: 테스트 실행 (pytest coverage)
    ├─ Step 6: 리팩토링
    ├─ Step 7: 재테스트
    ├─ Step 8: 문서화
    └─ Step 9: 커밋
    ↓
완성된 코드 + 테스트 + 문서
```
### Necessary Information Only 원칙

**Blueprint (5000 lines)**:
- AI가 읽을 필요 없음 (너무 많음)
- Task 문서가 필요한 부분만 추출함

**Task 문서 (100 lines)**:
- AI가 읽어야 함
- "무엇을" 만들지 정의

**Checklist (실행 단계)**:
- AI가 따라야 함
- "어떻게" 만들지 단계별 지시

**핵심**: AI는 Blueprint를 직접 읽지 않고, Task 문서와 Checklist만으로 작업 완수 가능

---

## 8. 추가 참고 자료

### 관련 문서
- **CORE_METHODOLOGY.md Section 3**: 9-Step Checklist 상세 설명
- **TASK_BREAKDOWN_GUIDE.md**: Task 문서 작성 방법
- **PROJECT_STANDARDS.md**: 프로젝트 표준 (structlog, Pydantic, 아키텍처 규칙)

### 도구 문서
- **pytest**: https://docs.pytest.org/
- **ruff**: https://docs.astral.sh/ruff/
- **mypy**: https://mypy.readthedocs.io/
- **import-linter**: https://import-linter.readthedocs.io/

### Conventional Commit

```
<type>(<scope>): <subject>

<body>

<footer>
```
**Type**:

- `feat`: 새 기능
- `fix`: 버그 수정
- `refactor`: 리팩토링
- `test`: 테스트 추가
- `docs`: 문서화

**Scope**: 변경된 모듈 (auth, payment, user 등)

**Footer**: `Closes T2.1.1` 형식으로 Task 참조

---

## 마무리

이 가이드를 사용하여:
1. **Task 문서 읽기** (TASK_BREAKDOWN_GUIDE 참조)
2. **Checklist 템플릿 복사** (Section 4)
3. **9-Step 순서대로 작성** (Section 3 참조)
4. **실전 예시 참고** (Section 5)
5. **검증 체크리스트 확인** (Section 6)

**핵심 원칙**:
- ✅ **실행 가능**: 모든 명령어가 복사-붙여넣기 가능
- ✅ **자급자족**: Task 문서 + Checklist만으로 완수 가능
- ✅ **검증 가능**: 0 violations, 95%+ coverage 명확히 확인

Happy coding! 🚀


================================================================================
# End of 09G-00_checklist_guide.md
================================================================================

