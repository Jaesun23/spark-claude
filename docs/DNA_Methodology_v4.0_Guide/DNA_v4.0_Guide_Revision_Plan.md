# DNA v4.0 가이드 전체 수정 계획

**작성일**: 2025-11-14
**작성자**: 2호
**목적**: Stage 1-9 가이드 전체 수정을 위한 상세 계획 및 실행 가이드

---

## 📋 목차

1. [문제점 분석 (Jason의 5가지 지적사항)](#1-문제점-분석)
2. [DNA v4.0 프로젝트 분해 체계 정의](#2-dna-v40-프로젝트-분해-체계-정의)
3. [5대 수정 원칙](#3-5대-수정-원칙)
4. [Stage별 상세 수정 항목](#4-stage별-상세-수정-항목)
5. [작업 우선순위 및 실행 계획](#5-작업-우선순위-및-실행-계획)

---

## 1. 문제점 분석

### 1.1 패밀리 개수 오류 (6개 → 7개)

#### 현황
```markdown
# 원본 (01G-00_core_definition_guide.md:186, 234)
> **목표**: 시스템의 본질을 파악하여 6가지 패밀리 중 하나로 분류
...
**6가지 아키텍처 패밀리**:
```

#### 원인
- 1호가 연구를 통해 7개 패밀리로 확정했으나 반영 안 됨
- 초기 6개 패밀리 버전이 그대로 유지됨

#### 영향도
- **심각** 🔴
- 사실 오류로 인한 잘못된 분류 가능성
- 신규 패밀리 (A-A-B, A-B-A) 누락

#### 수정 범위
- `01G-00_core_definition_guide.md`
- 관련 Manual, Case 문서
- 다른 Stage에서 패밀리 언급하는 부분

#### 수정 방법

**Before**:
```markdown
**6가지 아키텍처 패밀리**:
1. CRUD/트랜잭션 (A-A-A)
2. 검색/추천 (C-B-B)
3. 실시간 스트리밍 (B-C-A)
4. 협업/동기화 (B-A-A)
5. 분석/배치 (C-C-C)
6. 실시간 트랜잭션 (A-C-A)
```

**After** (Jason 수정본 기준):
```markdown
**7가지 아키텍처 패밀리**:

| 패밀리 코드 | 패밀리 이름     | 대표 사례                    | 핵심 기술                  |
| ----------- | --------------- | ---------------------------- | -------------------------- |
| **A-A-A**   | 초고속 거래     | NASDAQ 매칭 엔진 (14μs)      | FPGA, 코로케이션           |
| **A-A-B**   | 트랜잭션/CRUD   | Amazon 주문, 은행 ATM        | PostgreSQL, 마이크로서비스 |
| **B-A-A**   | 협업/동기화     | Google Docs, Figma           | CRDT, WebSocket            |
| **B-B-B**   | 검색/추천       | Elasticsearch, AI 외부메모리 | 벡터 DB, 역인덱스          |
| **B-C-A**   | 실시간 스트리밍 | Netflix RDG, Uber GPS        | Kafka, Flink               |
| **B-A-C**   | 분석/배치       | Snowflake, BigQuery          | MPP, ETL                   |
| **A-B-A**   | 안전-임계 IoT   | 산업 제어, 긴급 경보         | MQTT, SCADA                |
```

---

### 1.2 문서 분리 미반영 (Guide/Manual/Case)

#### 현황
```markdown
# 원본은 이미 반영되어 있음!
## 📚 이 가이드의 구성
- **이 문서** (Guide): 질문 템플릿 + 작성 원칙 (간결)
- **해설서** (Manual): 왜? 어떻게? 상세 설명 → `01M-01_layer1_manual.md`, `01M-02_layer2_manual.md`
- **사례집** (Cases): 전체 흐름 실전 예시 → `02E-01_stock_trading_case.md`
```

#### 원인
- 사실 Stage 1은 이미 반영되어 있음
- 하지만 Jason 지적 = 다른 Stage들도 확인 필요

#### 영향도
- **중간** 🟡
- 문서 분리 의도를 사용자/Agent가 모를 수 있음
- 1000-1500줄 원칙의 배경 이해 부족

#### 수정 범위
- Stage 2-9 모든 가이드 파일
- 각 가이드 시작 부분에 "📚 이 가이드의 구성" 섹션 추가

#### 수정 방법

**표준 템플릿** (모든 Stage에 적용):
```markdown
## 📚 이 가이드의 구성

DNA 방법론은 2호의 컨텍스트 한계(200K tokens)를 고려하여 문서를 분리합니다:

- **이 문서** (Guide): 질문 템플릿 + 작성 원칙 (간결, 1000-1500줄)
  - **목적**: 빠른 참조, 독립 실행 가능
  - **대상**: 실무 작업 시 필수 참고

- **해설서** (Manual): 왜? 어떻게? 상세 설명
  - **목적**: 깊은 이해, 애매한 상황 해결
  - **위치**: `./0XM-0Y_*.md` (예: `./02M-01_layer3_manual.md`)

- **사례집** (Cases): 실전 프로젝트 전체 흐름
  - **목적**: 전체 맥락 이해, 참고 예시
  - **위치**: `./0XE-0Y_*.md` (예: `./02E-01_stock_trading_case.md`)

**원칙**: Guide만 봐도 작성 가능, Manual/Case는 필요시에만 참고
```

---

### 1.3 참조 경로 불명확 (라인 수 누락)

#### 현황
```markdown
# 원본
**상세 설명**: Manual 1.2절 참고

# Jason 수정본
**상세 설명**: **Manual**(`01M-01_layer1_manual.md`) 1.2절 참고
```

#### 원인
- 초기 작성 시 경로만 제공
- 라인 수 필요성 인식 못 함
- Jason: "이러면 2호나 에이전트가 메뉴얼을 찾아볼까요? 안본다에 걸겠습니다."

#### 영향도
- **심각** 🔴
- Agent/2호가 실제로 참조하지 않을 가능성 높음
- 청사진/작업분해/체크리스트에서도 동일한 원칙

#### 수정 범위
- 모든 가이드의 참조 링크
- 청사진, 작업분해, 체크리스트 예시

#### 수정 방법

**Before**:
```markdown
**상세 설명**: Manual 1.2절 참고
**참고**: ADR-116 참고
**활용**: Blueprint Section 3.2 참고
```

**After**:
```markdown
**상세 설명**: **Manual**(`./01M-01_layer1_manual.md:45-78`) 1.2절 참고
**참고**: **ADR**(`docs/adr/domain/03A-116_order_schema.md:12-45`) 참고
**활용**: **Blueprint**(`07B-01_project_blueprint.md:234-289`) Section 3.2 참고
```

**표준 형식**:
```
**참조명**(`경로:시작줄-끝줄`) 섹션/절 번호 참고
```

**실행 가능성**:
- Agent가 정확한 파일과 라인을 즉시 찾을 수 있음
- Read tool에 offset/limit으로 바로 적용 가능

---

### 1.4 가이드 내용 및 논리적 흐름

#### 현황

**원본 Part 0**:
```markdown
## Part 0: 핵심 기능 파악 ⭐

### Q0-1. 이 시스템의 존재 이유는 무엇인가?
```

**Jason 수정본**:
```markdown
## Part 0: 핵심 기능 파악 ⭐

프로젝트의 시작은 아주 간단한 아이디어가 떠올라 그걸 실현시키고 싶을 때,
또는 어떤 일의 불편함이나 문제를 인식하고 그걸 해결하려고 할 때 시작하게 됩니다.
먼저 아이디어나 문제와 해결방법, 추가 요구사항을 접수하세요.

- 프로젝트 아이디어 (간단한 설명)
- 해결하고자 하는 문제
- 기본적인 요구사항 (선택적)

이제부터 접수된 내용에서 가장 '근원적인 기능'과 그 기능을 통해 무엇을 이루려고 하는 것인지
그 '목적'을 파악해 내야 합니다. 그 방법은 질문을 던져서 찾아냅니다.

---

### Q. 이 시스템은 무엇을 하기 위한 시스템인가요?
```

#### 원인
- 원본: 질문만 나열 (맥락 부족)
- 수정본: 왜 이 질문을 하는지, 어떤 흐름인지 설명

#### 영향도
- **중간** 🟡
- 이해도 차이 발생
- 독립 실행 가능성 저하

#### 수정 범위
- 모든 Part/Section 시작 부분
- 맥락 설명 추가

#### 수정 방법

**원칙**:
1. 각 Part 시작 시 "왜 이 Part가 필요한가" 설명
2. 흐름을 자연스럽게 연결
3. 질문의 목적 명시

**Before**:
```markdown
## Layer 1: 아키텍처 패밀리 식별

### L1-Q1. 핵심 기능이 실패하면 얼마나 치명적인가?
```

**After**:
```markdown
## Part 1: 시스템의 패밀리 유형 파악

Part 0에서 핵심 기능을 파악했습니다. 이제 이 시스템이 **어떤 종류의 시스템인지** 파악해야 합니다.

DNA 방법론에서는 모든 소프트웨어 시스템을 3가지 핵심 차원으로 분류하여
7가지 패밀리로 구분합니다. 패밀리를 정하면 기술 스택이 자동으로 좁혀집니다.

### 3-Layer Decision Tree

3가지 질문에 답하면 패밀리가 자동으로 결정됩니다:

#### Layer 1: 실패의 파급력 (Failure Impact)

**핵심 질문**: "이 시스템이 5분간 멈추면 어떻게 되나요?"

... (질문 내용)
```

---

### 1.5 구조 용어 혼란 ⭐ (가장 심각)

#### 현황

**원본 구조**:
```
Part 0: 핵심 기능 파악
Layer 1: 아키텍처 패밀리 식별  ← Part 1이 아님!
Layer 2: NFR 우선순위          ← Part 2가 아님!
```

**Jason 수정본**:
```
Part 0: 핵심 기능 파악
Part 1: 패밀리 유형 파악
  └─ 3-Layer Decision Tree (Layer 1, 2, 3)
Part 2: NFR 우선순위
```

#### 원인
- Part와 Layer 개념 혼재
- 3-Layer Decision Tree의 Layer와 Part의 Layer가 충돌

#### 영향도
- **최고** 🔴🔴🔴
- 근본적 구조 문제
- 모든 문서에 영향

#### 수정 범위
- DNA v4.0 프로젝트 분해 체계 정의 필수
- 모든 Stage 재검토

#### 수정 방법

다음 섹션에서 상세히 다룸 (Section 2)

---

## 2. DNA v4.0 프로젝트 분해 체계 정의

### 2.1 v3.6 vs v4.0 비교

#### v3.6 체계 (Jason 제공)
```
Project (전체 건물) - 문제해결을 위한 시스템
└── Stage (층) - 진화 단계
    └── Phase (방) - 기능 영역
        └── Task (가구/레고블럭) ← 핵심! 기능적 작동 단위
            └── Step (조립 단계) - 9-Step 중 하나
                └── Action (나사 조이기) - 구체적 행동
                    └── Sub_Action (드라이버 돌리기) - 세부 행동
```

**파일명 예시**: `D1.P2.T3` = 1번 도메인의 2페이즈 3번째 작업

#### v4.0 현재 상태 (혼란)
```
Methodology
└─ Stage (9개)
    └─ ??? (Part? Layer?)
```

### 2.2 DNA v4.0 체계 정의 (제안)

```
DNA Methodology v4.0
└─ Stage (큰 단계, 9개: Stage 1~9)
    └─ Part (Stage 내부 파트, 0~N)
        └─ Layer (특수 개념, Part 1 전용)
            └─ Question (실제 질문, Q0-1, L1-Q1, P2-Q1)
                └─ Answer (A/B/C 선택)
```

### 2.3 용어 사전

| 용어 | 정의 | 범위 | 예시 |
|------|------|------|------|
| **Stage** | 방법론의 큰 단계 | 1~9 | Stage 1 (핵심정의), Stage 2 (구조설계) |
| **Part** | Stage 내부 파트 | 0~N | Part 0 (핵심 기능), Part 1 (패밀리), Part 2 (NFR) |
| **Layer** | 3-Layer Decision Tree의 계층 | Part 1 전용 | Layer 1 (실패 파급력), Layer 2 (데이터 형태), Layer 3 (응답 시점) |
| **Question** | 실제 질문 | 각 Part/Layer별 | Q0-1, L1-Q1, L1-Q2, L1-Q3, P2-Q1 |

**핵심 원칙**:
- **Layer는 Part 1에서만 사용**: 3-Layer Decision Tree는 특수 개념
- **다른 Part는 Layer 사용 금지**: Part 0 = Q0-X, Part 2 = P2-QX
- **일관성 유지**: 모든 Stage에서 동일한 명명 규칙

### 2.4 Stage 1 예시 (정확한 구조)

```
Stage 1: 핵심정의 (Core Definition)
│
├─ Part 0: 핵심 기능 파악
│   ├─ Q0-1: 이 시스템은 무엇을 하기 위한 시스템인가요?
│   └─ Q0-2: (선택적) 실패하면 어떤 영향?
│
├─ Part 1: 패밀리 유형 파악
│   │
│   └─ 3-Layer Decision Tree (특수 구조)
│       │
│       ├─ Layer 1: 실패의 파급력
│       │   └─ L1-Q1: 시스템이 5분간 멈추면?
│       │       ├─ A: 치명적
│       │       └─ B: 점진적
│       │
│       ├─ Layer 2: 데이터의 형태
│       │   └─ L1-Q2: 데이터베이스 스키마를 미리 정의 가능?
│       │       ├─ A: 구조화
│       │       ├─ B: 반구조화
│       │       └─ C: 비구조화
│       │
│       └─ Layer 3: 응답 시점
│           └─ L1-Q3: 사용자가 결과를 얼마나 빨리 기대?
│               ├─ A: 밀리초
│               ├─ B: 수초
│               └─ C: 배치
│       │
│       └─ 결과: 7가지 패밀리 (A-A-A, A-A-B, B-A-A, B-B-B, B-C-A, B-A-C, A-B-A)
│
└─ Part 2: NFR 우선순위
    ├─ P2-Q1: 핵심 품질은? (A/B/C)
    ├─ P2-Q2: 사용자 규모는? (A/B/C)
    ├─ P2-Q3: 데이터 노출 수준은? (A/B/C)
    └─ P2-Q4: 데이터 최신성은? (A/B/C)
    └─ 결과: NFR 프로파일 (A-B-B-A)
```

**출력 문서 (4개)**:
1. `01F-01_core_functions.md` (Part 0 결과)
2. `01C-01_family_classification.md` (Part 1 결과)
3. `01C-02_nfr_profile.md` (Part 2 결과)
4. `01D-01_tech_candidates.md` (패밀리 기반 기술 후보)

---

## 3. 5대 수정 원칙

### 원칙 1: 프로젝트 분해 체계 명확화

**적용 대상**: 모든 Stage

**내용**:
- DNA v4.0 체계 문서 작성 (`00_PROJECT_STRUCTURE.md`)
- 모든 가이드에서 일관된 용어 사용
- Part, Layer, Question 명명 규칙 준수

**검증**:
- [ ] 00_PROJECT_STRUCTURE.md 작성 완료
- [ ] 모든 가이드에서 Part/Layer 올바르게 사용
- [ ] 용어 혼재 0건

---

### 원칙 2: 문서 구성 명시 (1000-1500줄 원칙)

**적용 대상**: Stage 1-9 모든 가이드

**내용**:
- 각 가이드 시작 부분에 "📚 이 가이드의 구성" 섹션 추가
- Guide/Manual/Case 역할 및 경로 명시
- 1000-1500줄 원칙 설명

**표준 템플릿**:
```markdown
## 📚 이 가이드의 구성

DNA 방법론은 2호의 컨텍스트 한계(200K tokens)를 고려하여 문서를 분리합니다:

- **이 문서** (Guide): 질문 템플릿 + 작성 원칙 (간결, 1000-1500줄)
  - **목적**: 빠른 참조, 독립 실행 가능
  - **대상**: 실무 작업 시 필수 참고

- **해설서** (Manual): 왜? 어떻게? 상세 설명
  - **목적**: 깊은 이해, 애매한 상황 해결
  - **위치**: `./0XM-0Y_*.md`

- **사례집** (Cases): 실전 프로젝트 전체 흐름
  - **목적**: 전체 맥락 이해, 참고 예시
  - **위치**: `./0XE-0Y_*.md`

**원칙**: Guide만 봐도 작성 가능, Manual/Case는 필요시에만 참고
```

**검증**:
- [ ] 9개 가이드 모두 섹션 추가
- [ ] 경로 정확성 확인
- [ ] 일관된 설명

---

### 원칙 3: 참조 경로 완전 명시

**적용 대상**: 모든 참조 링크

**내용**:
- 파일명 + 라인 범위 필수
- 실행 가능성 보장

**표준 형식**:
```markdown
**참조명**(`경로:시작줄-끝줄`) 섹션/절 번호 참고
```

**예시**:
```markdown
**상세 설명**: **Manual**(`./01M-01_layer1_manual.md:45-78`) 1.2절 참고
**참고**: **ADR**(`docs/adr/domain/03A-116_order_schema.md:12-45`) 참고
**활용**: **Blueprint**(`07B-01_project_blueprint.md:234-289`) Section 3.2 참고
```

**검증**:
- [ ] 모든 Manual 참조 라인 수 추가
- [ ] 모든 ADR 참조 라인 수 추가
- [ ] 청사진/작업분해/체크리스트 예시 업데이트

---

### 원칙 4: 가이드 내용 충실화

**적용 대상**: 모든 Part/Section 시작 부분

**내용**:
1. 각 Part 시작 시 맥락 설명
2. 왜 이 Part가 필요한지
3. 이전 Part와의 연결
4. 질문의 목적

**Before**:
```markdown
## Layer 1: 아키텍처 패밀리 식별

### L1-Q1. 핵심 기능이 실패하면 얼마나 치명적인가?
```

**After**:
```markdown
## Part 1: 시스템의 패밀리 유형 파악

Part 0에서 핵심 기능을 파악했습니다. 이제 이 시스템이 **어떤 종류의 시스템인지** 파악해야 합니다.

DNA 방법론에서는 모든 소프트웨어 시스템을 3가지 핵심 차원으로 분류하여
7가지 패밀리로 구분합니다. 패밀리를 정하면 기술 스택이 자동으로 좁혀집니다.

### 3-Layer Decision Tree

3가지 질문에 답하면 패밀리가 자동으로 결정됩니다:

#### Layer 1: 실패의 파급력 (Failure Impact)

**핵심 질문**: "이 시스템이 5분간 멈추면 어떻게 되나요?"

(질문 내용...)
```

**검증**:
- [ ] 모든 Part에 맥락 추가
- [ ] 자연스러운 흐름 확인
- [ ] Jason 수정본과 비교

---

### 원칙 5: 구조 일관성

**적용 대상**: 모든 Stage

**내용**:
- Stage → Part → Layer/Question 계층 준수
- Layer는 Part 1에서만 사용
- 명명 규칙 일관성

**명명 규칙**:
```
Part 0: Q0-1, Q0-2, ...
Part 1: L1-Q1, L1-Q2, L1-Q3 (3-Layer Decision Tree)
Part 2: P2-Q1, P2-Q2, P2-Q3, P2-Q4
Part 3: P3-Q1, P3-Q2, ...
```

**검증**:
- [ ] 모든 질문 번호 일관성
- [ ] Layer 오용 0건
- [ ] Part 구분 명확

---

## 4. Stage별 상세 수정 항목

### 4.1 Stage 1: 핵심정의 (Core Definition)

#### 파일
- `01G-00_core_definition_guide.md`

#### 수정 항목 체크리스트

**A. 구조 수정**:
- [ ] 제목: "00." → "Stage1."
- [ ] Part 0, Part 1, Part 2 명확화
- [ ] Layer는 Part 1 안에만 사용
- [ ] 3-Layer Decision Tree 제목 명시

**B. 패밀리 개수**:
- [ ] "6가지" → "7가지" 전체 변경
- [ ] 7개 패밀리 표 업데이트 (Jason 수정본)
- [ ] 플로우차트 추가

**C. 문서 구성**:
- [ ] "📚 이 가이드의 구성" 이미 있음 (확인만)
- [ ] Manual 경로 확인

**D. 참조 경로**:
- [ ] "Manual 1.2절" → "**Manual**(`./01M-01_layer1_manual.md:45-78`) 1.2절"
- [ ] 모든 Manual 참조 라인 수 추가 (약 10곳)

**E. 내용 충실화**:
- [ ] Part 0 앞에 맥락 설명 (Jason 수정본)
- [ ] Part 1 시작 부분 설명 추가
- [ ] Part 2 시작 부분 설명 추가
- [ ] 각 Layer 설명 강화

**F. Before/After 예시**:

**Before** (line 137-162):
```markdown
## Part 0: 핵심 기능 파악 ⭐

### Q0-1. 이 시스템의 존재 이유는 무엇인가?

**작성 원칙**:
- 가장 **원자적인 기능**만 파악하세요
...
```

**After** (Jason 수정본 line 68-99):
```markdown
## Part 0: 핵심 기능 파악 ⭐

프로젝트의 시작은 아주 간단한 아이디어가 떠올라 그걸 실현시키고 싶을 때,
또는 어떤 일의 불편함이나 문제를 인식하고 그걸 해결하려고 할 때 시작하게 됩니다.
먼저 아이디어나 문제와 해결방법, 추가 요구사항을 접수하세요.

- 프로젝트 아이디어 (간단한 설명)
- 해결하고자 하는 문제
- 기본적인 요구사항 (선택적)

이제부터 접수된 내용에서 가장 '근원적인 기능'과 그 기능을 통해 무엇을 이루려고 하는 것인지
그 '목적'을 파악해 내야 합니다. 그 방법은 질문을 던져서 찾아냅니다.

------

### Q. 이 시스템은 무엇을 하기 위한 시스템인가요?

**작성 원칙**:
- 가장 **원자적인 기능(핵심기능)**만 파악하세요
...
```

---

### 4.2 Stage 2: 구조설계 (Structure Design)

#### 파일
- `02G-00_structure_design_guide.md`

#### 점검 필요 사항
- [ ] Part 구조 확인 (Layer 3가 Stage 2로 이동했다고 함)
- [ ] "📚 이 가이드의 구성" 추가 필요 여부
- [ ] Manual 참조 라인 수 추가
- [ ] 맥락 설명 보강

---

### 4.3 Stage 3: ADR 작성

#### 파일
- `03G-00_adr_guide.md`

#### 점검 필요 사항
- [ ] Part 구조 있는지 확인
- [ ] "📚 이 가이드의 구성" 추가 필요 여부
- [ ] Manual 참조 라인 수 추가
- [ ] ADR 템플릿 검증

---

### 4.4 Stage 4: DNA 시스템 계획

#### 파일
- `04G-00_dna_planning_guide.md`

#### 점검 필요 사항
- [ ] Part 구조 확인
- [ ] "📚 이 가이드의 구성" 추가 필요 여부
- [ ] Manual 참조 라인 수 추가

---

### 4.5 Stage 5: DNA 시스템 구현

#### 파일
- `05G-00_dna_implementation_guide.md`

#### 점검 필요 사항
- [ ] Part 구조 확인
- [ ] "📚 이 가이드의 구성" 추가 필요 여부
- [ ] Manual 참조 라인 수 추가

---

### 4.6 Stage 6: 프로젝트 표준

#### 파일
- `06G-00_project_standards_guide.md`

#### 점검 필요 사항
- [ ] Part 구조 확인
- [ ] "📚 이 가이드의 구성" 추가 필요 여부
- [ ] Manual 참조 라인 수 추가
- [ ] 이미 수정한 입출력 재확인

---

### 4.7 Stage 7: 청사진

#### 파일
- `07G-00_blueprint_guide.md`

#### 점검 필요 사항
- [ ] Part 구조 확인
- [ ] "📚 이 가이드의 구성" 추가 필요 여부
- [ ] Manual 참조 라인 수 추가
- [ ] Level 3 스켈레톤 설명 확인

---

### 4.8 Stage 8: 작업 분해

#### 파일
- `08G-00_task_breakdown_guide.md`

#### 점검 필요 사항
- [ ] Part 구조 확인
- [ ] "📚 이 가이드의 구성" 추가 필요 여부
- [ ] Manual 참조 라인 수 추가
- [ ] Task 템플릿 검증

---

### 4.9 Stage 9: 체크리스트

#### 파일
- `09G-00_checklist_guide.md`

#### 점검 필요 사항
- [ ] Part 구조 확인
- [ ] "📚 이 가이드의 구성" 추가 필요 여부
- [ ] Manual 참조 라인 수 추가
- [ ] TDD 9-Step 검증

---

## 5. 작업 우선순위 및 실행 계획

### 5.1 우선순위

#### Priority 1: 긴급 (즉시 수정)
1. **DNA v4.0 프로젝트 분해 체계 문서 작성**
   - `00_PROJECT_STRUCTURE.md` 생성
   - 모든 가이드의 기준이 됨

2. **Stage 1 수정 완료**
   - Jason 수정본 기준으로 완전 반영
   - 패밀리 7개 업데이트
   - Part/Layer 구조 명확화

#### Priority 2: 중요 (순차 수정)
3. **Stage 2-9 구조 점검 및 수정**
   - Part 구조 확인
   - Layer 오용 제거

4. **모든 Manual 참조 라인 수 추가**
   - Stage 1-9 전체

5. **"📚 이 가이드의 구성" 섹션 추가**
   - 누락된 Stage에 추가

#### Priority 3: 개선 (점진적)
6. **내용 충실화**
   - 맥락 설명 보강
   - 흐름 개선

### 5.2 실행 순서

#### Phase 1: 기반 작업 (1-2시간)
1. `00_PROJECT_STRUCTURE.md` 작성
2. 이 계획 문서 Jason 리뷰

#### Phase 2: Stage 1 완전 수정 (2-3시간)
1. Jason 수정본 완전 반영
2. 5대 원칙 모두 적용
3. 검증

#### Phase 3: Stage 2-9 순차 수정 (Stage당 1-2시간)
1. Stage 2부터 순차 진행
2. 각 Stage마다:
   - 구조 점검
   - 5대 원칙 적용
   - 검증

#### Phase 4: 최종 검증 (1시간)
1. 전체 일관성 확인
2. 용어 통일 확인
3. Jason 최종 리뷰

### 5.3 검증 방법

#### 자동 검증 (Grep)
```bash
# Part/Layer 오용 확인
grep -n "Layer [0-9]:" 0*G-00_*.md | grep -v "Part 1"

# 6가지 패밀리 잔존 확인
grep -n "6가지" 0*G-00_*.md

# Manual 참조 라인 수 누락 확인
grep -n "Manual.*절 참고" 0*G-00_*.md | grep -v ":[0-9]"
```

#### 수동 검증 체크리스트
- [ ] 모든 가이드 "📚 이 가이드의 구성" 있음
- [ ] Part 구조 일관성 (Part 0, 1, 2...)
- [ ] Layer는 Part 1에서만 사용
- [ ] Manual 참조 모두 라인 수 있음
- [ ] 7개 패밀리로 통일
- [ ] 맥락 설명 충분

#### Jason 검증 요청
- [ ] 00_PROJECT_STRUCTURE.md 승인
- [ ] Stage 1 수정 완료 승인
- [ ] Stage 2-9 수정 완료 승인

---

## 📌 다음 단계

1. ✅ 이 계획 문서 작성 완료
2. ⏳ Jason 리뷰 및 피드백
3. ⏳ `00_PROJECT_STRUCTURE.md` 작성
4. ⏳ Stage 1 수정 실행
5. ⏳ Stage 2-9 수정 실행
6. ⏳ 최종 검증

---

**작성 완료**: 2025-11-14
**다음 검토**: Jason 피드백 후
