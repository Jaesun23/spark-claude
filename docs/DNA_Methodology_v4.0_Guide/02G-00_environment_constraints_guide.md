# Stage2. 환경 제약 가이드 (Environment Constraints Guide)

> **버전**: v4.0 (2025-11-14)
> - v4.0 (2025-11-14): Stage 2 구조 확립 - Part 1-3 구성
>
> **목적**: Stage 1에서 결정한 패밀리가 실제 환경에서 구현 가능한지 확인하고, 충돌 발견시 트레이드오프 결정

---

## 📚 이 가이드의 구성
- **이 문서** (Guide): 질문 템플릿 + 작성 원칙 (간결)
- **해설서** (Manual): 왜? 어떻게? 상세 설명 → `02M-01_environment_constraints_manual.md`
- **사례집** (Cases): 전체 흐름 실전 예시 → `02E-01_stock_trading_case.md`

---

## 📋 목차
1. [Stage 2가 필요한 이유](#stage-2가-필요한-이유)
2. [Part 1: Layer 3 (외부 제약) 조사](#part-1-layer-3-외부-제약-조사)
3. [Part 2: 충돌 패턴 식별](#part-2-충돌-패턴-식별)
4. [Part 3: 구현 방법 결정 (5단계)](#part-3-구현-방법-결정-5단계)
5. [산출물 작성 가이드](#산출물-작성-가이드)

---

## Stage 2가 필요한 이유

Stage 1에서 시스템의 패밀리를 결정했습니다. 예를 들어 "A-A-B (트랜잭션/CRUD)" 또는 "B-C-A (실시간 스트리밍)" 같은 패밀리 코드를 얻었죠.

**하지만 여기서 중요한 질문이 생깁니다**:

> "이 패밀리가 요구하는 성능과 구조를, 현실 세계의 외부 환경(API, 클라우드, 규제 등)이 지원할 수 있나요?"

**예시로 이해하기**:
```
Stage 1 결정: A-C-A 패밀리 (초고속 실시간 거래)
  ├─ Layer 1: A (실패 = 금전 손실)
  ├─ Layer 2: C (스트림 데이터)
  └─ Layer 3: A (100ms 이하 응답)  ← 이게 가능한가?

Stage 2 조사: 실제 증권 API 성능 확인
  ├─ 한국투자증권: 평균 200-400ms  ❌ (Layer 3 불만족!)
  ├─ 키움증권: 평균 300-600ms      ❌ (Layer 3 불만족!)
  └─ WebSocket 실시간: 50-100ms   ✅ (조건부 가능)

결론: Layer 3 목표(100ms)와 현실(200-600ms)이 충돌!
→ 트레이드오프 결정 필요
```

**이것이 바로 Stage 2의 역할입니다**:
- **현실 확인**: 이상과 현실 사이의 간극 파악
- **충돌 발견**: 목표와 제약 사이의 충돌 명확히 식별
- **트레이드오프**: 의식적으로 절충안 결정하고 문서화

---

## Part 1: Layer 3 (외부 제약) 조사

Stage 1에서 결정된 패밀리의 **Layer 3 (응답 시간)** 요구사항을 만족시킬 수 있는 **외부 환경**을 조사합니다.

여기서 "Layer 3"는 Stage 1 Part 1의 3-Layer Decision Tree에서 결정한 **응답 시간 요구사항**(A: 100ms 이하, B: 1초 이하, C: 1초 이상)을 의미합니다.

### 왜 Layer 3만 조사하나요?

**Layer 1, 2는 이미 확정**:
- **Layer 1 (실패 영향)**: 시스템 본질 - 바꿀 수 없음
- **Layer 2 (데이터 구조)**: 데이터 특성 - 바꿀 수 없음

**Layer 3 (응답 시간)만 협상 가능**:
- 외부 API/서비스로 달성해야 하는 성능
- 불가능하면 목표를 조정하거나 아키텍처 변경
- **이것이 Stage 2의 핵심!**

---

### P1-Q1: Layer 3 제약을 만족하는 외부 서비스/API는 무엇이 있나요?

**질문 의도**: Stage 1에서 결정된 응답 시간 요구사항(A/B/C)을 만족하는 실제 사용 가능한 외부 서비스를 찾습니다.

**작성 가이드**:
1. **Stage 1 결과 확인**: "우리 시스템은 Layer 3가 A/B/C인가?"
2. **후보 서비스 조사**: 해당 응답 시간을 제공하는 서비스 찾기
3. **비교표 작성**: 성능, 가격, SLA, 제약사항 비교

**작성 예시** (Layer 3: B - 1초 이하인 경우):

```markdown
## Layer 3 제약 조사: 증권 거래 API

**Stage 1 결과**: Layer 3 = B (1초 이하 응답 필요)

### 후보 서비스 비교

| 서비스명 | 평균 응답 시간 | SLA | 월 비용 | Rate Limit | 비고 |
|----------|----------------|-----|---------|------------|------|
| 한국투자증권 REST API | 200-400ms | 99.9% | 무료 | 실전: 20건/초<br>모의: 2건/초 | ✅ Layer 3 만족 |
| 키움증권 OpenAPI | 300-600ms | 99.5% | 무료 | 초당 5건 | ⚠️ 응답 시간 경계선 |
| WebSocket (실시간) | 50-100ms | - | 무료 | 동시 41개 | ✅ 실시간 가능 |

### 제약사항 발견

1. **Rate Limit 차이**:
   - 실전 거래: 초당 20건
   - 모의 거래: 초당 2건 (10배 차이!)

2. **WebSocket 구독 제한**:
   - 동시 41개 종목만 구독 가능
   - 더 많은 종목은 Polling 필요

3. **SLA 보장 범위**:
   - 99.9% ≠ 100% → 장애 시간 존재
```

> 📖 **더 알아보기**: [Manual 1.1절: Layer 3 조사 방법론](./02M-01_environment_constraints_manual.md#11-layer-3-조사-방법론)(`02M-01_environment_constraints_manual.md:20-80`)

---

### P1-Q2: 다른 외부 제약(규제, 클라우드, 비용 등)이 있나요?

**질문 의도**: API 성능 외에 시스템 구현에 영향을 주는 다른 제약사항을 모두 파악합니다.

**작성 가이드**:

**1. 규제 제약**:
- 금융, 의료, 교육 등 규제 산업인가?
- 데이터 보관/삭제 의무 기간
- 개인정보보호 요구사항

**2. 클라우드/인프라 제약**:
- 온프레미스 필수인가? (보안, 규제)
- 클라우드 사용 가능한가?
- 지역(Region) 제한

**3. 비용 제약**:
- 예산 한도
- 트래픽 비용 구조
- 무료 티어 제한

**4. 기술 제약**:
- 기존 시스템과의 호환성
- 사용 가능한 프로그래밍 언어
- 라이선스 제약

**작성 예시**:

```markdown
## 외부 제약 조사

### 1. 규제 제약
- **금융위원회 전자금융거래법**:
  - 거래 기록 5년 보관 의무
  - 고객 거래 내역 조회 제공 의무

- **개인정보보호법**:
  - 주민번호 암호화 저장 필수
  - 개인정보 제3자 제공 동의 필요

### 2. 클라우드 제약
- ✅ 클라우드 사용 가능 (금융권 승인됨)
- ⚠️ 한국 리전(Region) 필수 (데이터 국외 반출 금지)
- 권장: AWS Seoul, NCP (네이버 클라우드)

### 3. 비용 제약
- 초기 예산: 월 50만원 이하
- 증권 API: 무료 (한국투자증권)
- 클라우드: t3.medium 24시간 = 월 약 40만원

### 4. 기술 제약
- 증권사 API: Python, Java, C++ 지원
- ActiveX 제외 (키움증권 일부 기능)
- 64비트 환경 필수
```

> 📖 **더 알아보기**: [Manual 1.2절: 외부 제약 조사 체크리스트](./02M-01_environment_constraints_manual.md#12-외부-제약-조사-체크리스트)(`02M-01_environment_constraints_manual.md:81-150`)

---

## Part 2: 충돌 패턴 식별

Part 1에서 조사한 **현실적 제약**이 Stage 1에서 결정한 **이상적 목표(NFR 프로파일)**와 **충돌하는지** 확인합니다.

### 충돌이란?

```
이상 (Stage 1 Part 2: NFR 프로파일)
  "정확성 A: 100% 정확한 조건 감지"
  "최신성 A: 실시간 즉시 반영"

         vs

현실 (Stage 2 Part 1: Layer 3 제약)
  "API Rate Limit: 초당 20건"
  "WebSocket 구독: 최대 41개"

        ↓
     충돌 발생!
```

**충돌은 정상입니다!** 이상과 현실 사이의 간극은 항상 존재합니다.
중요한 것은 **의식적으로 트레이드오프를 결정하고 문서화**하는 것입니다.

---

### P2-Q1: NFR 목표가 Layer 3 제약 하에서 달성 가능한가?

**질문 의도**: Stage 1 Part 2에서 정한 NFR 우선순위를, Part 1에서 조사한 실제 제약 환경에서 달성할 수 있는지 검증합니다.

**작성 가이드**:
1. **NFR 목표 나열**: Stage 1 Part 2 결과 (A-B-B-A 등)
2. **제약 사항 나열**: Part 1 조사 결과
3. **달성 가능성 분석**: 각 NFR별로 체크

**작성 예시**:

```markdown
## NFR 달성 가능성 분석

### Stage 1 Part 2 결과: NFR 프로파일 = A-B-B-A

| NFR | 목표 | Part 1 제약 | 달성 가능? |
|-----|------|-------------|-----------|
| **정확성** | A (100%) | API 자체가 정확한 데이터 제공 | ✅ 가능 |
| **성능** | B (1초) | 평균 200-400ms | ✅ 가능 |
| **확장성** | B (중간) | Rate Limit 20건/초 | ⚠️ 조건부 |
| **최신성** | A (실시간) | WebSocket 41개 제한 | ⚠️ 조건부 |

### 상세 분석

#### ✅ 달성 가능: 정확성 A
- API가 제공하는 데이터 자체가 정확함
- 거래소 직접 연결 데이터
- 추가 검증 불필요

#### ✅ 달성 가능: 성능 B
- 목표: 1초 이하
- 실제: 평균 200-400ms
- 충분한 여유 있음

#### ⚠️ 조건부 달성: 확장성 B
- Rate Limit: 초당 20건
- 100개 조건 체크 시: 5초마다 1회 전체 체크
- 빠른 변동 감지 어려움 → 충돌!

#### ⚠️ 조건부 달성: 최신성 A
- WebSocket: 최대 41개 동시 구독
- 100개 종목 감시 불가능
- 나머지는 Polling → 최신성 하락 → 충돌!
```

> 📖 **더 알아보기**: [Manual 2.1절: NFR 달성 가능성 분석 방법](./02M-01_environment_constraints_manual.md#21-nfr-달성-가능성-분석)(`02M-01_environment_constraints_manual.md:151-220`)

---

### P2-Q2: 어떤 충돌 패턴이 존재하나요?

**질문 의도**: P2-Q1에서 발견한 "⚠️ 조건부" 또는 "❌ 불가능" 항목을 구체적으로 분석하여 충돌 패턴을 명확히 정의합니다.

**작성 가이드**:

각 충돌마다 다음 형식으로 작성:

```markdown
### 충돌 #N: [목표 vs 제약]

**목표 (NFR)**:
- [Stage 1 Part 2에서 정한 목표]

**현실 (Layer 3 제약)**:
- [Part 1에서 조사한 제약]

**충돌 상황**:
- [왜 불가능한가? 구체적 수치로]

**영향**:
- [이 충돌이 시스템에 미치는 영향]

**트레이드오프 옵션**:
- 옵션 A: [방법 1 - 장단점]
- 옵션 B: [방법 2 - 장단점]
```

**작성 예시**:

```markdown
## 발견된 충돌 패턴

### 충돌 #1: 정확성 A vs API Rate Limit

**목표 (NFR 정확성 A)**:
- 100개 조건을 초 단위로 정확히 감지
- 조건 만족 시점을 놓치지 않아야 함

**현실 (API Rate Limit)**:
- 실전 거래: 초당 20건 제한
- 모의 거래: 초당 2건 제한

**충돌 상황**:
100개 조건을 초당 체크하려면?
  → 100건/초 API 호출 필요
  → 하지만 20건/초 제한
  → 불가능!

해결책: 5초마다 1회 전체 체크 (100건 ÷ 20건/초 = 5초)

**영향**:
- 조건 체크 주기: 1초 → 5초로 증가
- 빠른 시장 변동 시 조건 만족 시점 놓칠 위험
- 정확성 A 목표 달성 어려움

**트레이드오프 옵션**:

**옵션 A: 감시 조건 개수 축소**
- 장점: 정확성 A 유지 가능 (20개 × 1초 = 20건)
- 단점: 기능 제한 (100개 → 20개)

**옵션 B: 체크 주기 연장 수용**
- 장점: 100개 조건 모두 감시 가능
- 단점: 정확성 A → B로 하락 (5초 주기)

**옵션 C: 하이브리드 - 우선순위 기반**
- 중요한 20개: WebSocket 실시간 감시
- 나머지 80개: 5초 주기 Polling
- 장점: 핵심 기능은 정확성 A 유지
- 단점: 복잡도 증가

---

### 충돌 #2: 최신성 A vs WebSocket 구독 제한

**목표 (NFR 최신성 A)**:
- 호가 변동 즉시 반영
- 조건 감지 즉시 체결

**현실 (WebSocket 제한)**:
- 동시 구독: 최대 41개 종목
- 초과 시: Polling으로 대체 필요

**충돌 상황**:
100개 종목 실시간 감시하려면?
  → 100개 WebSocket 구독 필요
  → 하지만 41개 제한
  → 불가능!

해결책: 41개 WebSocket + 59개 Polling

**영향**:
- 41개: 실시간 (50-100ms)
- 59개: Polling (5초 주기 = 5000ms)
- 전체 종목 최신성 A 달성 불가

**트레이드오프 옵션**:

**옵션 A: 동적 구독 전환**
- 우선순위 높은 41개만 WebSocket
- 우선순위 변경 시 구독 교체
- 장점: 중요한 것은 실시간
- 단점: 구독 전환 지연 (1-2초)

**옵션 B: 계좌 분산**
- 여러 계좌 사용 (각 41개)
- 장점: 더 많은 종목 실시간 가능
- 단점: 관리 복잡도 증가

---

### 충돌 #3: 모의투자 검증 vs 실전 성능 차이

**목표**:
- 모의투자로 전략 검증 후 실전 투자

**현실**:
- 모의투자: 초당 2건 제한
- 실전투자: 초당 20건 제한
- **10배 성능 차이!**

**충돌 상황**:
모의투자 검증이 의미 있는가?
  → 제약이 10배 차이
  → 동작 양상이 완전히 다름
  → 검증 신뢰도 하락!
  
**영향**:
- 모의에서 성공한 전략이 실전에서 실패 가능
- 모의 환경에서 충분한 테스트 불가능
- 실전 직접 투입 위험 증가

**트레이드오프 옵션**:

**옵션 A: 모의 환경 제약에 맞춰 설계**
- 초당 2건 제한 내에서 전략 설계
- 장점: 모의 검증 신뢰도 100%
- 단점: 실전에서 성능 미활용 (20건 중 2건만 사용)

**옵션 B: 실전 환경 기준 설계 + 제한적 모의 테스트**
- 초당 20건 기준으로 설계
- 모의는 기본 로직만 검증
- 장점: 실전 성능 최대 활용
- 단점: 모의 검증 불완전

**옵션 C: 시뮬레이션 환경 자체 구축**
- 과거 데이터로 백테스팅 환경 구축
- 장점: 제약 없이 완전 테스트
- 단점: 개발 시간/비용 증가
```
> 📖 **더 알아보기**: [Manual 2.2절: 충돌 패턴 분석 방법론](./02M-01_environment_constraints_manual.md#22-충돌-패턴-분석-방법론)(`02M-01_environment_constraints_manual.md:221-300`)
>
> 📖 **실전 사례**: [Case: 주식 거래 시스템 충돌 분석](./02E-01_stock_trading_case.md#part-2-충돌-패턴)(`02E-01_stock_trading_case.md:150-250`)

---

## Part 3: 구현 방법 결정 (5단계)

Part 2에서 충돌을 발견했다면, 이제 **어떻게 구현할 것인지** 결정해야 합니다.

DNA 방법론의 **5단계 구현 결정 프로세스**를 따릅니다:

```
기능 → 속성 → 제약 → 기술 → 설계

1. 기능 요구사항 (Functional Requirements)
2. 속성 요구사항 (Quality Attributes = NFR)
3. 제약 사항 (Constraints = Layer 3)
4. 기술 스택 (Technology Stack)
5. 아키텍처 설계 (Architecture Design)
```

### 왜 5단계인가?

이 순서는 **SEI (Software Engineering Institute) ADD (Attribute-Driven Design)** 방법론에서 검증된 결정 순서입니다:

1. **기능이 먼저**: 무엇을 할 것인가?
2. **속성이 두 번째**: 얼마나 잘 해야 하는가?
3. **제약이 세 번째**: 현실적으로 무엇이 가능한가?
4. **기술이 네 번째**: 위 3가지를 만족하는 도구는?
5. **설계가 마지막**: 어떻게 조합할 것인가?

---

### P3-Q1: 핵심 기능 요구사항은 무엇인가요? (1단계)

**질문 의도**: Stage 1 Part 0에서 정의한 핵심 기능을 다시 확인합니다.

**작성 가이드**:
- Stage 1 Part 0 결과를 그대로 가져오기
- 변경 없음 (이미 확정됨)

**작성 예시**:

```markdown
## 1단계: 기능 요구사항

**핵심 기능** (Stage 1 Part 0):
- **주식 거래**

**세부 기능**:
1. 조건 설정 (가격, 수량, 지표)
2. 조건 감시 (시장 데이터 실시간 체크)
3. 자동 체결 (조건 만족 시 즉시 매매)

**목적**:
- 거래를 통한 주식의 소유권 획득 또는 소유권 이전
- 관련 법규와 규정의 범위 안에서 거래
- 수익 창출
- 24시간 자동 거래
```

---

### P3-Q2: 속성 요구사항(NFR)과 실제 달성 가능 수준은? (2단계)

**질문 의도**: Part 2에서 분석한 충돌을 반영하여, **이상적 목표**와 **현실적 달성 가능 수준**을 명확히 구분합니다.

**작성 가이드**:

```markdown
| NFR | 이상 (Stage 1) | 현실 (Part 2 분석) | 최종 결정 |
|-----|----------------|-------------------|-----------|
| 정확성 | A | 충돌 #1 | ? |
| 성능 | B | ✅ 가능 | B |
| 확장성 | B | ✅ 가능 | B |
| 최신성 | A | 충돌 #2 | ? |
```

**작성 예시**:

```markdown
## 2단계: 속성 요구사항 (NFR) 최종 결정

| NFR | 이상 목표 | 현실 제약 | 트레이드오프 결정 | 최종 등급 |
|-----|-----------|-----------|------------------|-----------|
| **정확성** | A (100%) | Rate Limit 충돌 | 옵션 C: 하이브리드<br>- 중요 20개: 실시간<br>- 나머지 80개: 5초 주기 | A (부분적) |
| **성능** | B (1초) | ✅ 200-400ms | 충분히 달성 가능 | B |
| **확장성** | B (중간) | ✅ 20건/초 | 100개 조건은 5초 주기로 가능 | B |
| **최신성** | A (실시간) | WebSocket 41개 제한 | 옵션 A: 동적 구독<br>- 우선순위 41개: 실시간<br>- 나머지: 5초 Polling | A (부분적) |

### 최종 NFR 프로파일

**현실적 달성 수준**: A(부분)-B-B-A(부분)

**핵심 트레이드오프**:
1. ✅ 중요한 기능은 정확성·최신성 A 유지
2. ⚠️ 비중요 기능은 B로 하락 수용
3. 📋 이 결정을 ADR로 문서화 (Stage 3)
```

---

### P3-Q3: 제약 사항 종합 정리 (3단계)

**질문 의도**: Part 1에서 조사한 모든 제약을 한눈에 볼 수 있도록 정리합니다.

**작성 가이드**:

```markdown
**Layer 3 제약**:
- [API 성능 제약]

**규제 제약**:
- [법률, 규정]

**비용 제약**:
- [예산 한도]

**기술 제약**:
- [호환성, 라이선스]
```

**작성 예시**:

```markdown
## 3단계: 제약 사항 종합

### Layer 3 제약 (성능)
- API Rate Limit: 실전 20건/초, 모의 2건/초
- WebSocket 구독: 최대 41개 동시
- 평균 응답 시간: 200-400ms

### 규제 제약
- 거래 기록 5년 보관 의무
- 개인정보 암호화 필수
- 데이터 국외 반출 금지 (한국 리전 필수)

### 비용 제약
- 월 예산: 50만원 이하
- 증권 API: 무료
- 클라우드: 40만원 (t3.medium)

### 기술 제약
- Python/Java 지원 (ActiveX 제외)
- 64비트 환경 필수
- 한국투자증권 API 사용
```

---

### P3-Q4: 적합한 기술 스택은 무엇인가요? (4단계)

**질문 의도**: 1-3단계에서 정리한 기능, 속성, 제약을 **모두 만족하는** 기술을 선택합니다.

**작성 가이드**:

**SEI ADD 원칙 적용**:
1. **NFR 프로파일 먼저** → 패밀리 코드
2. **패밀리에 맞는 기술** 후보 선정
3. **제약으로 필터링** → 최종 결정

**작성 예시**:

```markdown
## 4단계: 기술 스택 선택

### Step 1: 패밀리 기반 후보 선정

**패밀리**: A-C-A (Stage 1 결정)
  ├─ A: 실패 = 손실
  ├─ C: 스트림 데이터
  └─ A: 100ms 이하 (→ 현실: 200-400ms로 조정)

**패밀리 권장 기술**:
- **언어**: Python (데이터 처리), Go (고성능)
- **프레임워크**: FastAPI (비동기), Flask
- **DB**: PostgreSQL (트랜잭션), Redis (캐시)
- **메시징**: Kafka, RabbitMQ
- **실시간**: WebSocket, gRPC

### Step 2: 제약으로 필터링

| 기술 | 패밀리 적합 | 제약 만족 | 최종 |
|------|------------|----------|------|
| **언어: Python** | ✅ 데이터 처리 강점 | ✅ 한투 API 지원 | ✅ 선택 |
| 언어: Go | ✅ 고성능 | ❌ 한투 API 미지원 | ❌ 제외 |
| **프레임워크: FastAPI** | ✅ 비동기 지원 | ✅ Python 기반 | ✅ 선택 |
| **DB: PostgreSQL** | ✅ 트랜잭션 | ✅ 5년 보관 가능 | ✅ 선택 |
| DB: MongoDB | ⚠️ 비정형 | ✅ 가능 | ❌ 불필요 (정형 데이터) |
| **캐시: Redis** | ✅ 고속 | ✅ 조건 캐싱 | ✅ 선택 |
| **실시간: WebSocket** | ✅ 필수 | ✅ 한투 제공 | ✅ 선택 |

### Step 3: 최종 기술 스택

[언어]
- Python 3.11+

[웹 프레임워크]
- FastAPI (비동기 처리)

[데이터베이스]
- PostgreSQL 15+ (거래 기록, 5년 보관)
- Redis 7+ (조건 캐싱, 실시간 데이터)

[실시간 통신]
- WebSocket (한국투자증권)

[클라우드]
- AWS Seoul Region (데이터 국내 보관)
- t3.medium (월 40만원)

[모니터링]
- CloudWatch (AWS 기본 제공)

### 기술 선택 근거 (ADR 작성 예정)

1. **Python**: 한투 API 공식 지원, 데이터 분석 생태계
2. **FastAPI**: 비동기 처리로 20건/초 Rate Limit 최적 활용
3. **PostgreSQL**: 트랜잭션 ACID, 5년 보관 안정성
4. **Redis**: 100개 조건 빠른 매칭 (메모리 캐시)
5. **WebSocket**: 41개 핵심 종목 실시간 감시
6. **AWS Seoul**: 규제 준수 (데이터 국내), 안정적 SLA
```
> 📖 **더 알아보기**: [Manual 3.1절: 기술 스택 선택 방법론 (SEI ADD)](./02M-01_environment_constraints_manual.md#31-기술-스택-선택-방법론)(`02M-01_environment_constraints_manual.md:301-400`)

---

### P3-Q5: 아키텍처 설계 방향은? (5단계)

**질문 의도**: 선택한 기술 스택으로 **어떤 아키텍처 패턴**을 사용할 것인지 결정합니다.

**작성 가이드**:

1. **패밀리 권장 패턴** 확인
2. **충돌 해결 방안** 반영
3. **고수준 아키텍처 스케치**

**작성 예시**:

```markdown
## 5단계: 아키텍처 설계 방향

### 패밀리 A-C-A 권장 패턴

**핵심 패턴**: Event-Driven + Microservices
- **Event-Driven**: 실시간 스트림 처리 (Layer 2: C)
- **트랜잭션 보장**: ACID + 보상 트랜잭션 (Layer 1: A)
- **고성능**: 비동기 처리, 캐싱 (Layer 3: A → 현실 B)

### 충돌 해결 아키텍처 반영

**충돌 #1 해결** (Rate Limit):
[아키텍처 컴포넌트]
Priority Queue Scheduler
  ├─ High Priority (20개): 1초 주기 체크
  ├─ Medium Priority (30개): 3초 주기 체크
  └─ Low Priority (50개): 5초 주기 체크

총 API 호출: 20건 (High) + 10건 (Med) + 10건 (Low) = 40건
→ 2초에 분산하면 20건/초 준수!

**충돌 #2 해결** (WebSocket 41개):
[아키텍처 컴포넌트]
Dynamic Subscription Manager
  ├─ WebSocket Pool: 41개 슬롯
  ├─ Priority Ranking: 실시간 우선순위 계산
  └─ Swap Mechanism: 우선순위 변경 시 구독 교체
  
### 고수준 아키텍처 스케치
┌─────────────────────────────────────────┐
│         API Gateway (FastAPI)            │
│  - REST API (사용자 조건 설정)           │
│  - WebSocket (실시간 알림)               │
└────────────┬────────────────────────────┘
             │
┌────────────┴────────────────────────────┐
│      Application Layer                   │
│  ┌─────────────┐  ┌──────────────────┐ │
│  │ Condition   │  │ Trading Engine   │ │
│  │ Manager     │  │ (주문 실행)      │ │
│  └─────────────┘  └──────────────────┘ │
└────────────┬────────────────────────────┘
             │
┌────────────┴────────────────────────────┐
│      Event Processing Layer              │
│  ┌─────────────┐  ┌──────────────────┐ │
│  │ WebSocket   │  │ Priority Queue   │ │
│  │ Subscriber  │  │ Scheduler        │ │
│  │ (41개)      │  │ (Rate Limit)     │ │
│  └─────────────┘  └──────────────────┘ │
└────────────┬────────────────────────────┘
             │
┌────────────┴────────────────────────────┐
│      Data Layer                          │
│  ┌─────────────┐  ┌──────────────────┐ │
│  │ PostgreSQL  │  │ Redis Cache      │ │
│  │ (거래 기록) │  │ (조건 매칭)      │ │
│  └─────────────┘  └──────────────────┘ │
└────────────┬────────────────────────────┘
             │
┌────────────┴────────────────────────────┐
│      External Integration                │
│  ┌─────────────┐  ┌──────────────────┐ │
│  │ 한국투자    │  │ WebSocket        │ │
│  │ REST API    │  │ Real-time        │ │
│  │ (20건/초)   │  │ (41개 구독)      │ │
│  └─────────────┘  └──────────────────┘ │
└─────────────────────────────────────────┘

### 핵심 설계 결정

1. **Event-Driven Architecture**: 실시간 이벤트 처리
2. **Priority-Based Scheduling**: Rate Limit 우회
3. **Dynamic Subscription**: WebSocket 최적 활용
4. **Redis Caching**: 조건 매칭 성능 향상
5. **ACID Transaction**: 거래 정확성 보장
```
> 📖 **더 알아보기**: [Manual 3.2절: 아키텍처 패턴 선택 가이드](./02M-01_environment_constraints_manual.md#32-아키텍처-패턴-선택)(`02M-01_environment_constraints_manual.md:401-500`)
>
> 📖 **실전 사례**: [Case: 주식 거래 시스템 아키텍처 설계](./02E-01_stock_trading_case.md#part-3-구현-방법)(`02E-01_stock_trading_case.md:251-400`)

---

### P3-Q6: DNA 시스템은 어떻게 구성하나요? (6단계)

**질문 의도**: 모든 소프트웨어에 필수적인 **DNA 시스템 11개**를 패밀리 특성과 규모/예산에 맞춰 구성합니다.

**핵심 개념**:
```
소프트웨어 시스템 구성:
├─ DNA 시스템 (11개) ← 필수, 모든 프로젝트 공통
│   └─ 로깅, 에러 핸들링, 설정 관리 등
└─ 도메인 시스템 ← 선택, 문제 해결 위해 구상
    └─ Priority Queue Scheduler, Subscription Manager 등

선택의 자유도:
├─ ❌ 외부 제약 (어쩔 수 없음) → Part 1
├─ ❌ 충돌 타협 (어쩔 수 없음) → Part 2
├─ 🔄 기술 스택 (최선 선택) → Part 3-4단계
├─ 🔄 도메인 기술 (문제 해결 필수) → Part 3-5단계
└─ 🔄 DNA 시스템 (패밀리 + 규모/예산 → 대부분 자동 결정) → Part 3-6단계

💡 실제로는 "꼬리에 꼬리를 물면서" 대부분 자동 결정됨!
```

**작성 가이드**:

**Step 1: 패밀리 매트릭스에서 DNA 기본 스택 확인**

각 패밀리는 DNA 시스템 11개에 대한 권장 기술 스택을 제공합니다. (1호가 작성 중인 7개 패밀리 매트릭스 참조)

**Step 2: 규모와 예산에 따른 조정**

| DNA 시스템 | 소규모 (< 1000 사용자) | 중규모 (< 10만 사용자) | 대규모 (> 10만 사용자) |
|-----------|---------------------|-------------------|-------------------|
| **로깅** | 파일 로깅 (무료) | CloudWatch (월 $10) | ELK Stack (월 $100+) |
| **DB 연결** | 단순 커넥션 풀 | asyncpg (비동기) | PgBouncer (연결 관리) |
| **캐싱** | 로컬 메모리 | Redis (월 $30) | Redis Cluster |
| **모니터링** | 기본 헬스체크 | Prometheus | Datadog/New Relic |

**Step 3: DNA 시스템 11개 ADR 목록 생성**

**작성 예시**:

```markdown
## 6단계: DNA 시스템 구성

### DNA 시스템 11개 목록

**우리 프로젝트**: 소규모 (< 100 사용자), 월 40만원 예산, A-C-A 패밀리

#### 1. 로깅 시스템
- **선택**: structlog + 파일 로깅
- **근거**:
  - A-C-A → 구조화 로그 필수 (스트림 데이터 추적)
  - 소규모 → CloudWatch 불필요, 파일로 충분
- **ADR**: ADR-001 로깅 전략

#### 2. 에러 핸들링
- **선택**: FastAPI HTTPException + 트랜잭션 롤백
- **근거**:
  - A-C-A → Layer 1: A (실패=손실) → 트랜잭션 필수
  - FastAPI 표준 예외 + 커스텀 에러 코드
- **ADR**: ADR-002 에러 핸들링 전략

#### 3. 설정 관리
- **선택**: pydantic Settings + .env
- **근거**:
  - 소규모 → AWS Secrets Manager 불필요
  - FastAPI와 통합 용이
- **ADR**: ADR-003 설정 관리

#### 4. DB 연결 관리
- **선택**: SQLAlchemy async + 커넥션 풀 (pool_size=5)
- **근거**:
  - A-C-A → 비동기 필수 (실시간 처리)
  - 소규모 → pool_size 5면 충분
- **ADR**: ADR-004 DB 연결 전략

#### 5. 인증/인가
- **선택**: JWT (jose) + 간단한 RBAC
- **근거**:
  - 개인 사용 → OAuth 불필요
  - JWT로 stateless 인증
- **ADR**: ADR-005 인증/인가 전략

#### 6. 캐싱
- **선택**: Redis 7+ (AWS ElastiCache)
- **근거**:
  - 100개 조건 매칭 → 메모리 캐시 필수
  - 월 $30 예산 내
- **ADR**: ADR-006 캐싱 전략

#### 7. 비동기 처리
- **선택**: FastAPI BackgroundTasks (간단한 작업용)
- **근거**:
  - 소규모 → Celery 불필요
  - 간단한 알림 전송만 비동기
- **ADR**: ADR-007 비동기 처리

#### 8. API 설계
- **선택**: REST + OpenAPI 자동 문서화
- **근거**:
  - FastAPI 기본 제공
  - 개인 사용 → GraphQL 불필요
- **ADR**: ADR-008 API 설계 원칙

#### 9. 테스트 전략
- **선택**: pytest + pytest-asyncio
- **근거**:
  - Python 표준
  - 비동기 코드 테스트 필요
- **ADR**: ADR-009 테스트 전략

#### 10. 배포 전략
- **선택**: Docker + AWS ECS Fargate
- **근거**:
  - 서버 관리 불필요
  - 월 예산 내 (t3.medium 상당)
- **ADR**: ADR-010 배포 전략

#### 11. 모니터링
- **선택**: CloudWatch 기본 모니터링 + 헬스체크
- **근거**:
  - AWS 기본 제공 (추가 비용 무)
  - 소규모 → Datadog 불필요
- **ADR**: ADR-011 모니터링 전략

### DNA 시스템 결정 요약

| DNA 시스템 | 선택 기술 | 결정 근거 | ADR |
|-----------|----------|----------|-----|
| 1. 로깅 | structlog + 파일 | A-C-A (구조화) + 소규모 | ADR-001 |
| 2. 에러 | HTTPException + 롤백 | A-C-A (트랜잭션) | ADR-002 |
| 3. 설정 | pydantic + .env | 소규모 | ADR-003 |
| 4. DB 연결 | SQLAlchemy async | A-C-A (비동기) | ADR-004 |
| 5. 인증 | JWT + RBAC | 개인 사용 | ADR-005 |
| 6. 캐싱 | Redis 7+ | 필수 (조건 매칭) | ADR-006 |
| 7. 비동기 | BackgroundTasks | 소규모 | ADR-007 |
| 8. API | REST + OpenAPI | FastAPI 기본 | ADR-008 |
| 9. 테스트 | pytest + async | Python 표준 | ADR-009 |
| 10. 배포 | Docker + Fargate | 예산 내 | ADR-010 |
| 11. 모니터링 | CloudWatch | AWS 기본 | ADR-011 |

💡 **패턴 발견**:
- 패밀리 (A-C-A) → 4개 자동 결정 (로깅, 에러, DB, 캐싱)
- 규모 (소규모) → 5개 자동 결정 (설정, 비동기, 배포, 모니터링, 인증)
- 기술 스택 (FastAPI) → 2개 자동 결정 (API, 테스트)

👉 **총 11개 중 11개 "꼬리에 꼬리를 물면서" 결정됨!**
```

> 📖 **더 알아보기**: [Manual 3.3절: DNA 시스템 구성 방법](./02M-01_environment_constraints_manual.md#33-dna-시스템-구성)(`02M-01_environment_constraints_manual.md:501-650`)

---

## 산출물 작성 가이드

### Stage 2 최종 산출물: `02D-01_implementation_approach.md`

Stage 2는 **1개의 통합 문서**를 생성합니다. 이 문서는 Part 1-3의 모든 결과를 포함하며, Stage 3 (ADR 작성)의 입력이 됩니다.

**작성 순서** (중요!):
```
1. Part 1 작업 → 중간 결과 정리
2. Part 2 작업 → Part 1 결과 사용, 중간 결과 정리
3. Part 3 작업 → Part 1-2 결과 사용
4. 최종 문서 작성 → 02D-01_implementation_approach.md
```

---

### 문서 구조: `02D-01_implementation_approach.md`

```markdown
# Stage 2: 환경 제약 및 구현 방법 결정서

> **프로젝트**: [프로젝트명]
> **작성일**: YYYY-MM-DD
> **패밀리**: A-C-A (Stage 1 결과)
> **NFR**: A-B-B-A (Stage 1 결과)

---

## Part 1: Layer 3 (외부 제약) 조사 결과

### 1.1 외부 서비스/API 비교
[P1-Q1 결과: 비교표]

**선택**: [최종 선택한 API/서비스]
**이유**: [선택 근거]

### 1.2 기타 제약사항
[P1-Q2 결과]
- 규제: ...
- 클라우드: ...
- 비용: ...
- 기술: ...

### 1.3 제약 종합
[Part 1 요약]

---

## Part 2: 충돌 패턴 식별 결과

### 2.1 NFR 달성 가능성 분석
[P2-Q1 결과: NFR별 달성 가능성 표]

### 2.2 발견된 충돌

#### 충돌 #1: [제목]
[P2-Q2 결과: 목표, 현실, 충돌 상황, 영향]

**트레이드오프 옵션**:
- 옵션 A: ...
- 옵션 B: ...
- 옵션 C: ...

**선택**: 옵션 [X]
**이유**: ...

#### 충돌 #2: [제목]
...

### 2.3 충돌 해결 요약
[모든 충돌과 선택된 옵션 요약]

---

## Part 3: 5단계 구현 방법 결정

### 3.1 1단계: 기능 요구사항
[P3-Q1 결과: Stage 1 Part 0 재확인]

### 3.2 2단계: 속성 요구사항 (NFR)
[P3-Q2 결과: 트레이드오프 반영된 현실적 NFR]

### 3.3 3단계: 제약 사항
[P3-Q3 결과: Part 1 제약 종합]

### 3.4 4단계: 기술 스택
[P3-Q4 결과: 선택된 기술 스택과 근거]

### 3.5 5단계: 아키텍처 설계
[P3-Q5 결과: 고수준 아키텍처 스케치와 도메인 기술]

### 3.6 6단계: DNA 시스템 구성
[P3-Q6 결과: DNA 시스템 11개 선택과 근거]

---

## Stage 3 준비: ADR 작성 목록

Stage 2에서 결정된 모든 사항은 Stage 3에서 ADR로 문서화됩니다. ADR은 **5개 카테고리**로 구성됩니다:

### 📋 ADR 5개 카테고리 (총 ~25개)

#### 1️⃣ 외부 제약 ADR (Part 1 결과, 3-5개)
**어쩔 수 없는 선택** - 외부 요인으로 강제된 결정

**작성 항목**:
- **ADR-101**: [외부 API/서비스] 선택
  - 내용: Part 1.1 비교 결과
  - 근거: 공식 지원, 기능 만족, 제약 준수

- **ADR-102**: [클라우드 제공자] 선택
  - 내용: Part 1.2 제약 분석
  - 근거: 지역 요구사항, 규제 준수

- **ADR-103**: [규제/컴플라이언스] 준수 방안
  - 내용: Part 1.2 규제 요구사항
  - 근거: 법적 의무사항

**예시**: 한국투자증권 API 선택, AWS Seoul Region, 금융위원회 전자금융거래법 준수

---

#### 2️⃣ 충돌 해결 ADR (Part 2 결과, 2-3개)
**어쩔 수 없는 타협** - NFR 간 충돌과 트레이드오프 결정

**작성 항목**:
- **ADR-201**: 충돌 #1 - [충돌 제목]
  - 내용: Part 2.2 충돌 분석
  - 트레이드오프: 옵션 A vs B vs C
  - 선택: 옵션 [X]
  - 근거: [장기적 관점, 비용 효율 등]

- **ADR-202**: 충돌 #2 - [충돌 제목]
  - 내용: Part 2.2 충돌 분석
  - 근거: [우선순위, 제약 등]

**예시**: 하이브리드 아키텍처 (성능-일관성 균형), Rate Limit 우회 전략

---

#### 3️⃣ 기술 스택 ADR (Part 3-4단계 결과, 4-6개)
**최선의 선택** - 패밀리 권장 + 제약으로 필터링된 기술

**작성 항목**:
- **ADR-301**: [언어] 선택
  - 내용: Part 3.4 기술 스택 결정
  - 근거: 패밀리 권장 + 외부 API 지원

- **ADR-302**: [프레임워크] 선택
  - 내용: Part 3.4 기술 스택 결정
  - 근거: 패밀리 특성 (비동기, 성능 등)

- **ADR-303**: [데이터베이스] 선택
  - 내용: Part 3.4 기술 스택 결정
  - 근거: 트랜잭션, NFR 요구사항

- **ADR-304**: [기타 기술] 선택
  - 내용: Part 3.4 기술 스택 결정
  - 근거: 특정 기능 요구사항

**예시**: Python 3.11+, FastAPI, PostgreSQL + Redis, WebSocket

---

#### 4️⃣ 도메인 기술 ADR (Part 3-5단계 결과, 2-4개)
**문제 해결 필수** - 아이디어 현실화를 위해 구상한 시스템

**작성 항목**:
- **ADR-401**: [도메인 컴포넌트 #1] 설계
  - 내용: Part 3.5 아키텍처 설계
  - 근거: 충돌 해결, 문제 해결 필수

- **ADR-402**: [도메인 컴포넌트 #2] 설계
  - 내용: Part 3.5 아키텍처 설계
  - 근거: 핵심 기능 구현 필수

**예시**: Priority Queue Scheduler, Dynamic Subscription Manager, Event-Driven Architecture

---

#### 5️⃣ DNA 시스템 ADR (Part 3-6단계 결과, 11개)
**자동 결정** - 패밀리 매트릭스 + 규모/예산으로 대부분 자동 결정

**작성 항목**:
- **ADR-001**: 로깅 전략
- **ADR-002**: 에러 핸들링 전략
- **ADR-003**: 설정 관리 전략
- **ADR-004**: DB 연결 관리 전략
- **ADR-005**: 인증/인가 전략
- **ADR-006**: 캐싱 전략
- **ADR-007**: 비동기 처리 전략
- **ADR-008**: API 설계 원칙
- **ADR-009**: 테스트 전략
- **ADR-010**: 배포 전략
- **ADR-011**: 모니터링 전략

**내용**: Part 3.6 DNA 시스템 구성 결과
**근거**: 패밀리 특성, 규모, 예산, 기술 스택 선택

**예시**: structlog + 파일, HTTPException + 롤백, pydantic + .env, SQLAlchemy async 등

---

### 🎯 ADR 작성 목록 요약

| 카테고리 | 개수 | 결정 근거 | 예시 |
|---------|-----|---------|------|
| 1. 외부 제약 | 3-5 | 어쩔 수 없음 | 한투 API, AWS Seoul |
| 2. 충돌 해결 | 2-3 | 어쩔 수 없음 | 하이브리드 아키텍처 |
| 3. 기술 스택 | 4-6 | 최선 선택 | FastAPI, PostgreSQL |
| 4. 도메인 기술 | 2-4 | 문제 해결 필수 | Priority Scheduler |
| 5. DNA 시스템 | 11 | 자동 결정 | 로깅, 에러, 인증 등 |
| **합계** | **22-29** | **꼬리에 꼬리** | **Stage 3 입력** |

💡 **핵심**: "꼬리에 꼬리를 물면서" 대부분 자동으로 결정됨!

**예상 ADR 총 개수**: [22-29]개
```

---

## Stage 2 완료 체크리스트

다음 항목을 **순서대로** 완료했는지 확인하세요:

### Part 1: Layer 3 조사 (먼저)
- [ ] P1-Q1: 외부 서비스/API 비교표 작성 (최소 2개 이상)
- [ ] P1-Q2: 규제, 클라우드, 비용, 기술 제약 조사
- [ ] Part 1 중간 결과 정리 (메모/초안)

### Part 2: 충돌 패턴 식별 (Part 1 완료 후)
- [ ] P2-Q1: NFR 달성 가능성 분석 (Part 1 제약 사용)
- [ ] P2-Q2: 충돌 패턴 상세 분석 (최소 1개 이상)
- [ ] 각 충돌에 대한 트레이드오프 옵션 제시 (2-3개)
- [ ] 각 충돌별 최종 선택 결정
- [ ] Part 2 중간 결과 정리 (메모/초안)

### Part 3: 구현 방법 결정 (Part 1-2 완료 후)
- [ ] P3-Q1: 기능 요구사항 확인 (Stage 1 Part 0)
- [ ] P3-Q2: 현실적 NFR 수준 결정 (Part 2 트레이드오프 반영)
- [ ] P3-Q3: 제약 종합 정리 (Part 1 결과 사용)
- [ ] P3-Q4: 기술 스택 선택 (SEI ADD 원칙)
- [ ] P3-Q5: 아키텍처 설계 방향 수립 (도메인 기술)
- [ ] P3-Q6: DNA 시스템 11개 구성

### 최종 산출물 작성
- [ ] `02D-01_implementation_approach.md` 작성
  - [ ] Part 1 결과 포함
  - [ ] Part 2 결과 포함
  - [ ] Part 3 결과 포함 (Q1-Q6)
  - [ ] Stage 3 준비: ADR 작성 목록 5개 카테고리 포함

### Stage 3 입력 확인
- [ ] ADR 5개 카테고리 모두 식별됨
  - [ ] 1️⃣ 외부 제약 ADR (3-5개)
  - [ ] 2️⃣ 충돌 해결 ADR (2-3개)
  - [ ] 3️⃣ 기술 스택 ADR (4-6개)
  - [ ] 4️⃣ 도메인 기술 ADR (2-4개)
  - [ ] 5️⃣ DNA 시스템 ADR (11개)
- [ ] 각 ADR 주제와 결정 내용이 문서화됨
- [ ] 예상 ADR 총 개수 파악됨 (22-29개)

---

## 변경 이력

- **v4.0 (2025-11-14)**: 초안 작성
  - Part 1-3 구조 확립
  - 5단계 구현 결정 프로세스 정의
  - 충돌 패턴 분석 방법론 정립
  - 맥락 있는 설명과 흐름 강화
  - 새로운 링크 스타일 적용

---

**문서 끝**
