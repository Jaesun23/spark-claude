# 핵심정의 해설서 Part 2: NFR 우선순위

> **목적**: Stage 1 - Layer 2 (NFR 우선순위) 상세 해설
>
> **버전**: v3.0 (2025-11-12)
> - v3.0: Stage 구조 재정립 (Layer 3 → Stage 2로 이동)
>
> **참고**:
> - 가이드: `01_CORE_DEFINITION_GUIDE.md`
> - Part 1: `01-1_CORE_DEFINITION_MANUAL_Part1.md` (Part 0 + Layer 1)
> - 사례집: `IMPLEMENTATION_CASES.md`

---

## 목차

1. [Layer 2: NFR 우선순위](#1-layer-2-nfr-우선순위)

---

## 1. Layer 2: NFR 우선순위

### 1.1 왜 NFR이 중요한가?

#### Carnegie Mellon SEI 핵심 원칙

> **"품질 속성(Quality Attributes)이 아키텍처를 주도한다"**
>
> Architecture is driven by Quality Attributes, not by Features.

**의미**:
- 기능(Feature)은 **무엇을** 만들지 정의
- 품질 속성(NFR)은 **어떻게** 만들지 결정

**예시**:
```
기능: "사용자 인증"

NFR 없이:
- 어떤 DB? (MySQL? MongoDB?)
- 어떤 아키텍처? (모놀리식? MSA?)
- 답 없음!

NFR 있으면:
- 정확성 A (100%) → MySQL + ACID
- 규모 C (100만 명) → 샤딩 필요
- 보안 A (극비) → 암호화 필수
- 즉시성 A (< 100ms) → 인메모리 캐시
→ 아키텍처 결정 가능! ✅
```

---

#### Layer 2의 역할

**위치**:
```
Layer 1: 패밀리 식별 (시스템 본질)
    ↓
Layer 2: NFR 우선순위 (품질 속성) ← 여기!
    ↓
Layer 3: 환경 제약 (기술 좁히기)
```

**목표**:
1. **NFR 프로파일 생성**: A-B-B-A
2. **충돌 감지**: 불가능한 조합 발견
3. **트레이드오프 결정**: 무엇을 희생할지

---

#### 속성 질문의 중요성 (SEI ADD)

> **출처**: `docs/ARCHITECTURE_THEORY_MAPPING.md`

**SEI Attribute-Driven Design (ADD)**:
```
Step 1: 기능 요구사항 파악
Step 2: 품질 속성 우선순위 ⭐ (가장 중요!)
Step 3: 아키텍처 패턴 선택
```

**Jason 방법론 매핑**:
```
Layer 1 = Step 1 (기능 본질)
Layer 2 = Step 2 (품질 우선순위) ⭐⭐⭐
Stage 2 = Step 3 (구현 방법)
```

**1호의 통찰** (2025-11-11):
> "속성 질문(2단계)이 가장 중요!"
>
> - "얼마나 빨라야?" "몇 명?" "실패하면?"
> - Carnegie Mellon SEI: "속성이 기술 선택을 주도"

---

### 1.2 L2-Q1: 핵심 품질 (북극성) 상세

#### 질문의 의미

**"북극성(North Star)"**:
- 모든 결정의 기준점
- 트레이드오프 시 우선순위
- 타협할 수 없는 품질

**선택지**:
- **A (정확성)**: 100% 정확, 오류 불허
- **B (속도)**: 빠른 응답, 처리량
- **C (관련성)**: 맥락 이해, 품질

---

#### A (정확성) 상세

**의미**: 100% 정확해야 함, 오류 1건도 불허

**적용 사례**:
- 금융 트랜잭션 (1원도 틀리면 안 됨)
- 의료 진단 (오진 불가)
- 법률 문서 (계약서 오류 → 법적 문제)
- 주식 거래 (조건 감지 오류 → 금전 손실)

**아키텍처 영향**:
```
정확성 A 선택 시:

필수 요소:
- ACID 트랜잭션
- 데이터 검증 (입력/출력)
- 에러 핸들링 철저
- 롤백 메커니즘
- 감사 로그

기술 선택:
- RDBMS (PostgreSQL, MySQL)
- Transactional NoSQL (MongoDB Transactions)
- 2PC, Saga Pattern
```

**비용**:
- 성능 희생 (락, 검증)
- 복잡도 증가 (트랜잭션 관리)
- 인프라 비용 (고가용성)

---

#### B (속도) 상세

**의미**: 빠른 응답, 높은 처리량

**적용 사례**:
- 실시간 대시보드 (지연 < 1초)
- API 게이트웨이 (처리량 중요)
- 스트리밍 (지연시간 < 100ms)
- 캐시 시스템

**아키텍처 영향**:
```
속도 B 선택 시:

필수 요소:
- 인메모리 캐시 (Redis)
- 비동기 처리
- CDN
- 로드 밸런싱
- 수평 확장

기술 선택:
- NoSQL (빠른 읽기/쓰기)
- Message Queue (Kafka, RabbitMQ)
- Elasticsearch (빠른 검색)
```

**비용**:
- 정확성 희생 (Eventual Consistency)
- 복잡도 (분산 시스템)
- 인프라 비용 (캐시 서버)

---

#### C (관련성) 상세

**의미**: 맥락 이해, 의미적 품질

**적용 사례**:
- AI 검색 (의미 기반)
- 추천 시스템 (개인화)
- 자연어 처리 (문맥 이해)
- 콘텐츠 필터링

**아키텍처 영향**:
```
관련성 C 선택 시:

필수 요소:
- 벡터 DB (Milvus, Pinecone)
- 임베딩 모델 (OpenAI, Sentence Transformers)
- 랭킹 알고리즘
- A/B 테스팅
- 피드백 루프

기술 선택:
- Vector Search
- ML Pipeline
- Feature Store
```

**비용**:
- 계산 비용 (임베딩 생성)
- 저장 비용 (고차원 벡터)
- 튜닝 비용 (모델 학습)

---

#### 경계 사례: A vs B vs C

**Q: 검색 시스템의 핵심 품질은?**

**경우 1: 법률 문서 검색 (A)**
```
정확성이 핵심:
- 틀린 판례 검색 → 법적 문제
- 100% 정확한 키워드 매칭 필요
→ A (정확성)
```

**경우 2: 실시간 뉴스 검색 (B)**
```
속도가 핵심:
- 실시간 업데이트 중요
- 약간의 관련성 낮음은 OK
→ B (속도)
```

**경우 3: AI 의미 검색 (C)**
```
관련성이 핵심:
- 맥락 이해 중요
- 정확한 키워드 아니어도 OK
→ C (관련성)
```

---

### 1.3 L2-Q2: 규모 상세

#### 선택지

**A (소규모)**: < 100명
- 개인 프로젝트, 팀 도구
- 단일 서버 OK
- 복잡한 확장 불필요

**B (중규모)**: 100 ~ 10,000명
- 스타트업, 부서 시스템
- 수평 확장 대비 필요
- 캐싱, 로드 밸런싱

**C (대규모)**: > 10,000명
- 엔터프라이즈, 글로벌 서비스
- 분산 아키텍처 필수
- 샤딩, 리전별 배포

---

#### 확장성 고려

**수직 확장 (Scale Up)**:
```
소규모 (A):
- 서버 스펙 업그레이드
- 간단, 저렴
- 한계 명확
```

**수평 확장 (Scale Out)**:
```
중규모 (B):
- 서버 추가
- 로드 밸런서
- Stateless 설계

대규모 (C):
- 자동 확장 (Auto Scaling)
- 글로벌 분산
- 샤딩, 파티셔닝
```

---

#### 규모와 다른 NFR의 충돌

**충돌 1: 규모 C + 정확성 A**
```
문제:
- 대규모 → 분산 필요
- 정확성 → 일관성 필요
- 분산 일관성 = 어려움!

해결:
- 2PC (느림, 복잡)
- Saga Pattern (보상 트랜잭션)
- CQRS (읽기/쓰기 분리)
```

**충돌 2: 규모 C + 보안 A**
```
문제:
- 대규모 → 많은 서버
- 보안 → 접근 제어 복잡
- 감사 로그 대용량

해결:
- RBAC (역할 기반)
- RLS (Row-Level Security)
- 암호화 (성능 희생)
```

---

### 1.4 L2-Q3: 데이터 노출 상세

#### 선택지

**A (극비)**: 개인 금융, 의료 기록
- 암호화 필수 (저장 + 전송)
- 접근 제어 엄격
- 감사 로그 필수
- 규제 준수 (HIPAA, GDPR)

**B (민감)**: 사용자 정보, 내부 데이터
- 암호화 권장
- 인증/인가 필요
- 로그 보관

**C (공개)**: 공개 콘텐츠, 통계
- 최소 보안
- Rate Limiting
- 스팸 방지

---

#### 보안 요구사항

**A (극비) 체크리스트**:
- [ ] 저장 데이터 암호화 (AES-256)
- [ ] 전송 데이터 암호화 (TLS 1.3)
- [ ] 접근 제어 (RBAC/ABAC)
- [ ] MFA (다중 인증)
- [ ] 감사 로그 (변경 이력)
- [ ] 정기 보안 감사
- [ ] 데이터 백업 암호화
- [ ] 재해 복구 계획

**B (민감) 체크리스트**:
- [ ] 전송 암호화 (HTTPS)
- [ ] 비밀번호 해싱 (bcrypt)
- [ ] JWT/OAuth
- [ ] 세션 관리
- [ ] CSRF 방지
- [ ] SQL Injection 방지

**C (공개) 체크리스트**:
- [ ] Rate Limiting
- [ ] DDoS 방어
- [ ] 스팸 필터링

---

### 1.5 L2-Q4: 최신성 상세

#### 선택지

**A (즉시)**: 실시간 (ms~초)
- WebSocket, Server-Sent Events
- Change Data Capture (CDC)
- 이벤트 스트리밍

**B (준실시간)**: 분~시간
- Polling (1분 간격)
- 배치 업데이트
- Eventual Consistency

**C (배치)**: 일~주
- Cron Job
- ETL 파이프라인
- 오프라인 처리

---

#### 최신성과 속도의 차이

**최신성 (L2-Q4)**:
- "데이터가 얼마나 최신인가?"
- 예: 주가 - 1초 전 vs 1분 전 vs 1시간 전

**속도 (L2-Q1 B)**:
- "응답이 얼마나 빠른가?"
- 예: API 응답 시간 100ms vs 1초

**조합 예시**:
```
Case 1: 속도 B + 최신성 A
- 빠른 응답 + 실시간 데이터
- 예: 주식 거래 플랫폼
- 해결: WebSocket + 캐싱

Case 2: 속도 A + 최신성 C
- 즉각 응답 + 오래된 데이터 OK
- 예: 통계 대시보드 (전일 데이터)
- 해결: 캐시 + 배치 업데이트
```

---

### 1.6 NFR 프로파일과 충돌 감지

#### NFR 프로파일 생성

**출력 형식**:
```
L2-Q1: A (정확성)
L2-Q2: B (중규모)
L2-Q3: B (민감)
L2-Q4: A (즉시)

→ NFR 프로파일: A-B-B-A
```

**패밀리별 경향**:
```
CRUD/트랜잭션 (A-A-A):
- NFR 경향: A-A/B-A/B-A/B
- 정확성 중심, 규모·보안·최신성 가변

검색/추천 (C-B-B):
- NFR 경향: C-B/C-B/C-B/C
- 관련성 중심, 규모 중대형

실시간 트랜잭션 (A-C-A):
- NFR 경향: A-B-A/B-A ⭐
- 정확성 + 즉시성 (둘 다!)
```

---

#### 충돌 패턴 (오늘 발견!)

> **출처**: `docs/session-summaries/20251112_Phase2_복합시스템_도전.md`

**충돌 1: 정확성 A + 즉시성 A**
```
문제:
- 100% 정확 + 즉시 응답 (밀리초)
- 검증 시간 vs 응답 시간 충돌

사례: 주식 거래 플랫폼
- 조건 감지 100% 정확
- 체결 즉시 (< 100ms)

해결 전략:
1. 하이브리드 아키텍처
   - WebSocket (실시간 호가)
   - REST (거래 요청, Rate Limit 관리)
2. 우선순위 큐
   - 중요 종목 우선 처리
3. 캐싱 + 검증
   - 빠른 응답 + 백그라운드 검증
```

**충돌 2: 규모 C + 보안 A**
```
문제:
- 대규모 → 많은 서버, 복잡한 네트워크
- 극비 보안 → 암호화, 접근 제어

사례: 의료 기록 시스템 (100만 환자)

해결 전략:
1. RLS (Row-Level Security)
   - DB 레벨 접근 제어
   - 환자별 격리
2. 논리적 격리
   - 물리적 샤딩 대신 논리적 파티션
3. 암호화 계층화
   - 저장: 테이블 암호화
   - 전송: TLS
   - 앱: 필드 암호화
```

**충돌 3: 속도 B + 즉시성 A**
```
문제:
- 빠른 처리 + 실시간 업데이트
- 처리량 vs 지연시간 트레이드오프

사례: 실시간 대시보드 (대용량 데이터)

해결 전략:
1. Kafka + 비동기 Workers
   - 이벤트 스트리밍
   - 백프레셔 관리
2. CQRS
   - 쓰기: 비동기 (속도)
   - 읽기: 실시간 (즉시성)
3. Eventual Consistency 수용
   - 수 초 지연 허용
```

---

#### 트레이드오프 결정 프로세스

**Step 1: 충돌 감지**
```
NFR 프로파일 분석:
- A + A 조합 → 비용 극대화 경고
- A + C 조합 → 불가능 여부 확인
```

**Step 2: 협상 질문**
```
"정확성 100%를 95%로 낮출 수 있나?"
"즉시 응답을 1초로 완화할 수 있나?"
"대규모를 중규모로 축소할 수 있나?"
```

**Step 3: 해결 전략 선택**
```
Option 1: NFR 완화
- 덜 중요한 NFR 낮춤
- 예: 정확성 A → B (99.9%)

Option 2: 아키텍처 복잡화
- 하이브리드, CQRS, Saga
- 비용 증가 수용

Option 3: 범위 축소
- MVP 기능만
- 점진적 확장
```

---

