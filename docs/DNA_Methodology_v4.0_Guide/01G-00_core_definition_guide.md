# Stage1. 핵심정의 가이드 (Core Definition Guide)

> **목적**: Stage 1 - 패밀리 구분과 핵심기능 파악 (큰 방향과 큰 틀만 잡기)
>
> **버전**: v4.0 (2025-11-14)
>
> - v4.0 (2025-11-14): Stage - Part - Layer 구조 재정립 및 내용 수정
> - v3.0: Stage 구조 재정립 (Layer 3 → Stage 2로 이동)
> - v2.0: 3-Layer Decision Tree 도입

---

## 📚 이 가이드의 구성

- **이 문서** (Guide): 질문 템플릿 + 작성 원칙 (간결)
- **해설서** (Manual): 왜? 어떻게? 상세 설명 → `./01M-01_layer1_manual.md`, `./01M-02_layer2_manual.md`
- **사례집** (Cases): 전체 흐름 실전 예시 → `./02E-01_stock_trading_case.md`

---

## 📥 입력 문서 (이 Stage를 시작하기 전에 필요한 것)

**없음** - Stage 1은 프로젝트의 시작점입니다.

**필요한 것**:

- 프로젝트 아이디어 (간단한 설명)
- 해결하고자 하는 문제
- 기본적인 요구사항 (선택적)

---

## 📤 출력 문서 (이 Stage에서 생성해야 할 문서)

### 필수 문서

#### 1. **`01F-01_core_functions.md`** - '핵심기능' 정의 문서

#### 2. **`01C-01_family_classification.md`** - 7가지 패밀리 중 해당되는 패밀리(유형) 선택 문서

#### 3. **`01C-02_nfr_profile.md`** - NFR(Non-Functional Requirement) 프로파일링 문서

#### 4. **`01D-01_tech_candidates.md`** - 기술 후보군 명세서

---

### 🔄 4개의 문서를 통해 다음 Stage로 전달되는 것

#### Stage 1 → Stage 2:

- ##### ✅ 패밀리 코드 (A-C-A)

- ##### ✅ 핵심 기능 (거래)

- ##### ✅ NFR 프로파일 (A-B-B-A)

- ##### ✅ 기술 후보군 (WebSocket, FastAPI, Redis, PostgreSQL)

#### Stage 2에서는 이를 기반으로:

- ##### Layer 3 외부 제약 조사 (실제 API, 법규 등)

- ##### 충돌 패턴 발견

- ##### 구체적 기술 스택 확정

---

## Part 0: 핵심 기능 파악 ⭐

프로젝트의 시작은 아주 간단한 아이디어가 떠올라 그걸 실현시키고 싶을 때, 또는 어떤 일의 불편함이나 문제를 인식하고 그걸 해결하려고 할 때 시작하게 됩니다. 먼저 아이디어나 문제와 해결방법, 추가 요구사항을 접수하세요.

- 프로젝트 아이디어 (간단한 설명)
- 해결하고자 하는 문제
- 기본적인 요구사항 (선택적)

이제부터 접수된 내용에서 가장 '근원적인 기능'과 그 기능을 통해 무엇을 이루려고 하는 것인지 그 '목적'을 파악해 내야 합니다. 그 방법은 질문을 던져서 찾아냅니다.

------

### Q. 이 시스템은 무엇을 하기 위한 시스템인가요?

**작성 원칙**:

- 가장 **원자적인 기능(핵심기능)**만 파악하세요.
- 기능의 **확장 형태** 또는 **구현 방식**을 별개의 기능으로 보면 안 됩니다
- **비즈니스 목적**으로 구분하세요.

**예시**:

```
❌ 잘못된 구분:
   - 수동 거래 (핵심기능 1)
   - 자동 거래 (핵심기능 2)
❌ 잘못된 비지니스 목적: 편하게 거래하고, 필요할 때는 불편해도 수동으로 거래

✅ 올바른 구분:
   - 거래 (핵심기능)
     ├─ 구현 방식 A: 수동
     └─ 구현 방식 B: 자동
✅ 비지니스 목적: "거래"를 통해 법적인 소유권 이전 효과 획득
```

✅ 다른 예시:
- AI 챗봇 + 외부메모리 (X) → AI 외부메모리 (CRUD) (O)
- 일반 검색 + AI 검색 (X) → 검색 (O)

**상세 설명**: **Manual**(`01M-01_layer1_manual.md`) 1.2절 참고

---

## Part 1: 시스템의 패밀리 유형 파악

### DNA 방법론의 7가지 패밀리 유형

> DNA Development Methodology v4.0에서는 모든 소프트웨어 시스템을 **3가지 핵심 차원**으로 분류하여 이론적으로 2×3×3 = 18가지 조합이 가능하지만, 실증 연구를 통해 **실무적으로 의미 있고 검증된 7가지 패밀리**를 도출했습니다.
>
> 지금 개발하려는 시스템이 **7가지 패밀리**에서 어떤 패밀리에 해당하는 지는 **3개의 질문에 답변**을 하면 자연스럽게 정해집니다.

---

## 3가지 분류 차원 (3-Layer Decision Tree)

### Layer 1: 실패의 파급력 (Failure Impact) ➟ "시스템이 실패하면 어떤 일이 벌어지는가?"

| 코드  |       유형        |                     의미                      |              실제 예시              |
| :---: | :---------------: | :-------------------------------------------: | :---------------------------------: |
| **A** | 치명적 (Critical) |    실패 시 생명, 재산, 시장에 즉각적 피해     |   금융 거래, 의료 기록, 항공 관제   |
| **B** | 점진적 (Graceful) | 실패 시 성능 저하나 일부 기능 상실, 계속 작동 | 소셜 미디어, 추천 시스템, 협업 도구 |

#### 핵심 질문: "이 시스템이 5분간 멈추면 어떻게 되나요?"

- A: 돈을 잃거나, 생명이 위험하거나, 법적 문제 발생
- B: 불편하지만 재시도하거나 나중에 처리 가능

---

### Layer 2: 데이터의 형태 (Data Structure) ➟ "다루는 정보가 얼마나 정형화되어 있는가?"

| 코드  |            유형            |                     의미                      |                 실제 예시                  |
| :---: | :------------------------: | :-------------------------------------------: | :----------------------------------------: |
| **A** |    구조화 (Structured)     | 고정된 스키마, 명확한 관계, 정확한 쿼리 가능  |    주문 데이터, 회계 장부, 예약 시스템     |
| **B** | 반구조화 (Semi-Structured) |    유연한 스키마, 일부 비정형, JSON/XML 등    |   사용자 프로필, IoT 센서 로그, API 응답   |
| **C** |  비구조화 (Unstructured)   | 스키마 없음, 이벤트 스트림, 자연어, 이미지 등 | 실시간 스트리밍, 로그 분석, AI 학습 데이터 |

#### 핵심 질문: "데이터베이스 스키마를 미리 정의할 수 있나요?"

- A: 네, 명확히 정의 가능 (ORDER, USER, PRODUCT 테이블)
- B: 부분적으로 (기본 필드 + 추가 속성)
- C: 아니오, 매번 다를 수 있음 (이벤트 스트림, 로그)

---

### Layer 3: 응답 시점 (Response Time) ➟ "얼마나 빨리 결과를 내야 하는가?"**

| 코드  |        유형        |                   의미                    |              실제 예시              |
| :---: | :----------------: | :---------------------------------------: | :---------------------------------: |
| **A** | 밀리초 (Real-time) | 사람이 "즉각"이라고 느끼는 속도 (< 100ms) | 협업 편집, 고빈도 거래, 실시간 채팅 |
| **B** | 수초 (Interactive) |    사람이 기다릴 수 있는 속도 (1~10초)    | 검색 결과, 주문 처리, 일반 API 응답 |
| **C** |    배치 (Batch)    |       스케줄 기반, 시간/분/일 단위        |   데이터 분석, 월말 정산, ML 학습   |

#### 핵심 질문: "사용자가 결과를 얼마나 빨리 기대하나요?"

- A: 즉시 (타이핑하는 동안, 클릭 직후)
- B: 잠깐 기다림 (로딩 인디케이터 표시)
- C: 나중에 (야간 처리, 주간 리포트)

---

## 패밀리 선택 플로우차트 예시

```
시작: 어떤 시스템을 만드나요?
  ↓
[Q1] 실패하면 어떻게 되나요?
  ├─ 돈/생명/시장 손실 → A (치명적)
  └─ 성능 저하/재시도 → B (점진적)
       ↓
[Q2] 데이터 형태는?
  ├─ 고정 스키마 → A (구조화)
  ├─ 유연한 JSON → B (반구조화)
  └─ 이벤트/로그 → C (비구조화)
       ↓
[Q3] 얼마나 빨라야 하나요?
  ├─ 즉시 (< 100ms) → A (밀리초)
  ├─ 기다림 (1~10초) → B (수초)
  └─ 나중에 (배치) → C (배치)
       ↓
패밀리 코드 확정! (예: B-C-A)
  ↓
해당 패밀리 기술 매트릭스 참고
```

### 아키텍처 패밀리 결정

**7가지 아키텍처 패밀리**:

| 패밀리 코드 | 패밀리 이름     | 대표 사례                    | 핵심 기술                  |
| ----------- | --------------- | ---------------------------- | -------------------------- |
| **A-A-A**   | 초고속 거래     | NASDAQ 매칭 엔진 (14μs)      | FPGA, 코로케이션           |
| **A-A-B**   | 트랜잭션/CRUD   | Amazon 주문, 은행 ATM        | PostgreSQL, 마이크로서비스 |
| **B-A-A**   | 협업/동기화     | Google Docs, Figma           | CRDT, WebSocket            |
| **B-B-B**   | 검색/추천       | Elasticsearch, AI 외부메모리 | 벡터 DB, 역인덱스          |
| **B-C-A**   | 실시간 스트리밍 | Netflix RDG, Uber GPS        | Kafka, Flink               |
| **B-A-C**   | 분석/배치       | Snowflake, BigQuery          | MPP, ETL                   |
| **A-B-A**   | 안전-임계 IoT   | 산업 제어, 긴급 경보         | MQTT, SCADA                |

## Part 2: NFR 우선순위

> **목표**: 품질 속성(Quality Attributes) 우선순위 결정

---

### P2-Q1. 핵심 품질은 무엇인가? (북극성)

**선택지**:

- **A (정확성)**: 100% 정확, 오류 불허
- **B (속도)**: 빠른 응답, 처리량
- **C (관련성)**: 맥락 이해, 품질

**상세 설명**: **Manual**(`01M-02_layer2_manual.md`) 3.1절 참고

---

### P2-Q2. 예상 사용자 규모는?

**선택지**:

- **A (소규모)**: < 100명
- **B (중규모)**: 100 ~ 10,000명
- **C (대규모)**: > 10,000명

**상세 설명**: **Manual**(`01M-02_layer2_manual.md`) 3.2절 참고

---

### P2-Q3. 데이터 노출 수준은?

**선택지**:
- **A (극비)**: 개인 금융, 의료
- **B (민감)**: 사용자 정보
- **C (공개)**: 공개 콘텐츠

**상세 설명**: **Manual**(`01M-02_layer2_manual.md`) 3.3절 참고

---

### P2-Q4. 데이터 최신성은?

**선택지**:
- **A (즉시)**: 실시간 (ms~초)
- **B (준실시간)**: 분~시간
- **C (배치)**: 일~주

**상세 설명**: **Manual**(`01M-02_layer2_manual.md`) 3.4절 참고

---

### NFR 프로파일 생성

**출력 형식**: `L2-Q1: A, L2-Q2: B, L2-Q3: B, L2-Q4: A → A-B-B-A`

**충돌 감지**:

- A (정확성) + A (즉시) → 가능하지만 비용 높음
- B (속도) + A (정확성) → 트레이드오프 필요

**상세 설명**: **Manual**(`01M-02_layer2_manual.md`) 3.5절 참고

---

## 템플릿

### Part 0: 핵심 기능
```markdown
## 핵심 기능

### Q0-1: 존재 이유
- 핵심 기능: [기능명]
- 구현 방식: [A, B, C...]

### Q0-2: 실패 영향
- 영향: [금전 손실 / 불편함 / 데이터 손실]
- 치명도: [A / B / C]
```

### Part 1: 패밀리

```markdown
## Layer 1: 아키텍처 패밀리

### L1-Q1: 실패 파급력
- 선택: [A / B]
- 이유: [...]

### L1-Q2: 정보 형태
- 선택: [A / B / C]
- 이유: [...]

### L1-Q3: 응답 시점
- 선택: [A / B / C]
- 이유: [...]

### 패밀리: [패밀리명] ([패턴])
```

### Part 2: NFR
```markdown
## Layer 2: NFR 우선순위

### L2-Q1: 핵심 품질
- 선택: [A / B / C]

### L2-Q2: 규모
- 선택: [A / B / C]

### L2-Q3: 데이터 노출
- 선택: [A / B / C]

### L2-Q4: 최신성
- 선택: [A / B / C]

### NFR 프로파일: [A-B-B-A]
```

---

## 다음 단계

**Stage 1 완료 후 → Stage 2: 구조설계**

Stage 1에서 결정된 내용:
- ✅ 패밀리 (예: A-C-A) → 필수 기술 방향
- ✅ 핵심 기능 (예: 거래) → 구현 후보군
- ✅ NFR 프로파일 (예: A-B-B-A) → 품질 우선순위

Stage 2에서 할 일:
- 🔄 외부 제약, 내부 자원
- 🔄 충돌 패턴 발견 (NFR vs 제약)
- 🔄 5단계 구현방법 (기능→속성→제약→기술→설계)
- 🔄 결정 요소 목록 작성

**다음 문서**: `02G-00_structure_design_guide.md`

---

## 참고 문서

- **상세 해설**: `01M-01_layer1_manual.md`, `01M-02_layer2_manual.md`
  - 왜 이 질문들인가?
  - 어떻게 답변하는가?
  - 7가지 패밀리 상세 설명

- **실전 사례**: `02E-01_stock_trading_case.md`
  - Case 1: Memory (CRUD/트랜잭션)
  - Case 2: BioNeX (검색/추천)
  - Case 3: BlueprintAI (협업/동기화)
  - Case 4: Stock Trading (실시간 트랜잭션) ⭐

- **이론적 근거**: `../research/ARCHITECTURE_THEORY_MAPPING.md`
  - SEI Quality Attributes
  - Martin Fowler Patterns
  - CAP Theorem

---

**버전 이력**:
- v4.0 (2025-11-14): Stage - Part - Layer 구조 재정립 및 오류 정정 포함 내용 수정
- v3.0 (2025-11-12): Stage 구조 재정립 (Layer 3 → Stage 2로 이동)
- v2.1 (2025-11-12): Part 0 추가, A-C-A 패밀리 추가
- v2.0 (2025-11-11): 3-Layer Decision Tree 도입
- v1.0 (2025-11-10): 7가지 고정 질문
