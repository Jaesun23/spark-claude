# Stage 2 Manual: 환경 제약 (Environment Constraints)

> **목적**: Stage 2 가이드의 상세 해설 - 왜? 어떻게? 실전 경험
>
> **버전**: v4.0 (2025-11-14)
> **연계 문서**: `02G-00_environment_constraints_guide.md`

---

## 📚 이 문서의 역할

**Guide에서 제공하는 것**:
- 질문 템플릿
- 작성 가이드
- 간단한 예시

**Manual에서 제공하는 것** (이 문서):
- **왜** 이 단계들이 필요한가?
- **어떻게** 조사하고 분석하는가?
- **실전 경험**과 통찰
- **주의사항**과 흔한 실수

---

## 📋 목차

1. [Part 1: Layer 3 (외부 제약) 조사](#1-part-1-layer-3-외부-제약-조사)
   - 1.1 [왜 Layer 3가 필요한가?](#11-왜-layer-3가-필요한가)
   - 1.2 [외부 서비스/API 비교 방법](#12-외부-서비스api-비교-방법)
   - 1.3 [규제/컴플라이언스 올바른 구분](#13-규제컴플라이언스-올바른-구분)
   - 1.4 [배포 환경 선택 가이드](#14-배포-환경-선택-가이드)

2. [Part 2: 충돌 패턴 식별](#2-part-2-충돌-패턴-식별)
   - 2.1 [충돌 패턴이란 무엇인가?](#21-충돌-패턴이란-무엇인가)
   - 2.2 [NFR 달성 가능성 분석](#22-nfr-달성-가능성-분석)
   - 2.3 [트레이드오프 결정 방법](#23-트레이드오프-결정-방법)

3. [Part 3: 6단계 구현 방법](#3-part-3-6단계-구현-방법)
   - 3.1 [SEI ADD 방법론](#31-sei-add-방법론)
   - 3.2 [속성 질문 템플릿](#32-속성-질문-템플릿)
   - 3.3 [제약 통합 방법](#33-제약-통합-방법)
   - 3.4 [패밀리별 기술 스택](#34-패밀리별-기술-스택)
   - 3.5 [아키텍처 설계 요소](#35-아키텍처-설계-요소)
   - 3.6 [DNA 시스템 구성](#36-dna-시스템-구성)

---

## 1. Part 1: Layer 3 (외부 제약) 조사

### 1.1 왜 Layer 3가 필요한가?

#### 외부 제약이 아키텍처를 80% 결정한다

Stage 2를 시작하기 전에 많은 사람들이 이렇게 생각합니다:

> "패밀리(A-C-A)가 결정되었으니 이제 기술을 선택하면 되겠지?"

하지만 **현실은 전혀 다릅니다**.

**Phase 2 주식 거래 플랫폼 사례** (2025-11-12 실전 발견):

```
증권사 선택 = 아키텍처 전체 결정!

한국투자증권 선택 시:
- Rate Limit: 20건/초
- API: REST + WebSocket
- OS: Linux/Windows/Mac (크로스 플랫폼)
- 배포: Docker, Cloud 가능
→ Python, Node.js, Java 선택 가능
→ 클라우드 네이티브 아키텍처

키움증권 선택 시:
- Rate Limit: 5건/초 (4배 느림!)
- API: COM/DLL (Windows 전용)
- OS: Windows Server 필수
- 배포: 온프레미스만 가능
→ C++, C# 전용
→ 레거시 아키텍처
```

**결론**:
- 외부 API **1개 선택** = 기술 스택 **80% 결정**
- 패밀리는 "방향"을 제시하지만, 외부 제약이 "실제 선택지"를 결정
- **Layer 3 조사 = 가장 중요한 실전 작업!**

---

#### Layer 3의 역할

**DNA 방법론의 흐름**:
```
Stage 1: 이상적 목표 설정
├─ Part 1: 패밀리 (A-C-A)
└─ Part 2: NFR (A-B-B-A)
    ↓
Stage 2: 현실 확인
├─ Part 1: Layer 3 (외부 제약) ← 여기!
├─ Part 2: 충돌 발견 (이상 vs 현실)
└─ Part 3: 현실적 구현방법
```

**Layer 3의 3가지 역할**:

1. **외부 제약 파악**: API, 규제, 인프라
2. **기술 후보 좁히기**: 불가능한 선택지 제거
3. **충돌 조기 발견**: NFR vs 제약

---

#### 왜 "Layer 3"라고 부르나?

**Stage 1 Part 1의 3-Layer Decision Tree**:
- Layer 1: 실패 영향
- Layer 2: 데이터 구조
- **Layer 3: 응답 시간** ← 이것!

Stage 2 Part 1에서는 **Layer 3 (응답 시간 요구사항)**을 만족하는 **외부 환경**을 조사합니다.

```
예시:
Stage 1 결정: Layer 3 = A (100ms 이하)
    ↓
Stage 2 조사: 실제 API가 100ms 이하로 응답 가능한가?
    ↓
발견: 대부분 API는 200-400ms
    ↓
충돌! → 트레이드오프 결정 필요
```

---

### 1.2 외부 서비스/API 비교 방법

#### 왜 비교가 필요한가?

**흔한 실수**:
```
개발자 A: "이 API 좋아 보이네. 이거 쓰자!"
         → 나중에 Rate Limit 때문에 전체 재설계...

개발자 B: "유명한 API니까 괜찮겠지?"
         → 나중에 플랫폼 제약 발견...
```

**올바른 접근**:
```
✅ 최소 3개 이상 후보 비교
✅ 체계적 비교표 작성
✅ 제약사항 명확히 문서화
```

---

#### 비교 방법: 3단계 필터링

**주식 거래 플랫폼 실전 사례** (2025-11-12):

**1단계: 기본 자격 확인**
```
질문: "개인 사용 가능한가?"

4개 증권사 조사:
✅ 한국투자증권: 개인 무료 API 제공
✅ 키움증권: 개인 무료 API 제공
✅ 이베스트투자증권: 개인 무료 API 제공
❌ 삼성증권: 개인 API 미제공

→ 3개로 좁혀짐
```

**2단계: 플랫폼 제약 확인**
```
질문: "크로스 플랫폼 가능한가?"

✅ 한국투자증권: REST API (크로스)
❌ 키움증권: COM/DLL (Windows 전용)
✅ 이베스트: REST API (크로스)

→ 2개로 좁혀짐
```

**3단계: 성능 비교**
```
질문: "Rate Limit은?"

한국투자증권: 20건/초 (실전), 2건/초 (모의)
이베스트: 10건/초

→ 최종 선택: 한국투자증권 (2배 빠름)
```

---

#### 비교표 템플릿

**7가지 핵심 비교 항목**:

| 비교 항목 | 설명 | 예시 |
|----------|------|------|
| **Rate Limit** | 초당 요청 제한 | 20건/초, 100건/초 |
| **API 방식** | 통신 프로토콜 | REST, WebSocket, gRPC, GraphQL |
| **비용** | 월 사용료 | 무료, $99/월, 종량제 |
| **플랫폼** | OS 제약 | Linux, Windows, Mac, 크로스 |
| **문서화** | 품질 | 우수, 보통, 빈약 |
| **SDK** | 언어별 지원 | Python, Java, Node.js, Go |
| **SLA** | 가용성 보장 | 99.9%, 99.99%, 보장 없음 |

**실전 비교표** (주식 거래):

| 증권사 | Rate Limit | API 방식 | 비용 | 플랫폼 | 문서화 | 추천도 |
|--------|-----------|---------|------|--------|--------|--------|
| **한국투자증권** | 20건/초 | REST + WS | 무료 | 크로스 | 우수 | ⭐⭐⭐ |
| 키움증권 | 5건/초 | COM/DLL | 무료 | Windows | 보통 | ⭐⭐ |
| 이베스트 | 10건/초 | REST + WS | 무료 | 크로스 | 보통 | ⭐⭐ |
| 삼성증권 | - | - | ❌ 불가 | - | - | ❌ |

---

#### 외부 API가 결정하는 것들

**1. 아키텍처 패턴**:
```
REST API → Request/Response 패턴
WebSocket → Event-Driven 패턴
gRPC → 고성능 RPC 패턴
GraphQL → Flexible Query 패턴
```

**2. 기술 스택**:
```
Python SDK 제공 → Python 선택 가능
Java Only → Java 필수
COM/DLL → Windows + C++/C# 강제
```

**3. 배포 환경**:
```
Cloud API → Docker, Kubernetes 가능
On-Premise API → 서버 직접 운영 필요
Windows Only → Linux 배포 불가
```

**4. 확장 전략**:
```
Rate Limit 높음 (100건/초) → 단순 구조
Rate Limit 낮음 (5건/초) → 큐, 캐싱, 배치 필수
```

**5. 비용 구조**:
```
무료 Tier → MVP 빠른 출시
종량제 → 성장에 따른 비용 예측 필요
고정 요금 → 안정적 예산
```

---

### 1.3 규제/컴플라이언스 올바른 구분

#### 개인 개발자 vs 서비스 제공자 ⭐

> **Jason의 중요한 지적** (2025-11-12):

**2호의 착각**:
```
❌ "개인 개발자가 거래 기록 10년 보관해야 하나요?"
❌ "금융위원회 규제를 모두 준수해야 하나요?"
```

**Jason의 수정**:
```
✅ "그건 증권회사가 지켜야 하는 규제입니다!"
✅ "우리는 API를 '사용'하는 것이지, '제공'하는 게 아닙니다!"
```

이 구분을 놓치면 **불필요한 규제 부담**을 자신에게 씌우게 됩니다!

---

#### 올바른 구분

**서비스 제공자의 의무** (우리와 무관):
```
증권회사가 해야 할 일:
- 거래 기록 10년 보관 (자본시장법)
- 투자자 KYC 인증 (금융실명제)
- 금융위원회 규제 준수
- 개인정보 암호화 저장 (개인정보보호법)
- 자금세탁방지 AML (특정금융정보법)

→ 이미 증권사가 다 하고 있음!
```

**개인 개발자/내부 시스템의 의무** (우리가 해야 함):
```
API 사용자가 해야 할 일:

✅ API 키 안전 저장
   - 환경변수 (.env)
   - Secret Manager (AWS Secrets Manager, Vault)
   - 절대 Git에 커밋 금지!

✅ HTTPS 통신 (기본)
   - 증권사 API는 이미 HTTPS 제공
   - 추가 작업 불필요

✅ 거래 로그 (자체 감사용)
   - 내 거래 이력 보관
   - 버그 추적, 세금 신고 용도
   - 법적 의무는 아님
```

---

#### 규제별 요구사항

**금융 규제** (개인용 시스템):
```
적용되는 것:
✅ API 키 유출 방지 (본인 책임)
✅ 무단 거래 방지
✅ 개인 정보 보호

적용 안 되는 것 (증권사 책임):
❌ 거래 기록 장기 보관
❌ KYC 인증
❌ 자금세탁방지
```

**의료 규제** (HIPAA - 미국):
```
적용:
✅ 환자 데이터 암호화
✅ 접근 제어 (RBAC)
✅ 감사 로그

영향:
→ Stage 1 Part 2: 보안 A (극비)
→ 암호화, 접근 제어 필수
```

**개인정보 보호** (GDPR - 유럽):
```
적용:
✅ 명시적 동의
✅ 데이터 삭제권 (Right to be forgotten)
✅ 데이터 이동권 (Data portability)

영향:
→ DB 설계: soft delete (is_deleted 플래그)
→ API: DELETE /users/:id/data
→ 복잡도 증가
```

---

### 1.4 배포 환경 선택 가이드

#### 배포 환경 3가지 선택지

**온프레미스** (On-Premise):
```
특징:
- 자체 서버에 직접 배포
- 완전한 제어권

장점:
✅ 최고 수준 보안 (물리적 격리)
✅ 규제 준수 용이 (금융, 의료)
✅ 네트워크 통제 가능

단점:
❌ 초기 비용 높음 (서버, 인프라)
❌ 운영 부담 (24/7 모니터링)
❌ 확장 어려움 (하드웨어 구매)

적용:
→ 금융, 의료, 정부 기관
→ 데이터 국외 반출 금지
```

**클라우드** (Public Cloud):
```
특징:
- AWS, Azure, GCP 등 활용
- 필요한 만큼 사용 (탄력적)

장점:
✅ 빠른 시작 (몇 분 만에 배포)
✅ 자동 확장 (트래픽 증가 대응)
✅ 관리 편의 (패치, 백업 자동화)

단점:
❌ 비용 예측 어려움 (종량제)
❌ 벤더 종속 (Lock-in)
❌ 규제 이슈 (데이터 위치)

적용:
→ 스타트업, SaaS 서비스
→ 글로벌 서비스
```

**하이브리드**:
```
특징:
- 온프레미스 + 클라우드 혼합

장점:
✅ 유연성 (민감 데이터는 온프레미스)
✅ 점진적 전환 가능

단점:
❌ 복잡도 증가
❌ 운영 어려움

적용:
→ 엔터프라이즈
→ 레거시 마이그레이션
```

---

#### OS 제약 고려사항

**Linux 선호** (권장):
```
장점:
✅ 클라우드 기본 OS
✅ 오픈소스 생태계 풍부
✅ 라이선스 비용 무료
✅ 컨테이너 최적화 (Docker)

제약:
❌ Windows API 의존 시 불가
❌ COM/DLL 사용 시 불가

선택 기준:
→ 외부 API가 크로스 플랫폼이면 Linux
```

**Windows 필수**:
```
케이스:
- .NET Framework (레거시)
- COM/DLL API (키움증권)
- Active Directory 연동
- MS SQL Server (특정 기능)

영향:
❌ 클라우드: Windows Server (비용 2배)
❌ Docker: Windows Container (복잡)
❌ 개발 환경: Windows 필요

선택 기준:
→ 외부 API가 Windows 전용이면 어쩔 수 없음
```

**크로스 플랫폼** (이상적):
```
기술:
✅ Python, Node.js, Java, Go
✅ REST API
✅ Docker

장점:
✅ CI/CD 간소화
✅ 개발 환경 유연 (Mac, Linux, Windows)
✅ 클라우드 선택의 자유

선택 기준:
→ 가능하면 항상 크로스 플랫폼 선택!
```

---

#### 네트워크 제약

**방화벽**:
```
제약:
- 아웃바운드 HTTPS만 허용
- 특정 IP만 허용

영향:
→ VPN 필요
→ Proxy 서버 설정
→ 배포 복잡도 증가

해결:
- 네트워크 팀과 사전 협의
- 허용 IP/Port 목록 작성
```

**대역폭**:
```
제약:
- 저속 (< 10Mbps)
- 불안정 (패킷 손실)

영향:
→ 실시간 스트리밍 불가 (WebSocket)
→ Polling 방식 선택
→ 데이터 압축 필수

해결:
- 대역폭 측정 (speedtest)
- Polling 주기 조정 (1초 → 5초)
```

---

## 2. Part 2: 충돌 패턴 식별

### 2.1 충돌 패턴이란 무엇인가?

#### 이상 vs 현실

Stage 1에서 우리는 **이상적인 목표**를 설정했습니다:
- 패밀리: A-C-A (실시간 트랜잭션)
- NFR: A-B-B-A (정확성 A, 즉시성 A)

하지만 Part 1에서 조사한 **현실적 제약**:
- API Rate Limit: 20건/초
- WebSocket 구독: 41개 제한

**충돌 발생!**

```
이상 (NFR):
"100개 조건을 초 단위로 정확히 감지!" (정확성 A)

현실 (제약):
"API는 초당 20건만 허용..." (Rate Limit)

충돌:
100건 요청 vs 20건 제한 → 불가능!
```

**충돌은 정상입니다!**

이상과 현실 사이의 간극은 항상 존재합니다. 중요한 것은:
- ✅ 충돌을 **조기에 발견**하고
- ✅ **의식적으로 트레이드오프**를 결정하며
- ✅ 그 결정을 **문서화**(ADR)하는 것입니다

---

#### 충돌 매트릭스

**템플릿**:
```markdown
| NFR 목표 | Layer 3 제약 | 충돌? | 영향 |
|----------|-------------|-------|------|
| ... | ... | ✅/❌ | ... |
```

**주식 거래 플랫폼 예시**:

| NFR 목표 | Layer 3 제약 | 충돌? | 영향 |
|----------|-------------|-------|------|
| 정확성 A (100%) | API 20건/초 | ✅ | 모든 조건 실시간 감지 불가 |
| 즉시성 A (1초) | WebSocket 41개 | ✅ | 100개 종목 동시 모니터링 불가 |
| 보안 B (민감) | HTTPS 기본 | ❌ | 충돌 없음 (API 자체 제공) |
| 규모 B (중간) | Rate Limit 20건/초 | ⚠️ | 서비스화 시 재검토 필요 |

**범례**:
- ✅ **충돌 확인** → 트레이드오프 필요
- ❌ **충돌 없음** → 그대로 진행
- ⚠️ **조건부** → 상황에 따라 다름

---

### 2.2 NFR 달성 가능성 분석

#### 체계적 분석 방법

**3단계 프로세스**:

**Step 1: NFR 목록 확인**
```
Stage 1 Part 2 결과:
- 정확성: A (100%)
- 성능: B (1초)
- 확장성: B (100-1000명)
- 최신성: A (실시간)
```

**Step 2: 각 NFR별 제약 매핑**
```
정확성 A:
- 요구: 오류율 < 0.01%
- 제약: API Rate Limit 20건/초
- 충돌: 100개 조건 × 1초 = 100건 vs 20건

성능 B:
- 요구: 응답 < 1초
- 제약: API 평균 200-400ms
- 충돌 없음: 여유 있음
```

**Step 3: 달성 가능성 판단**
```
✅ 가능: 제약이 목표를 충분히 만족
⚠️ 조건부: 일부 조건에서만 가능
❌ 불가능: 제약이 목표를 절대 만족 못함
```

---

#### 주식 거래 시스템 실전 분석

**NFR 프로파일: A-B-B-A**

**정확성 A (100%)**:
```
목표:
- 모든 조건을 100% 정확히 감지
- 조건 만족 시점을 놓치지 않음

제약:
- API Rate Limit: 20건/초 (실전), 2건/초 (모의)
- 100개 조건 체크 필요

분석:
100개 × 1초 = 100건/초 필요
하지만 20건/초 제한

달성 가능성: ⚠️ 조건부
- 전체 조건 실시간: ❌ 불가능
- 우선순위 20개 실시간: ✅ 가능
- 나머지 80개 5초 주기: ✅ 가능
```

**성능 B (1초 이하)**:
```
목표:
- API 응답 < 1초
- UI 업데이트 < 1초

제약:
- API 평균: 200-400ms
- 최대: 600-800ms (99 percentile)

달성 가능성: ✅ 가능
- 평균 응답이 목표의 절반 수준
- 충분한 여유
```

**확장성 B (100-1000명)**:
```
목표:
- 개인용 (1-2명) → 서비스화 (100명)

제약:
- WebSocket 41개 구독 제한
- 계정당 제한

분석:
- 1명 사용: 41개 종목 가능 ✅
- 100명 사용: 4,100개 필요 ❌

달성 가능성: ⚠️ 조건부
- 현재 (개인): ✅ 가능
- 미래 (서비스): ❌ 재설계 필요
```

**최신성 A (실시간)**:
```
목표:
- 호가 변동 즉시 반영 (< 100ms)
- 조건 만족 즉시 체결

제약:
- WebSocket: 50-100ms ✅
- Polling: 5000ms ❌

달성 가능성: ⚠️ 조건부
- WebSocket 종목: ✅ 가능 (41개)
- Polling 종목: ❌ 불가능 (59개)
```

---

### 2.3 트레이드오프 결정 방법

#### 3가지 옵션

충돌이 발견되면 다음 3가지 중 선택해야 합니다:

**옵션 1: NFR 완화**
```
정확성 A → B로 하향
즉시성 A → B로 하향

장점:
✅ 구현 단순
✅ 비용 절감
✅ 빠른 출시

단점:
❌ 품질 저하
❌ 사용자 경험 하락
❌ 경쟁력 감소

적용:
→ 비핵심 기능
→ MVP 단계
```

**옵션 2: 아키텍처 복잡화**
```
하이브리드 전략:
- 중요한 부분: NFR A 유지 (복잡한 구조)
- 덜 중요한 부분: NFR B 수용 (단순 구조)

장점:
✅ 핵심 품질 유지
✅ 사용자 만족도 유지

단점:
❌ 복잡도 증가
❌ 개발 시간 증가
❌ 비용 증가

적용:
→ 핵심 기능
→ 경쟁 우위 요소
```

**옵션 3: 범위 축소**
```
기능 제한:
- 100개 조건 → 20개 조건만 지원
- 미래 버전에서 확장

장점:
✅ NFR 유지
✅ 빠른 출시
✅ 단순 구조

단점:
❌ 기능 제한
❌ 사용자 불만 가능

적용:
→ MVP
→ 점진적 확장 전략
```

---

#### 실전 선택 사례: 주식 거래 플랫폼

**충돌 #1: 정확성 A vs Rate Limit**

```
선택: 옵션 2 (하이브리드)

결정:
- 우선순위 20개: WebSocket 실시간 감지 (정확성 A)
- 나머지 80개: 5초 주기 Polling (정확성 B)
- 사용자가 우선순위 설정 기능 제공

이유:
✅ 중요한 종목은 절대 놓치면 안 됨 (금전 손실)
✅ 사용자에게 선택권 부여
✅ 복잡하지만 가치 있음

ADR로 기록: ADR-102 "하이브리드 모니터링 전략"
```

**충돌 #2: 즉시성 A vs WebSocket 41개 제한**

```
선택: 옵션 2 (동적 구독)

결정:
- WebSocket 41개 슬롯 동적 할당
- 우선순위 높은 종목부터 배정
- 우선순위 변경 시 구독 교체 (1-2초)

이유:
✅ 핵심 종목은 실시간 유지
✅ 유연한 대응 가능
❌ 구독 교체 지연 있지만 수용 가능

ADR로 기록: ADR-103 "동적 WebSocket 구독 관리"
```

**충돌 #3: 모의투자 vs 실전 성능 차이 (10배)**

```
선택: 옵션 2 (이중 전략)

결정:
- 실전 기준으로 설계 (20건/초 활용)
- 모의투자는 기본 로직만 검증
- 백테스팅 환경 별도 구축 (과거 데이터)

이유:
✅ 실전 성능 최대 활용
✅ 모의 제약에 발목 잡히지 않음
⚠️ 모의 검증 불완전 → 백테스팅으로 보완

ADR로 기록: ADR-104 "실전 우선 설계 + 백테스팅 검증"
```

---

## 3. Part 3: 6단계 구현 방법

### 3.1 SEI ADD 방법론

#### 왜 이 순서인가?

DNA 방법론의 5단계는 **SEI Attribute-Driven Design (ADD)**에서 검증된 순서입니다:

```
기능 → 속성 → 제약 → 기술 → 설계
  1      2      3      4      5
```

**왜 이 순서가 중요한가?**

**잘못된 순서** (역순):
```
❌ 기술부터 선택:
"Python이 좋으니까 Python으로 하자!"
→ 나중에 Windows 전용 API 발견
→ Python 사용 불가
→ 전체 재작성...
```

**올바른 순서** (순차):
```
✅ 1. 기능: 주식 거래
✅ 2. 속성: 정확성 A, 즉시성 A
✅ 3. 제약: Windows 전용 API
✅ 4. 기술: C# 또는 C++ 선택
✅ 5. 설계: Windows Service 아키텍처

→ 처음부터 올바른 선택!
```

---

#### 5단계 상세

**1단계: 기능 요구사항**
```
질문: "무엇을 하는 시스템인가?"
출처: Stage 1 Part 0
예시: 주식 거래, 검색, 결제
```

**2단계: 속성 요구사항 (NFR)**
```
질문: "얼마나 잘 해야 하는가?"
출처: Stage 1 Part 2 + Part 2 충돌 분석
예시: 정확성 A→A, 즉시성 A→B (트레이드오프 반영)
```

**3단계: 제약 사항**
```
질문: "무엇이 불가능한가?"
출처: Part 1 조사
예시: Rate Limit 20건/초, Windows 전용
```

**4단계: 기술 스택**
```
질문: "어떤 도구를 쓸 것인가?"
방법: 패밀리 권장 기술 + 제약 필터링
예시: Python + FastAPI + PostgreSQL
```

**5단계: 아키텍처 설계**
```
질문: "어떻게 조합할 것인가?"
방법: 패턴 선택 + 충돌 해결
예시: Event-Driven + Hybrid Monitoring
```

---

### 3.2 속성 질문 템플릿

#### SEI ADD 속성 질문

각 기능마다 다음 질문들에 답하세요:

**성능 (Performance)**:
```
1. 응답 시간: 얼마나 빨라야?
   - 예: < 100ms, < 1초, < 5초

2. 처리량 (TPS): 초당 몇 건?
   - 예: 100 TPS, 1,000 TPS

3. 동시 사용자: 몇 명?
   - 예: 10명, 100명, 10,000명
```

**가용성 (Availability)**:
```
1. 다운타임 허용: 얼마나?
   - 예: 99.9% (월 43분), 99.99% (월 4분)

2. 실패 시 영향: 치명적? 복구 가능?
   - 예: 금전 손실, 사용자 불편

3. 복구 시간 (RTO): 얼마나 빨리?
   - 예: < 5분, < 1시간
```

**확장성 (Scalability)**:
```
1. 데이터 증가율: 일 몇 건?
   - 예: 일 100건, 일 10만 건

2. 사용자 증가: 월 몇 %?
   - 예: 월 10%, 월 100%

3. 확장 방식: 수직? 수평?
   - 예: Scale-up (서버 업그레이드), Scale-out (서버 추가)
```

**보안 (Security)**:
```
1. 데이터 민감도: 극비? 민감? 공개?
   - 예: 신용카드, 이메일, 공개 게시물

2. 위협 수준: 내부? 외부?
   - 예: 내부 직원, 해커

3. 규제: 어떤 법?
   - 예: GDPR, HIPAA, 개인정보보호법
```

---

#### 주식 거래 플랫폼 예시

```markdown
## 기능: 주식 거래

### 성능
- 거래 요청 응답: < 100ms (99 percentile)
- 조건 감지 주기:
  - 우선순위: 1초
  - 일반: 5초
- 동시 모니터링: 50개 종목 (개인), 200개 (미래)

### 가용성
- 다운타임: < 0.1% (99.9%, 거래 시간 기준)
- 실패 영향: 치명적 (금전 손실)
- 자동 재연결: 필수 (10초 이내)

### 확장성
- 초기: 1명
- 1년 후: 100명 (β 테스터)
- 3년 후: 1,000명 (서비스화)
- 데이터: 일 1,000건 (거래 기록)

### 보안
- 데이터: 민감 (API 키, 거래 내역)
- 위협: 외부 (해킹, 키 유출)
- 규제: 개인정보보호법
```

이 답변들이 **기술 스택 선택**의 기준이 됩니다!

---

### 3.3 제약 통합 방법

#### 현실적 목표 수정

**프로세스**:
```
속성 목표 (이상)
    ↓
제약 확인 (현실)
    ↓
충돌 발견
    ↓
목표 수정 (현실적)
```

**주식 거래 예시**:

```
속성 목표:
- 100개 종목 실시간 모니터링 (즉시성 A)
- 응답 < 100ms

제약:
- API Rate Limit: 20건/초
- WebSocket: 41개 구독

충돌:
- 100개 × 1초 = 100건 vs 20건 ❌
- 100개 구독 vs 41개 ❌

현실적 목표 수정:
- 우선순위 20개: WebSocket 실시간 (< 100ms) ✅
- 나머지 80개: Polling 5초 주기 (5000ms) ✅
- 총 API 사용: 20건 (WebSocket) + 16건 (Polling) = 36건/5초 = 7.2건/초 ✅
```

**핵심 원칙**:
> 속성 목표를 현실 제약 내로 조정하되, 핵심 가치는 반드시 지킨다!

---

### 3.4 패밀리별 기술 스택

#### 패밀리별 권장 기술

**A-A-B (트랜잭션/CRUD)**:
```
필수:
✅ RDBMS: PostgreSQL, MySQL
✅ ACID 트랜잭션
✅ ORM: TypeORM, SQLAlchemy, Hibernate

선택:
- 캐시: Redis
- 큐: RabbitMQ (비동기 작업)
- 검색: Elasticsearch
```

**B-B-B (검색/추천)**:
```
필수:
✅ Vector DB: Milvus, Pinecone, Weaviate
✅ 검색 엔진: Elasticsearch
✅ 임베딩: OpenAI, HuggingFace

선택:
- Feature Store: Feast
- A/B Testing: Optimizely
```

**A-C-A (실시간 트랜잭션)** ⭐:
```
필수:
✅ RDBMS: PostgreSQL (트랜잭션)
✅ WebSocket: Socket.io, FastAPI WebSocket
✅ 메시지 큐: Kafka, RabbitMQ (이벤트)
✅ 캐시: Redis (성능)

선택:
- CQRS: 읽기/쓰기 분리
- Event Sourcing: 이벤트 기록
```

**상세 옵션**:
각 패밀리별 상세 기술 매트릭스는 `docs/family-tech-matrix/` 참고

---

### 3.5 아키텍처 설계 요소

#### 5가지 설계 요소

**1. 시스템 구조**:
```
모놀리식:
- 장점: 단순, 배포 쉬움
- 단점: 확장 어려움
- 적용: MVP, 소규모

MSA (Microservices):
- 장점: 독립 배포, 확장 용이
- 단점: 복잡, 운영 부담
- 적용: 대규모, 팀 분산
```

**2. 데이터 흐름**:
```
동기 (Synchronous):
- Request/Response
- 단순, 이해 쉬움
- 예: REST API

비동기 (Asynchronous):
- Event-Driven
- 확장성, 복잡함
- 예: Kafka, WebSocket
```

**3. 통신 패턴**:
```
REST:
- HTTP 표준
- 간단, 범용적
- 예: CRUD 작업

WebSocket:
- 양방향 실시간
- 복잡, 상태 유지
- 예: 채팅, 실시간 데이터

gRPC:
- 고성능 RPC
- 빠름, Protocol Buffers
- 예: 마이크로서비스 간 통신
```

**4. 상태 관리**:
```
Stateless:
- 서버가 상태 저장 안 함
- 확장 쉬움
- 예: REST API

Stateful:
- 서버가 상태 유지
- WebSocket 연결 등
- 예: 실시간 모니터링
```

**5. 배포 전략**:
```
단일 서버:
- 간단, 저비용
- 확장 어려움

컨테이너 (Docker):
- 격리, 재현 가능
- 오케스트레이션 필요

오케스트레이션 (K8s):
- 자동 확장, 자동 복구
- 복잡, 학습 곡선
```

---

#### 주식 거래 플랫폼 아키텍처

```
시스템 구조: 하이브리드 모놀리식
- 초기: 단일 서비스
- 미래: 거래 엔진 분리

데이터 흐름:
- WebSocket: 비동기 (실시간 호가)
- REST: 동기 (거래 요청)

통신 패턴:
- WebSocket: 우선순위 종목 (41개)
- Polling: 일반 종목 (59개)
- REST: 거래 실행 (Rate Limit 관리)

상태 관리:
- Stateful: WebSocket 연결 유지
- Redis Queue: 거래 요청 순서 보장

배포 전략:
- Docker 컨테이너화
- AWS ECS (초기)
- Kubernetes (서비스화 시)
```

---

### 3.6 DNA 시스템 구성

#### 왜 DNA 시스템이 필요한가?

**핵심 개념**:
```
모든 소프트웨어 = DNA 시스템 (11개) + 도메인 시스템

DNA 시스템:
- 필수: 모든 프로젝트 공통
- 로깅, 에러 핸들링, 설정, DB 연결 등
- "꼬리에 꼬리를 물면서" 대부분 자동 결정

도메인 시스템:
- 선택: 문제 해결 위해 구상
- Priority Scheduler, Subscription Manager 등
```

**선택의 자유도**:
```
❌ 어쩔 수 없음 (Part 1): 외부 제약 → 한투 API, AWS Seoul
❌ 어쩔 수 없음 (Part 2): 충돌 타협 → 하이브리드 아키텍처
🔄 최선 선택 (Part 3-4단계): 기술 스택 → FastAPI, PostgreSQL
🔄 문제 해결 필수 (Part 3-5단계): 도메인 기술 → Priority Scheduler
🔄 자동 결정 (Part 3-6단계): DNA 시스템 → 패밀리 + 규모/예산
```

**Jason의 통찰**:
> "잘 생각해보면 대부분은 꼬리에 꼬리를 물면서 결정이 되어 버린답니다."

---

#### DNA 시스템 11개 목록

**프로젝트 공통 인프라** (모든 소프트웨어 필수):

1. **로깅 시스템**: 이벤트/에러 기록
2. **에러 핸들링**: 예외 처리 전략
3. **설정 관리**: 환경별 설정 분리
4. **DB 연결 관리**: 커넥션 풀링, 트랜잭션
5. **인증/인가**: 사용자 인증, 권한 관리
6. **캐싱**: 데이터 캐싱 전략
7. **비동기 처리**: 백그라운드 작업
8. **API 설계**: 엔드포인트 규칙
9. **테스트 전략**: 단위/통합/E2E 테스트
10. **배포 전략**: CI/CD, 무중단 배포
11. **모니터링**: 헬스체크, 알림

---

#### 결정 프로세스

**Step 1: 패밀리 매트릭스 확인**

각 패밀리는 DNA 시스템 11개에 대한 **권장 기술 스택**을 제공합니다.

**예시: A-C-A 패밀리** (실시간 트랜잭션 시스템):
```markdown
| DNA 시스템 | A-C-A 권장 | 이유 |
|-----------|-----------|------|
| 1. 로깅 | structlog (구조화) | 스트림 데이터 추적 필수 |
| 2. 에러 | 트랜잭션 롤백 | Layer 1: A (실패=손실) |
| 4. DB 연결 | async (비동기) | Layer 2: C (스트림 처리) |
| 6. 캐싱 | Redis (메모리) | Layer 3: A (100ms 이하) |
```

**예시: B-B-B 패밀리** (배치 처리 시스템):
```markdown
| DNA 시스템 | B-B-B 권장 | 이유 |
|-----------|-----------|------|
| 1. 로깅 | 파일 로깅 | 실시간 불필요 |
| 2. 에러 | 재시도 + 알림 | 손실 허용 가능 |
| 4. DB 연결 | sync (동기) | 순차 처리 |
| 6. 캐싱 | 로컬 메모리 | 속도 중요하지 않음 |
```

**💡 핵심**: 패밀리만 알면 DNA 시스템 **기본 방향이 자동 결정**!

---

**Step 2: 규모와 예산으로 조정**

| DNA 시스템 | 소규모 (< 1K 사용자) | 중규모 (< 100K) | 대규모 (> 100K) |
|-----------|------------------|---------------|--------------|
| **1. 로깅** | 파일 (무료) | CloudWatch ($10/월) | ELK ($100+/월) |
| **3. 설정** | .env 파일 | .env + Vault | Secrets Manager |
| **4. DB 연결** | pool_size=5 | pool_size=20 | PgBouncer |
| **6. 캐싱** | 로컬 메모리 | Redis ($30/월) | Redis Cluster |
| **7. 비동기** | BackgroundTasks | Celery | Celery Cluster |
| **10. 배포** | Docker | ECS Fargate | Kubernetes |
| **11. 모니터링** | 헬스체크 | Prometheus | Datadog ($200+/월) |

**💡 핵심**: 규모와 예산이 정해지면 DNA 시스템 **구체적 기술이 자동 결정**!

---

**Step 3: 기술 스택으로 나머지 결정**

| DNA 시스템 | FastAPI 기반 | Django 기반 | Go 기반 |
|-----------|-------------|------------|---------|
| **2. 에러** | HTTPException | Django Middleware | error wrapping |
| **8. API** | OpenAPI 자동 | DRF Serializer | Gin framework |
| **9. 테스트** | pytest-asyncio | Django test | testing package |

**💡 핵심**: 기술 스택이 정해지면 **나머지 DNA 시스템 자동 결정**!

---

#### 실전 예시: 주식 거래 플랫폼

**프로젝트 특성**:
- 패밀리: A-C-A (실시간 트랜잭션)
- 규모: 소규모 (< 100 사용자)
- 예산: 월 40만원
- 기술 스택: Python + FastAPI

**DNA 시스템 11개 결정 과정**:

```markdown
### 1. 로깅 시스템
🎯 패밀리: A-C-A → 구조화 로그 필수
💰 규모: 소규모 → 파일 로깅 충분
✅ 결정: structlog + 파일 로깅

### 2. 에러 핸들링
🎯 패밀리: A-C-A (Layer 1: A) → 트랜잭션 필수
🔧 기술: FastAPI → HTTPException 표준
✅ 결정: HTTPException + 트랜잭션 롤백

### 3. 설정 관리
💰 규모: 소규모 → Secrets Manager 불필요
🔧 기술: FastAPI → pydantic Settings 통합
✅ 결정: pydantic Settings + .env

### 4. DB 연결 관리
🎯 패밀리: A-C-A (Layer 2: C) → 비동기 필수
💰 규모: 소규모 → pool_size=5 충분
✅ 결정: SQLAlchemy async + pool_size=5

### 5. 인증/인가
💰 규모: 개인 사용 → OAuth 불필요
🔧 기술: Python → python-jose
✅ 결정: JWT (jose) + 간단한 RBAC

### 6. 캐싱
🎯 패밀리: A-C-A (Layer 3: A → B) → 메모리 캐시 필수
💰 예산: Redis $30/월 가능
✅ 결정: Redis 7+ (AWS ElastiCache)

### 7. 비동기 처리
💰 규모: 소규모 → Celery 불필요
🔧 기술: FastAPI → BackgroundTasks 내장
✅ 결정: FastAPI BackgroundTasks

### 8. API 설계
🔧 기술: FastAPI → OpenAPI 자동 문서화
💰 규모: 개인 → GraphQL 불필요
✅ 결정: REST + OpenAPI

### 9. 테스트 전략
🔧 기술: Python + async → pytest-asyncio
🎯 패밀리: A-C-A → 트랜잭션 테스트 필수
✅ 결정: pytest + pytest-asyncio

### 10. 배포 전략
💰 예산: 월 40만원 → K8s 불필요
💰 규모: 소규모 → 서버 관리 피하기
✅ 결정: Docker + AWS ECS Fargate

### 11. 모니터링
💰 규모: 소규모 → Datadog 불필요
💰 예산: 무료로 해결
✅ 결정: CloudWatch 기본 + 헬스체크
```

**결정 패턴 분석**:
```
패밀리 (A-C-A) → 4개 자동 결정 (로깅, 에러, DB, 캐싱)
규모 (소규모) → 5개 자동 결정 (설정, 비동기, 배포, 모니터링, 인증)
기술 스택 (FastAPI) → 2개 자동 결정 (API, 테스트)

총 11개 중 11개 "꼬리에 꼬리를 물면서" 결정됨! ✅
```

---

#### 흔한 실수

**❌ 실수 1: DNA 시스템을 나중에 생각**
```
잘못된 접근:
"일단 기능 구현하고 로깅/에러는 나중에"

왜 문제?
→ 나중에 리팩토링 비용 10배
→ 일관성 없는 코드
→ 디버깅 불가능
```

**✅ 올바른 접근**:
```
Stage 2 Part 3-6단계에서 DNA 시스템 11개 모두 결정
→ Stage 3에서 DNA ADR 11개 작성
→ Stage 4-6에서 기능 구현 시 DNA 시스템 사용
```

**❌ 실수 2: 과도한 엔지니어링**
```
잘못된 선택:
소규모인데 Kubernetes, Datadog, ELK 등

왜 문제?
→ 복잡도 증가
→ 비용 폭탄
→ 유지보수 부담
```

**✅ 올바른 접근**:
```
규모에 맞는 선택:
소규모 → Docker + CloudWatch + 파일 로깅
중규모 → ECS + Prometheus + Redis
대규모 → K8s + Datadog + ELK
```

**❌ 실수 3: 패밀리 무시**
```
잘못된 선택:
A-C-A 패밀리인데 동기 DB 연결, 파일 로깅

왜 문제?
→ NFR 달성 불가능
→ 성능 병목
→ 재설계 필요
```

**✅ 올바른 접근**:
```
패밀리 권장 사항 따르기:
A-C-A → 비동기 DB, 구조화 로그, 메모리 캐시
B-B-B → 동기 DB, 파일 로그, 로컬 메모리
```

---

#### 핵심 요약

**DNA 시스템 결정 공식**:
```
패밀리 권장 (40%)
+ 규모/예산 조정 (40%)
+ 기술 스택 연계 (20%)
= DNA 시스템 11개 자동 결정!
```

**Jason의 핵심**:
> "어쩔 수 없는 것부터 식별하고 분류한 후에 우리가 정할 수 있는 것들은 최선으로 선택을 하는 거에요. 그런데 잘 생각해보면 대부분은 꼬리에 꼬리를 물면서 결정이 되어 버린답니다."

**Stage 3 준비**:
- DNA 시스템 11개 → ADR-001 ~ ADR-011
- 외부 제약 3-5개 → ADR-101 ~ ADR-105
- 충돌 해결 2-3개 → ADR-201 ~ ADR-203
- 기술 스택 4-6개 → ADR-301 ~ ADR-306
- 도메인 기술 2-4개 → ADR-401 ~ ADR-404

**총 22-29개 ADR, 대부분 "꼬리에 꼬리를 물면서" 자동 결정!**

---

## 참고 문서

**가이드**:
- `02G-00_environment_constraints_guide.md` - Stage 2 질문 템플릿

**사례집**:
- `02E-01_stock_trading_case.md` - 주식 거래 시스템 전체 사례

**실전 발견**:
- `../backup-docs/session-summaries/20251112_Phase2_복합시스템_도전.md`
- `../backup-docs/session-summaries/20251112_Layer3_외부제약조사.md`

**이론적 근거**:
- `../research/ARCHITECTURE_THEORY_MAPPING.md` - SEI ADD 방법론

---

## 변경 이력

- **v4.1 (2025-11-14)**: DNA 시스템 추가
  - Part 3을 5단계 → 6단계로 확장
  - 3.6 DNA 시스템 구성 섹션 추가
  - ADR 5개 카테고리 체계 확립
  - "꼬리에 꼬리를 물면서" 자동 결정 프로세스 문서화

- **v4.0 (2025-11-14)**: 신규 작성
  - 기존 02M-01, 02M-02 통합
  - Part 1-3 구조 확립
  - Jason의 핵심 통찰 반영 (개인 vs 서비스 제공자)
  - 5단계 구현방법 SEI ADD 기반
  - 실전 사례 (주식 거래) 중심 설명

---

**문서 끝**
