# Phase 2: 복합 시스템 도전 - 주식 거래 플랫폼

**날짜**: 2025-11-12
**참여자**: Jason + 2호 (Claude Code)
**목적**: 3-Layer 프레임워크로 복합 시스템 분석 도전

---

## 🎯 현재 상황

### Phase 1 완료 ✅
- ✅ 이론적 매핑 완료 (ARCHITECTURE_THEORY_MAPPING.md)
- ✅ Layer 2 ↔ SEI Quality Attributes 검증
- ✅ Layer 1 ↔ Martin Fowler Patterns 검증
- ✅ 충돌 패턴 ↔ CAP/ACID/BASE 검증

### Phase 2 시작 🔄
- 목표: 실시간 스트리밍 패밀리 (패밀리 3) 사례 추가
- 선정: **주식 거래 플랫폼** (Jason이 나중에 실제 만들 시스템)

---

## 🔥 핵심 도전 과제 발견

### 복합 시스템의 복잡도

**시스템 구성**:
```
주식 거래 플랫폼 = 복합 시스템
├─ 1. 실시간 호가 스트리밍 (부가 기능)
│  └─ 역할: 최신 가격 정보 제공
│
└─ 2. 거래 (핵심 기능) 💥
   ├─ 구현 방식 A: 수동 거래
   │  └─ 사용자 클릭 → 거래 요청 → 체결
   └─ 구현 방식 B: 자동 거래
      ├─ 전략 1: 지정가 도달 시 매수
      ├─ 전략 2: % 변동 감지 시 매도
      └─ 전략 3: 정기 매수 (적립식)

   실패 영향: 거래 못 함 → 금전 손실 (A)
   → 구현 방식과 무관!
```

**핵심 인사이트**:
- **핵심 기능 = "거래" (하나!)**
- **수동/자동 = "구현 방식" (여러 개)**
- 거래 실패 = 금전 손실 (방식과 무관)

---

## 💡 Jason의 핵심 통찰

### "방법론의 본질"

```
❌ "복잡하니까 시스템을 쪼개자"
   → 구현 편의주의

✅ "3-Layer 질문이 이 복잡도를 해결하는가?"
   → 방법론 검증!
```

**Jason의 원칙**:
> "우리는 엔터프라이즈 기업의 소프트웨어 개발 방법을 연구하고 있어요.
> 복잡도를 떠나서 우리의 질문들이 어떻게 구성되어야
> 이 문제들을 해결할 시스템적 답안으로 이끌 것인가를 찾아야 한다는 거에요."

**검증 질문**:
```
현재 3-Layer 10개 질문으로
복합 시스템을 하나의 일관된 아키텍처로 이끌 수 있는가?

YES → 질문이 잘 설계됨 ✅
NO → 질문 수정/추가 필요 ⚠️
```

---

## 🎯 현재까지 분석 결과

### Layer 1: 아키텍처 패밀리 (핵심 기능 기준)

**판단 원칙**: "핵심 기능"의 **비즈니스 목적**으로 답변 (구현 방식 X)

**L1-Q1: 실패 파급력**
```
핵심 기능 = 거래 (Trading)
- 거래 요청 전달 실패 → 금전 손실
- 원하는 가격에 체결 못 함 → 금전 손실
- 수동/자동 무관, 모든 거래 실패가 치명적

선택: A (치명적) ✅
```

**L1-Q2: 정보 형태**
```
주가, 호가, 거래량 = 숫자 시계열
% 변동 계산, 이동평균
조건 비교 (지정가 도달 여부)

선택: C (숫자·분석 데이터) ✅
```

**L1-Q3: 응답 시점**
```
거래 요청 → 즉시 체결 필요
가격 변동 → 즉시 감지 필요
체결 완료 → 즉시 알림 필요

선택: A (즉각 응답) ✅
```

**→ 패밀리: A-C-A** 💥

**핵심 포인트**:
- ❌ "자동 거래"가 핵심 (구현 방식 기준)
- ✅ "거래 기능"이 핵심 (비즈니스 목적 기준)

### 🔥 중요 발견 1: 새로운 패밀리 패턴!

**기존 5개 패밀리**:
```
1. CRUD/트랜잭션 (A-A-A)
2. 검색/추천 (C-B-B)
3. 실시간 스트리밍 (B-C-A)
4. 협업/동기화 (B-A-A)
5. 분석/배치 (C-C-C)
```

**주식 거래 플랫폼**:
```
A-C-A ← 기존에 없던 조합!
```

**새 패밀리 후보**:
- **"실시간 트랜잭션"** 패밀리?
- 특성: 실패 치명적 + 숫자 데이터 + 즉각 응답
- 예시: 금융 거래, 자동화 시스템, IoT 제어

---

### Layer 2: NFR 우선순위

**L2-Q1: 핵심 품질**
```
A (가장 정확 - 100%) ✅
- 조건 감지 오류 = 금전 손실
- "70,000원 도달" 놓치면 안 됨
```

**L2-Q2: 규모**
```
B (B2C - 동시 1만 명) ✅
- 개인 투자자 플랫폼
```

**L2-Q3: 데이터 노출**
```
B (암호화 - 멀티 테넌트) ✅
- 개인 투자 내역 = 민감 정보
- 금융위원회 규제
```

**L2-Q4: 데이터 최신성**
```
A (즉시 반영 - 초 단위) ✅
- 호가 변동 즉시 반영
- 조건 감지 즉시 체결
```

**NFR 프로파일**: A-B-B-A

### 🔥 중요 발견 2: 충돌 패턴 예상

```
L2-Q1 (정확성 A: 100%) + L2-Q4 (즉시 A: 초 단위)
→ 100% 정확하게 + 즉시 감지/실행?
→ 가능한가? 트레이드오프 있나?
```

**예상 충돌**:
- 조건 감지의 정확성 vs 실시간 처리
- 모든 조건을 실시간으로 100% 정확히 감지 가능한가?

---

## 🤔 현재 질문 및 과제

### 질문 1: 패밀리 분류
- **A-C-A 패턴**을 어떻게 다룰 것인가?
  - 옵션 1: 6번째 패밀리 추가 ("실시간 트랜잭션")
  - 옵션 2: 기존 패밀리에 억지로 매핑
  - 옵션 3: 패밀리 수를 늘리는 게 맞는가?

### 질문 2: 복합 시스템 처리
- ✅ "핵심 기능" 판단 기준 명확화 완료
  - ❌ 구현 방식 (수동/자동)
  - ✅ 비즈니스 목적 (거래)
- 부가 기능(호가 스트리밍)은 어떻게 설계하나?
- Layer 1-2로 핵심 아키텍처 결정 → 부가 기능은 그 안에서 설계

### 질문 3: Layer 3 & 5단계
- Layer 3 (환경 제약) 적용 필요
- 5단계 구현방법 작성
- 충돌 패턴 해결 전략 도출

---

## 📝 다음 단계 (Context 복구 후)

### 1. Layer 3 완료 ✅

**접근 방식**: 내부 결정 사항 먼저 → 외부 제약 조사 → 통합 답변

#### Part 1: 우리가 결정/가정 가능한 항목 ✅

**L3-Q2: 팀 역량 (가정)**
```
팀 구성:
- 백엔드: 1-2명 (Python/Node.js)
- 프론트엔드: 1명 (React/Next.js)
- 금융 도메인 경험: 없음 (학습 필요)

기술 역량:
✅ 일반 웹 개발: 가능
✅ REST API, WebSocket: 가능
❓ 금융 규제 이해: 학습 필요
❓ 보안 인증: 학습 필요
```

**기술 스택 (제약 내 선택 가능)**
```
백엔드:
- FastAPI (Python) 또는 NestJS (Node.js)

프론트엔드:
- Next.js + React

실시간 통신:
- WebSocket (증권사 API 지원 시)
- Server-Sent Events (대안)

데이터:
- Redis (실시간 호가 캐싱)
- PostgreSQL (거래 기록, 사용자)
- TimescaleDB (시계열 데이터)
```

#### Part 2: 외부 제약 조사 완료 ✅

**조사 완료**: `20251112_Layer3_외부제약조사.md` 참고

**증권사 6개 비교 결과**:
```
| 증권사 | 초당 제한 | API 방식 | 개인 사용 |
|--------|-----------|----------|-----------|
| 한투 | 20건 | REST ✅ | 가능 ⭐ |
| 키움 | 5건 | COM/DLL | 가능 (Windows) |
| 이베스트 | 10건 | REST ✅ | 가능 |
| 대신 | ? | COM/DLL | 보안 이슈 ⚠️ |
| NH투자 | ? | QV API | 정보 부족 |
| 삼성 | - | - | 불가능 ❌ |

→ 한국투자증권 선택 (REST, 20건/초, 크로스 플랫폼)
```

**법적 규제 조사 결과**:
```
✅ 개인 사용:
- 5억원 미만 거래: 규제 없음
- 신고/인허가 불필요
- 거래 기록 보관 의무 없음
- 개인정보보호법 미적용

⚠️ 유일한 의무:
- 증권사 API 약관 준수
- 본인 계좌만 사용
- API 키 보안 관리

❌ 서비스화 시:
- 완전히 다른 차원의 규제 발생!
```

---

#### Part 3: Layer 3 최종 답변 (통합)

**L3-Q1: 기술 스택 제약은?**
```
외부 제약 (확정):
✅ 증권사: 한국투자증권
✅ API 방식: REST + WebSocket
✅ Rate Limit: 초당 20건 (실전), 2건 (모의)
✅ WebSocket: 1세션 41건
✅ 인증: 토큰 기반 (Appkey + App secret)
✅ OS: 크로스 플랫폼 (Linux/Docker 가능)
✅ 비용: API 무료

필수 구현:
- 요청 큐잉 시스템 (Redis Queue)
- Throttling (초당 20건 제한)
- WebSocket 구독 관리 (최대 41건)
- 토큰 갱신 자동화

선택 가능 (제약 내):
- 백엔드: FastAPI (Python) 또는 NestJS (Node.js)
- 프론트: Next.js + React
- 데이터: Redis, PostgreSQL, TimescaleDB
```

**L3-Q2: 팀 역량은?**
```
가정:
- 백엔드: 1-2명 (Python/Node.js)
- 프론트: 1명 (React/Next.js)
- 도메인 경험: 없음

필수 학습:
✅ 기술:
   - 증권사 API 사용법
   - WebSocket 실시간 통신
   - Rate Limiting 처리

✅ 보안 (권장):
   - API 키 보안 관리
   - 환경 변수 설정
   - Git 보안 (.gitignore)

❌ 불필요 (개인 사용):
   - 금융 규제 상세
   - KYC 프로세스
   - 개인정보보호법 상세
```

**L3-Q3: 배포 환경은?**
```
자유로운 선택:
✅ 클라우드 (AWS, Azure, GCP) 가능
✅ 로컬 서버 가능
✅ Docker 컨테이너 가능
✅ 한투 API = 크로스 플랫폼 OK

규제 제약 없음:
❌ 데이터 보관 의무 없음 (개인 사용)
❌ 국내 서버 의무 없음
❌ 금융보안원 인증 불필요

권장 사항 (선택):
- 안정적인 인터넷 연결
- 24/7 실행 환경 (거래 시간)
- 백업 (설정, 전략 코드)
```

### 2. 5단계 구현방법 작성
```
1단계: 기능 분해
  - 호가 스트리밍
  - 수동 거래
  - 자동 거래 (3가지 전략)

2단계: 속성 질문 ⭐
  - "조건 감지 정확도는?"
  - "호가 업데이트 지연은?"
  - "체결 응답 시간은?"

3단계: 제약조건
  - 거래소 API 호출 비용
  - 금융위원회 규제

4단계: 기술 옵션 탐색
  - WebSocket vs gRPC
  - Redis vs Kafka
  - 조건 감지 엔진?

5단계: 통합 설계
  - 전체 아키텍처
  - 데이터 흐름
```

### 3. 충돌 패턴 분석
```
충돌: 정확성 (A) + 즉시성 (A)
해결 전략: ???
ADR 작성: ???
```

### 4. Martin Fowler Patterns 매핑
```
A-C-A 패턴 → 어떤 Fowler Pattern?
- 실시간: Gateway (WebSocket)?
- 조건 감지: ???
- 자동 실행: Transaction Script?
```

---

## 🎁 핵심 교훈

### 1. 방법론 검증의 본질
```
❌ "사례를 방법론에 끼워 맞추기"
✅ "방법론이 사례를 해결하는지 검증"
```

### 2. 복잡도는 회피 대상이 아님
```
복잡한 시스템 = 방법론의 진짜 시험대
→ 여기서 막히면 질문 구조 개선 필요
→ 이게 진짜 "이론 검증"
```

### 3. 새로운 패턴 발견 = 성공
```
A-C-A 패턴 발견
→ 기존 5개 패밀리로 부족할 수 있음
→ 방법론 확장의 기회
```

---

## Part 4: 충돌 패턴 발견 및 분석 ⭐

### 🎯 충돌 패턴이란?

```
Layer 2: 이상적 목표 (NFR 우선순위)
         ↓
Layer 3: 현실적 제약 (외부 환경)
         ↓
      충돌 발견!
```

**핵심 원칙**:
- 충돌은 정상이다! (이상 vs 현실)
- 중요한 것: **의식적으로 트레이드오프 결정**
- ADR로 결정 근거 문서화

---

### 📋 Part 4 질문 체크리스트

#### Q4-1: NFR 달성 가능한가?

**Layer 2 목표 검토**:
```
NFR 프로파일: A-B-B-A

L2-Q1: 정확성 A (100% 정확)
→ 조건 감지 오류 = 금전 손실
→ "70,000원 도달" 놓치면 안 됨

L2-Q4: 최신성 A (초 단위 즉시)
→ 호가 변동 즉시 반영
→ 조건 감지 즉시 체결
```

**Layer 3 제약 확인**:
```
외부 API 제약:
- Rate Limit: 초당 20건 (실전)
- Rate Limit: 초당 2건 (모의)
- WebSocket: 41개 동시 구독
```

**달성 가능성 분석**:
```
✅ 가능한 것:
- 개별 거래 정확성 100% → API 자체가 보장
- 체결 즉시성 → WebSocket으로 즉시 알림

⚠️ 제약이 있는 것:
- 조건 감지 빈도 제한 → API 호출 제한
- 동시 감시 종목 수 제한 → WebSocket 41개
```

**결론**: ⚠️ **부분적 제약 존재**

---

#### Q4-2: 어떤 충돌이 있는가?

**충돌 #1: 정확성 A vs API Rate Limit**

```
목표 (L2-Q1):
- 정확성 A → 모든 조건을 100% 정확히 감지

현실 (L3):
- 초당 20건 제한 (실전)
- 초당 2건 제한 (모의)

충돌:
❌ 100개 조건을 초당 체크하려면?
   → 100건/초 필요 vs 20건/초 제한
   → 불가능!
```

**영향**:
- 조건 체크 주기가 길어짐 (5초마다 100개 체크 = 20건/초)
- 조건 만족 시점 감지 지연 가능
- 빠른 시장 변동 시 놓칠 위험

---

**충돌 #2: 즉시성 A vs WebSocket 구독 제한**

```
목표 (L2-Q4):
- 최신성 A → 호가 변동 즉시 반영

현실 (L3):
- WebSocket 41개 동시 구독 제한

충돌:
❌ 100개 종목을 실시간 감시하려면?
   → 100개 구독 필요 vs 41개 제한
   → 불가능!
```

**영향**:
- 전체 종목 실시간 감시 불가
- 우선순위 높은 41개만 WebSocket
- 나머지는 Polling (정확성·즉시성 하락)

---

**충돌 #3: 모의투자 vs 실전 투자 성능 차이**

```
목표:
- 모의투자로 전략 검증 후 실전 투자

현실:
- 모의투자: 초당 2건 제한 ⚠️
- 실전투자: 초당 20건 제한
- 10배 차이!

충돌:
❌ 모의투자 검증 결과를 실전에 적용 가능한가?
   → 제약이 달라서 동작이 다를 수 있음!
```

**영향**:
- 모의에서 성공한 전략이 실전에서 실패 가능
- 모의에서 충분한 테스트 불가능
- 전략 검증의 신뢰도 하락

---

#### Q4-3: 트레이드오프 필요한가?

**트레이드오프 #1: 정확성 vs 감시 범위**

```
Option A: 정확성 우선
- WebSocket 41개 + Polling 최소화
- 감시 범위: 41개 종목만 100% 정확
- 나머지는 포기

Option B: 범위 우선
- 100개 종목 모두 감시
- Polling (5초 주기) → 정확성 하락
- 빠른 변동 놓칠 위험

→ 결정 필요! (ADR #1)
```

---

**트레이드오프 #2: 즉시성 vs 비용**

```
Option A: 즉시성 최대화
- 조건 체크 주기 짧게 (1초)
- API 호출 많음 → Rate Limit 도달
- 추가 비용 발생 가능 (유료 플랜)

Option B: 비용 최소화
- 조건 체크 주기 길게 (5초)
- API 호출 적음 → 무료 플랜
- 즉시성 하락 (5초 지연)

→ 결정 필요! (ADR #2)
```

---

**트레이드오프 #3: 복잡도 vs 성능**

```
Option A: 단순 구조
- Queue 없이 직접 API 호출
- 구현 간단
- Rate Limit 초과 시 실패

Option B: 복잡한 구조
- Redis Queue + Throttling
- 구현 복잡
- Rate Limit 보장, 안정성 향상

→ 결정 필요! (ADR #3)
```

---

### 🎯 충돌 패턴 요약

| 충돌 | Layer 2 목표 | Layer 3 제약 | 심각도 |
|------|-------------|-------------|-------|
| #1: 조건 감지 | 정확성 A (100%) | API 20건/초 | 🔴 높음 |
| #2: 실시간 감시 | 즉시성 A (초 단위) | WebSocket 41개 | 🔴 높음 |
| #3: 모의 검증 | 전략 검증 신뢰 | 모의 2건/초 | 🟡 중간 |

**결론**:
- ✅ 개별 거래 정확성·즉시성은 달성 가능
- ⚠️ 대규모 감시·처리는 트레이드오프 필요
- 📝 ADR 3개 작성 필요

---

---

## Stage 2 Part 3: 구현방법 결정 (5단계 프로세스)

### 🎯 5단계 프로세스 개요

```
입력: Stage 1 결과 + Stage 2 Part 1-2 결과
   ↓
1️⃣ 기능 분해: 문제 → 필요한 기능들
   ↓
2️⃣ 속성 질문 ⭐: 각 기능의 구체적 NFR
   ↓
3️⃣ 제약조건: 팀, 비용, 규제, 외부 시스템
   ↓
4️⃣ 기술 옵션: 속성과 제약 하에서 선택
   ↓
5️⃣ 통합 설계: 아키텍처 + Schema + API
   ↓
출력: 구체적 구현 계획
```

---

### 1️⃣ 기능 분해

**핵심 기능**: 거래 (Trading)

**필요한 기능 분해**:
```
F1. 거래 조건 설정
    - 사용자가 조건 입력 (종목, 가격, 수량)
    - 조건 유효성 검증
    - 조건 저장

F2. 실시간 시장 데이터 수신
    - 호가 데이터 스트리밍 (WebSocket)
    - 체결가 데이터 수신
    - 거래량, 변동률 등 추가 정보

F3. 조건 감지 및 체결
    - 설정된 조건과 시장 데이터 비교
    - 조건 만족 시 거래 API 호출
    - 체결 결과 확인

F4. 거래 내역 관리
    - 체결 내역 저장
    - 수익률 계산
    - 거래 이력 조회

F5. 알림 및 모니터링
    - 조건 만족 시 알림
    - 체결 완료 알림
    - 오류 발생 시 알림
```

---

### 2️⃣ 속성 질문 ⭐ (NFR 구체화)

**Stage 1 Layer 2 결과 활용**:
```
NFR 프로파일: A-B-B-A
- 정확성: A (100%)
- 규모: B (1만 명)
- 보안: B (암호화)
- 최신성: A (초 단위)
```

#### Q2-1: 성능 요구사항 (최신성 A → 속성 질문)

**F2 (실시간 데이터 수신)**:
```
Q: 시장 데이터를 얼마나 빨리 받아야 하나요?
A: 실시간 (100ms 이내)
   → WebSocket 필수

Q: 몇 개 종목을 동시에 감시하나요?
A: 100개 종목
   → WebSocket 41개 제한 충돌! (Part 2 발견)

Q: 데이터 업데이트 빈도는?
A: 호가 변동마다 (초당 수십~수백 건)
   → 고빈도 처리 필요
```

**F3 (조건 감지)**:
```
Q: 조건을 얼마나 자주 체크해야 하나요?
A: 실시간 (1초 이내)
   → Polling vs Event-driven?

Q: 조건 체크 지연이 얼마나 허용되나요?
A: 최대 1초 (가격 변동 놓치면 손실)
   → 낮은 레이턴시 필수
```

#### Q2-2: 품질 요구사항 (정확성 A → 속성 질문)

**F3 (조건 감지 및 체결)**:
```
Q: 조건 감지를 놓치면 어떻게 되나요?
A: 금전 손실 (원하는 가격에 못 삼)
   → 100% 정확성 필요

Q: 잘못된 가격에 체결되면?
A: 직접적 금전 손실
   → 가격 검증 필수

Q: 중복 체결이 발생하면?
A: 의도하지 않은 매수 (2배 손실)
   → 멱등성(Idempotency) 보장 필요
```

**F4 (거래 내역)**:
```
Q: 거래 기록이 손실되면?
A: 세금 신고 문제, 수익률 계산 불가
   → 영구 저장 필요
```

#### Q2-3: 규모 요구사항 (규모 B → 속성 질문)

**전체 시스템**:
```
Q: 동시 사용자 수는?
A: 1만 명 (B2C)

Q: 사용자당 조건 개수는?
A: 평균 10개 (최대 100개)
   → 총 10만~100만 개 조건 감시

Q: 피크 시간대 부하는?
A: 장 시작/종료 시 집중 (3배)
   → 스케일링 필요
```

#### Q2-4: 보안 요구사항 (보안 B → 속성 질문)

**F1 (조건 설정)**:
```
Q: 다른 사용자의 조건을 볼 수 있나요?
A: 절대 안 됨 (개인 투자 전략 = 민감 정보)
   → 멀티 테넌트 격리 필요

Q: API 키가 노출되면?
A: 계좌 접근 가능 → 금전 손실
   → 암호화 저장, HTTPS 필수
```

#### Q2-5: 환경 요구사항 (Stage 2 Part 1 결과)

**배포 환경**:
```
Q: 어디서 실행되나요?
A: 클라우드 (AWS/GCP) 또는 로컬 서버
   → 플랫폼 무관 설계

Q: 24/7 실행이 필요한가요?
A: 거래 시간 (9:00-15:30) 필수
   → 고가용성 중요도 중간

Q: 데이터 센터 위치 제약은?
A: 한국 내 (증권사 API 레이턴시)
   → 한국 리전 권장
```

---

### 3️⃣ 제약조건 파악

#### 외부 제약 (Stage 2 Part 1 결과)

```
증권사 API:
✅ 한국투자증권 선택
✅ REST API: 초당 20건 (실전), 2건 (모의)
✅ WebSocket: 41개 동시 구독
✅ 인증: 토큰 기반 (1시간 TTL)
✅ 비용: 무료

규제:
✅ 개인 사용: 규제 없음 (5억원 미만)
✅ 본인 계좌만 사용
✅ API 약관 준수
```

#### 내부 제약

```
팀 역량:
- 백엔드: 1-2명 (Python/Node.js)
- 프론트엔드: 1명 (React)
- 금융 도메인: 학습 필요

비용:
- 클라우드: 월 $100 이하
- DB: 무료 티어 활용
- 모니터링: 오픈소스

일정:
- MVP: 3개월
- 전체: 6개월
```

---

### 4️⃣ 기술 옵션 비교 및 선택

#### Option 1: 단순 Polling 방식

**아키텍처**:
```
사용자 → API Server → Polling Worker
                           ↓
                  증권사 API (REST)
                           ↓
                       PostgreSQL
```

**장점**:
- ✅ 구현 간단
- ✅ 디버깅 쉬움
- ✅ 팀 역량 내

**단점**:
- ❌ API Rate Limit 초과 (100개 종목 × 1초 = 100건/초 > 20건/초)
- ❌ 레이턴시 높음 (최소 5초 주기)
- ❌ 정확성 하락 (빠른 변동 놓침)

**적합성**: ❌ NFR 정확성 A, 최신성 A 달성 불가

---

#### Option 2: WebSocket + Polling 하이브리드 ⭐ (권장)

**아키텍처**:
```
사용자 → API Server → Condition Manager
                           ↓
        ┌─────────────────┴─────────────────┐
        ↓                                    ↓
  WebSocket Handler (41개)         Polling Worker (나머지)
        ↓                                    ↓
  증권사 WebSocket                 증권사 REST API
        ↓                                    ↓
        └─────────────────┬─────────────────┘
                          ↓
                    Redis Queue + PostgreSQL
```

**상세 설계**:
```
1. 우선순위 기반 감시:
   - 상위 41개: WebSocket (실시간, 100ms)
   - 나머지: Polling (5초 주기)

2. Rate Limiting:
   - Redis 기반 Throttling
   - Queue를 통한 순차 처리
   - 초당 20건 보장

3. 우선순위 동적 조정:
   - 조건 만족 임박 → WebSocket으로 승격
   - 조건 만족 멀어짐 → Polling으로 강등
```

**장점**:
- ✅ 정확성 A 달성 (중요 종목 실시간 감시)
- ✅ 최신성 A 달성 (WebSocket 100ms)
- ✅ API 제한 준수 (Queue + Throttling)
- ✅ 확장 가능 (우선순위 조정)

**단점**:
- ⚠️ 복잡도 증가 (Redis, Queue 관리)
- ⚠️ WebSocket 연결 관리 필요
- ⚠️ 우선순위 알고리즘 필요

**적합성**: ✅ NFR 달성 + 제약 준수 + 확장성

---

#### Option 3: 완전 Event-Driven (과도한 설계)

**아키텍처**:
```
사용자 → API Gateway → Lambda Functions
                              ↓
                        Kafka/RabbitMQ
                              ↓
                    여러 Microservices
                              ↓
                        DynamoDB/Redis
```

**장점**:
- ✅ 확장성 극대화
- ✅ 고가용성

**단점**:
- ❌ 복잡도 과다 (MVP 범위 초과)
- ❌ 비용 증가 (월 $500+)
- ❌ 팀 역량 부족
- ❌ 디버깅 어려움

**적합성**: ❌ Over-engineering (팀 역량, 비용 초과)

---

#### 기술 스택 결정 (Option 2 기반)

| 계층 | 기술 | 이유 |
|------|------|------|
| **백엔드** | FastAPI (Python) | - 비동기 지원 (WebSocket)<br>- 빠른 개발<br>- 팀 역량 |
| **실시간** | WebSocket (증권사 제공) | - 41개 종목 실시간 감시<br>- 100ms 레이턴시 |
| **Queue** | Redis + Bull/Celery | - Rate limiting<br>- 작업 큐잉<br>- 무료 티어 |
| **DB** | PostgreSQL | - 거래 기록 영구 저장<br>- ACID 보장<br>- 무료 티어 |
| **캐시** | Redis | - 호가 데이터 캐싱<br>- 조건 우선순위 관리 |
| **프론트** | Next.js + React | - SSR 성능<br>- 실시간 업데이트 (SWR) |
| **배포** | Docker + AWS ECS | - 컨테이너화<br>- 스케일링 용이 |

---

### 5️⃣ 통합 설계

#### 아키텍처 다이어그램

```
┌─────────────────────────────────────────────────────────────┐
│                       사용자 (Web UI)                        │
└──────────────────────────────┬──────────────────────────────┘
                               ↓
┌─────────────────────────────────────────────────────────────┐
│                    FastAPI Backend                          │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐      │
│  │ Auth API     │  │ Condition API│  │ History API  │      │
│  └──────────────┘  └──────────────┘  └──────────────┘      │
└──────────────────────────────┬──────────────────────────────┘
                               ↓
┌─────────────────────────────────────────────────────────────┐
│                  Condition Manager (핵심)                    │
│  ┌───────────────────────────────────────────────────┐      │
│  │ Priority Calculator (우선순위 41개 선택)          │      │
│  └───────────────────────────────────────────────────┘      │
└───────────┬──────────────────────────────┬──────────────────┘
            ↓                              ↓
┌─────────────────────┐        ┌─────────────────────┐
│ WebSocket Handler   │        │ Polling Worker      │
│ - 41개 종목         │        │ - 나머지 종목        │
│ - 실시간 (100ms)    │        │ - 5초 주기           │
└─────────┬───────────┘        └─────────┬───────────┘
          ↓                              ↓
┌─────────────────────────────────────────────────────┐
│         증권사 API (한국투자증권)                    │
│  ┌──────────────┐           ┌──────────────┐       │
│  │ WebSocket    │           │ REST API     │       │
│  │ (41 구독)    │           │ (20건/초)    │       │
│  └──────────────┘           └──────────────┘       │
└─────────┬──────────────────────────┬────────────────┘
          ↓                          ↓
┌─────────────────────────────────────────────────────┐
│              Redis Queue + Cache                    │
│  - Rate Limiting (20건/초)                          │
│  - 우선순위 관리                                     │
│  - 호가 데이터 캐싱                                  │
└─────────────────────┬───────────────────────────────┘
                      ↓
┌─────────────────────────────────────────────────────┐
│              PostgreSQL                             │
│  - 조건 저장                                         │
│  - 거래 내역                                         │
│  - 사용자 정보                                       │
└─────────────────────────────────────────────────────┘
```

#### 데이터 스키마 v1.0

**Conditions (조건)**:
```sql
CREATE TABLE conditions (
  id UUID PRIMARY KEY,
  user_id UUID NOT NULL,
  stock_code VARCHAR(10) NOT NULL,    -- 종목 코드
  condition_type VARCHAR(20) NOT NULL, -- 'price_above', 'price_below'
  target_price DECIMAL(10,2) NOT NULL,
  quantity INT NOT NULL,
  priority INT DEFAULT 50,             -- 0-100 (높을수록 우선)
  status VARCHAR(20) DEFAULT 'active', -- 'active', 'triggered', 'expired'
  created_at TIMESTAMP DEFAULT NOW(),
  triggered_at TIMESTAMP,
  INDEX idx_user_active (user_id, status),
  INDEX idx_priority DESC (priority)
);
```

**Trades (거래 내역)**:
```sql
CREATE TABLE trades (
  id UUID PRIMARY KEY,
  user_id UUID NOT NULL,
  condition_id UUID REFERENCES conditions(id),
  stock_code VARCHAR(10) NOT NULL,
  trade_type VARCHAR(10) NOT NULL,   -- 'buy', 'sell'
  price DECIMAL(10,2) NOT NULL,
  quantity INT NOT NULL,
  total_amount DECIMAL(15,2) NOT NULL,
  executed_at TIMESTAMP DEFAULT NOW(),
  api_response JSONB,                -- 증권사 API 응답 저장
  INDEX idx_user_time (user_id, executed_at DESC)
);
```

**Redis 구조**:
```
# WebSocket 구독 목록 (Sorted Set)
websocket:subscriptions -> {stock_code: priority}

# Polling 큐 (List)
polling:queue -> [stock_code1, stock_code2, ...]

# Rate Limiting (String with TTL)
ratelimit:{api_type} -> count (TTL 1초)

# 호가 캐시 (Hash)
price:{stock_code} -> {bid, ask, last, timestamp}
```

#### API 설계 v1.0

**조건 생성**:
```http
POST /api/v1/conditions
Content-Type: application/json

{
  "stock_code": "005930",        # 삼성전자
  "condition_type": "price_above",
  "target_price": 70000,
  "quantity": 10
}

Response 201:
{
  "id": "uuid",
  "priority": 50,
  "status": "active",
  "estimated_trigger_time": "2025-11-12T14:30:00Z"
}
```

**조건 목록 조회**:
```http
GET /api/v1/conditions?status=active

Response 200:
{
  "conditions": [
    {
      "id": "uuid",
      "stock_code": "005930",
      "target_price": 70000,
      "current_price": 69500,
      "priority": 75,           # 가격 근접 → 우선순위 상승
      "monitoring_type": "websocket"  # 또는 "polling"
    }
  ]
}
```

**거래 내역 조회**:
```http
GET /api/v1/trades?from=2025-11-01&to=2025-11-30

Response 200:
{
  "trades": [...],
  "total_profit": 150000,
  "win_rate": 0.65
}
```

---

### 🎯 구현방법 결정 요약

| 항목 | 결정 내용 |
|------|----------|
| **아키텍처** | WebSocket + Polling 하이브리드 |
| **핵심 전략** | 우선순위 기반 41개 실시간 감시 |
| **백엔드** | FastAPI (Python, 비동기) |
| **큐/캐시** | Redis (Rate limit + Priority) |
| **DB** | PostgreSQL (거래 기록) |
| **프론트** | Next.js + React |
| **배포** | Docker + AWS ECS |

**NFR 달성 검증**:
- ✅ 정확성 A: 중요 종목 WebSocket 실시간 감시
- ✅ 최신성 A: 100ms 레이턴시 (WebSocket)
- ✅ 규모 B: 1만 명 (Redis Queue로 확장 가능)
- ✅ 보안 B: 멀티 테넌트 격리, HTTPS, API 키 암호화

**제약 준수**:
- ✅ API 20건/초: Redis Throttling으로 보장
- ✅ WebSocket 41개: 우선순위 알고리즘으로 최적 활용
- ✅ 팀 역량: FastAPI, React 모두 가능
- ✅ 비용: 무료 티어 + 월 $50 이하

---

---

## Stage 3: ADR 작성 (Architecture Decision Records)

### 🎯 ADR의 목적

**ADR = 모든 "왜?"에 대한 답**

새로운 팀원이 참가했을 때:
- "왜 C++이 아니라 Python이죠?" → ADR-006 참고
- "왜 WebSocket + Polling을 같이 쓰나요?" → ADR-003 참고
- "왜 한국투자증권이죠?" → ADR-001 참고

**핵심 원칙**:
> "제약에 의한 결정"도 ADR이다!
> 선택지가 1개여도 "왜 이것밖에 없었는지" 기록해야 한다.

---

### 📋 ADR 전체 목록 (18개)

#### 🏢 외부 제약에 의한 결정

**ADR-001: 한국투자증권 API 선택** ⭐ (예시 작성)
- Context: 6개 증권사 API 비교
- Decision: 한국투자증권 REST API
- Why: 크로스 플랫폼, 20건/초, WebSocket 지원

**ADR-002: REST API 사용 (vs COM/DLL)**
- Context: 키움증권(COM/DLL) vs 한국투자(REST)
- Decision: REST API 우선
- Why: 크로스 플랫폼, Docker 배포 가능

---

#### ⚡ 충돌 해결 결정

**ADR-003: WebSocket + Polling 하이브리드 아키텍처** ⭐ (예시 작성)
- Context: NFR (정확성 A + 즉시성 A) vs 제약 (API 20건/초, WebSocket 41개)
- Decision: 하이브리드 방식
- Why: 충돌 해결 + NFR 달성

**ADR-004: 우선순위 기반 41개 종목 선택 알고리즘**
- Context: 100개 종목 vs WebSocket 41개 제한
- Decision: 동적 우선순위 알고리즘
- Why: 중요 종목만 실시간 감시

**ADR-005: Redis Queue 기반 Rate Limiting**
- Context: API 20건/초 제한
- Decision: Redis + Bull Queue + Throttling
- Why: 제한 준수 + 안정성

---

#### 🛠️ 기술 스택 결정

**ADR-006: FastAPI (Python) 백엔드 선택** ⭐ (예시 작성)
- Context: FastAPI vs NestJS vs Django
- Decision: FastAPI
- Why: 비동기 WebSocket, 빠른 개발, 팀 역량

**ADR-007: PostgreSQL 데이터베이스 선택**
- Context: PostgreSQL vs TimescaleDB vs MongoDB
- Decision: PostgreSQL
- Why: ACID 보장, 무료, 관계형 데이터

**ADR-008: Redis 캐시 및 큐 선택**
- Context: Redis vs Memcached vs RabbitMQ
- Decision: Redis
- Why: 캐시 + 큐 + Rate limit 통합

**ADR-009: Next.js 프론트엔드 선택**
- Context: Next.js vs CRA vs Vue
- Decision: Next.js
- Why: SSR, 실시간 업데이트 (SWR), SEO

**ADR-010: Docker + AWS ECS 배포**
- Context: Docker+ECS vs Kubernetes vs Serverless
- Decision: Docker + ECS
- Why: 팀 역량, 비용, 충분한 확장성

---

#### 📐 데이터 설계 결정

**ADR-011: UUID vs Auto Increment (조건 ID)**
- Context: Primary Key 전략
- Decision: UUID
- Why: 분산 환경, 충돌 없음, 보안

**ADR-012: JSONB 컬럼 (API 응답 저장)**
- Context: JSONB vs 테이블 정규화
- Decision: api_response JSONB
- Why: 유연성, 증권사 API 변경 대응

**ADR-013: 복합 인덱스 전략**
- Context: 조건 조회 성능
- Decision: idx_user_active, idx_priority
- Why: 쿼리 패턴 최적화

**ADR-014: Redis 데이터 구조 선택**
- Context: Sorted Set vs List vs Hash
- Decision: Sorted Set (우선순위), Hash (캐시)
- Why: 우선순위 정렬, 빠른 조회

---

#### 🔌 API 설계 결정

**ADR-015: REST API 버전 관리 (/api/v1)**
- Context: URL vs Header versioning
- Decision: URL 버전 (/api/v1)
- Why: 명확성, 클라이언트 호환성

**ADR-016: 에러 응답 형식 (RFC 7807)**
- Context: 커스텀 vs 표준
- Decision: RFC 7807 Problem Details
- Why: 표준, 구조화, 클라이언트 파싱 용이

---

#### 🔒 품질 및 보안 결정

**ADR-017: 멱등성 보장 (Idempotency Key)**
- Context: 중복 체결 방지
- Decision: 조건 ID 기반 멱등성
- Why: 중복 거래 = 금전 손실

**ADR-018: 토큰 갱신 전략 (사전 갱신)**
- Context: 토큰 만료 (1시간) 처리
- Decision: 50분 시점 사전 갱신
- Why: 거래 중단 방지

---

### 📝 ADR 예시 (3개)

---

#### ADR-001: 한국투자증권 API 선택

**Status**: Accepted
**Date**: 2025-11-12
**Type**: External Constraint (외부 제약)

---

##### Context

주식 거래 플랫폼 구현을 위해 증권사 API가 필요합니다.

**요구사항** (Stage 1 Layer 2):
- NFR Profile: A-B-B-A
- 정확성 A: 100% 정확한 체결
- 최신성 A: 실시간 (100ms)
- 규모 B: 1만 명 동시 사용자
- 보안 B: API 키 안전 관리

**제약조건** (Stage 2 Part 1):
- 팀 역량: Python/Node.js, 금융 도메인 학습 필요
- 배포 환경: 크로스 플랫폼 (Linux/Docker)
- 비용: 월 $100 이하

**조사 결과** (6개 증권사 비교):

| 증권사 | API 방식 | Rate Limit | OS 제약 | 개인 사용 | 비용 |
|--------|----------|-----------|---------|----------|------|
| **한국투자증권** | REST + WebSocket | 20건/초 | ✅ 크로스 | ✅ 가능 | 무료 |
| 키움증권 | COM/DLL | 5건/초 | ❌ Windows | ✅ 가능 | 무료 |
| 이베스트 | REST + WebSocket | 10건/초 | ✅ 크로스 | ✅ 가능 | 무료 |
| 대신증권 | COM/DLL | ? | ❌ Windows | ⚠️ 보안 이슈 | 무료 |
| NH투자증권 | QV API (C++) | ? | ⚠️ C++ | ✅ 가능 | ? |
| 삼성증권 | - | - | - | ❌ 불가 | - |

---

##### Decision

**한국투자증권 REST API + WebSocket 사용**

**선택 이유**:
1. ✅ **최고 성능**: 20건/초 (키움 5건, 이베스트 10건)
2. ✅ **크로스 플랫폼**: REST API (Docker 배포 가능)
3. ✅ **실시간 지원**: WebSocket 41개 동시 구독
4. ✅ **팀 역량**: Python FastAPI로 구현 가능 (COM/DLL, C++ 불필요)
5. ✅ **무료**: API 사용료 없음

**대안 검토**:
- ❌ **키움증권**: 5건/초는 NFR 최신성 A 달성 불가
- ❌ **NH투자증권**: C++ SDK는 팀 역량 초과
- ⚠️ **이베스트**: 10건/초는 가능하나 한투 20건/초가 더 여유

---

##### Consequences

**✅ Easier (긍정적 영향)**:
- 크로스 플랫폼 배포 (Linux, Docker, AWS)
- Python 생태계 활용 (FastAPI, Pydantic, pytest)
- 20건/초로 여유있는 Rate Limit
- WebSocket 41개로 핵심 종목 실시간 감시
- 팀 학습 곡선 낮음 (REST API는 익숙)

**❌ Harder (부정적 영향)**:
- 한국투자증권 API 종속성 (변경 시 마이그레이션 필요)
- 모의투자: 2건/초 제한 (실전 대비 10배 낮음)
- WebSocket 41개 제한 (100개 종목 감시 불가)

**⚠️ Risks (위험)**:
- API 정책 변경 가능성 (Rate Limit 축소, 유료화)
- 서비스 중단 위험 (대안: 이베스트 준비)

---

##### Compliance

**검증 방법**:
1. **Automated**: 환경 변수 검증
   ```python
   # .env 파일 필수 항목
   KIS_APP_KEY=required
   KIS_APP_SECRET=required
   KIS_ACCOUNT=required

   # 시작 시 검증
   if not all([KIS_APP_KEY, KIS_APP_SECRET]):
       raise ValueError("한국투자증권 API 키 필수")
   ```

2. **Automated**: Rate Limit 준수 검증
   ```python
   # Redis로 Rate Limiting
   @rate_limit(max_requests=20, window=1)
   def call_kis_api():
       ...

   # 테스트
   def test_rate_limit_compliance():
       # 21번째 요청은 차단되어야 함
       assert call_kis_api() == "Rate limit exceeded"
   ```

3. **Manual**: 분기별 API 정책 모니터링
   - 한국투자증권 공지사항 확인
   - Rate Limit 변경 시 대응 계획 수립

---

##### Notes

**참고 자료**:
- API 문서: https://apiportal.koreainvestment.com/
- 조사 문서: `docs/session-summaries/20251112_Layer3_외부제약조사.md`
- Migration Plan: 이베스트로 전환 시 2주 예상

**팀 공유**:
- API 키 발급 방법: Week 1 온보딩
- WebSocket 연결 방법: `examples/kis_websocket.py`

---

#### ADR-003: WebSocket + Polling 하이브리드 아키텍처

**Status**: Accepted
**Date**: 2025-11-12
**Type**: Conflict Resolution (충돌 해결)

---

##### Context

**NFR 목표** (Stage 1 Layer 2):
- 정확성 A: 조건 감지 100% 정확 (놓치면 금전 손실)
- 최신성 A: 실시간 감지 (초 단위)

**외부 제약** (Stage 2 Part 1):
- API Rate Limit: 20건/초 (실전), 2건/초 (모의)
- WebSocket: 41개 동시 구독 제한

**충돌 발견** (Stage 2 Part 2):
```
목표: 100개 종목을 실시간(1초) 100% 정확히 감시
제약: WebSocket 41개만 가능
충돌: 100개 > 41개 → 불가능!
```

**기술 옵션 비교** (Stage 2 Part 3):

| 옵션 | 정확성 | 즉시성 | API 제한 | 복잡도 | NFR 달성 |
|------|--------|--------|----------|--------|----------|
| **Option 1: Polling만** | C (70%) | C (5초) | ❌ 초과 | A (단순) | ❌ 미달 |
| **Option 2: 하이브리드** | A (95%) | A (100ms) | ✅ 준수 | B (중간) | ✅ 달성 |
| **Option 3: Event-Driven** | A (100%) | A (50ms) | ✅ 준수 | C (복잡) | ⚠️ 과도 |

---

##### Decision

**WebSocket + Polling 하이브리드 아키텍처 사용**

**핵심 전략**:
1. **우선순위 Top 41개**: WebSocket 실시간 감시 (100ms)
2. **나머지 종목**: Polling 5초 주기 (API 20건/초 준수)
3. **동적 우선순위 조정**:
   - 조건 임박 (목표가 ±5% 이내) → WebSocket 승격
   - 조건 멀어짐 → Polling 강등

**아키텍처**:
```
Condition Manager
    ↓
Priority Calculator (실시간 우선순위 계산)
    ↓
┌─────────────┬─────────────┐
WebSocket (41) Polling (나머지)
    ↓              ↓
한국투자증권 API (20건/초)
    ↓
Redis Queue + PostgreSQL
```

---

##### Consequences

**✅ Easier**:
- NFR 정확성 A 달성: 중요 종목 100% 실시간 감시
- NFR 최신성 A 달성: WebSocket 100ms 레이턴시
- API 제한 준수: Redis Queue로 20건/초 보장
- 확장 가능: 우선순위 알고리즘 개선으로 성능 향상

**❌ Harder**:
- 복잡도 증가: WebSocket + Polling 동시 관리
- 우선순위 알고리즘 구현 필요
- Redis 인프라 추가 필요
- 디버깅 어려움 (2개 경로)

**⚠️ Risks**:
- 우선순위 계산 오류 → 중요 종목 Polling 강등
- WebSocket 연결 끊김 → 실시간 감시 중단
- Redis 장애 → 전체 시스템 영향

---

##### Compliance

**검증 방법**:
1. **Automated**: WebSocket 구독 수 제한
   ```python
   MAX_WEBSOCKET_SUBSCRIPTIONS = 41

   def subscribe_stock(stock_code):
       current = redis.zcard("websocket:subscriptions")
       if current >= MAX_WEBSOCKET_SUBSCRIPTIONS:
           raise ValueError(f"WebSocket 제한 초과: {current}/41")

   # 테스트
   def test_websocket_limit():
       for i in range(42):
           if i < 41:
               assert subscribe_stock(f"stock_{i}") == True
           else:
               with pytest.raises(ValueError):
                   subscribe_stock(f"stock_{i}")
   ```

2. **Automated**: Rate Limit 준수
   ```python
   @rate_limit(max_requests=20, window=1)
   def call_api():
       ...

   # Polling Worker 테스트
   def test_polling_rate_limit():
       # 100개 요청 → 5초 소요 (20건/초)
       start = time.time()
       for i in range(100):
           call_api()
       duration = time.time() - start
       assert duration >= 5.0
   ```

3. **Manual**: 우선순위 알고리즘 검증
   - 시뮬레이션으로 우선순위 변화 확인
   - 조건 임박 시 WebSocket 승격 검증

---

##### Notes

**우선순위 알고리즘** (ADR-004 참고):
```python
priority = (
    100 - abs(current_price - target_price) / target_price * 100
) * quantity_weight

# 예시:
# 목표 70,000원, 현재 69,900원 → priority = 99.86
# 목표 70,000원, 현재 65,000원 → priority = 92.86
```

**대안 고려**:
- 나중에 API 유료 플랜 (Rate Limit ↑)으로 업그레이드 시 Polling 비중 축소 가능

---

#### ADR-006: FastAPI (Python) 백엔드 선택

**Status**: Accepted
**Date**: 2025-11-12
**Type**: Technology Stack (기술 스택)

---

##### Context

백엔드 프레임워크가 필요합니다.

**요구사항**:
- 비동기 지원: WebSocket 처리 필요
- 빠른 개발: MVP 3개월
- 타입 안정성: 금융 시스템 = 오류 0
- API 문서 자동화: Frontend 팀과 협업

**팀 역량**:
- 백엔드: 1-2명 (Python 가능, Node.js 가능)
- 금융 도메인: 학습 필요

**기술 옵션 비교**:

| 프레임워크 | 언어 | 비동기 | 타입 | 개발 속도 | 팀 역량 |
|-----------|------|--------|------|----------|---------|
| **FastAPI** | Python | ✅ async/await | ✅ Pydantic | ⭐⭐⭐⭐⭐ | ✅ 가능 |
| NestJS | TypeScript | ✅ async/await | ✅ 내장 | ⭐⭐⭐⭐ | ✅ 가능 |
| Django | Python | ⚠️ Channels | ❌ 수동 | ⭐⭐⭐ | ✅ 가능 |
| Express | JavaScript | ✅ Promise | ❌ 없음 | ⭐⭐⭐⭐⭐ | ✅ 가능 |

---

##### Decision

**FastAPI (Python) 사용**

**선택 이유**:
1. ✅ **비동기 WebSocket**: 네이티브 지원 (async/await)
2. ✅ **타입 안정성**: Pydantic으로 자동 검증
3. ✅ **빠른 개발**: 자동 API 문서 (OpenAPI)
4. ✅ **팀 역량**: Python 경험 있음
5. ✅ **생태계**: pytest, structlog, mypy 연동

**코드 예시**:
```python
from fastapi import FastAPI, WebSocket
from pydantic import BaseModel

app = FastAPI()

class Condition(BaseModel):
    stock_code: str
    target_price: float
    quantity: int

@app.post("/api/v1/conditions")
async def create_condition(condition: Condition):
    # Pydantic이 자동 검증
    return {"id": "uuid", "status": "active"}

@app.websocket("/ws/prices")
async def websocket_prices(websocket: WebSocket):
    await websocket.accept()
    # 실시간 호가 스트리밍
```

**대안 검토**:
- ❌ **Django**: WebSocket 지원 약함 (Channels 복잡)
- ⚠️ **NestJS**: 좋지만 Python 생태계 선호 (증권사 예제 대부분 Python)
- ❌ **Express**: 타입 안정성 부족 (금융 시스템 부적합)

---

##### Consequences

**✅ Easier**:
- 자동 API 문서 (/docs 엔드포인트)
- Pydantic 타입 검증 (런타임 오류 방지)
- async/await로 고성능 WebSocket
- Python 생태계 활용 (pandas, numpy)
- 테스트 용이 (pytest)

**❌ Harder**:
- Python GIL (CPU 바운드 작업 제한)
- 타입 힌트 학습 필요
- 배포 복잡도 (vs Node.js single binary)

**⚠️ Risks**:
- FastAPI 0.x 버전 (breaking changes 가능)
- Python 3.12+ 필수 (호환성 이슈)

---

##### Compliance

**검증 방법**:
1. **Automated**: Python 버전 검증
   ```python
   import sys
   assert sys.version_info >= (3, 12), "Python 3.12+ 필수"
   ```

2. **Automated**: Pydantic 타입 검증
   ```python
   # 모든 API 모델은 BaseModel 상속 필수
   from pydantic import BaseModel

   class APIModel(BaseModel):
       ...

   # mypy로 타입 체크
   mypy src/ --strict
   ```

3. **Automated**: API 문서 생성 확인
   ```bash
   # /docs 엔드포인트 응답 확인
   curl http://localhost:8000/docs
   assert response.status_code == 200
   ```

---

##### Notes

**성능 고려사항**:
- WebSocket 1,000 동시 연결 지원 (uvicorn 기준)
- API 응답 시간: 평균 50ms (목표)

**마이그레이션 계획**:
- 나중에 규모 증가 시 NestJS 고려 가능 (Microservices)

---

### 🎯 Stage 3 완료 요약

**작성된 ADR**:
- ✅ 전체 목록: 18개 정리
- ✅ 예시 작성: 3개 (외부 제약, 충돌 해결, 기술 스택)

**핵심 인사이트**:
> "모든 결정에는 이유가 있다. 그 이유를 기록하는 것이 ADR이다."

**다음 단계**:
- Stage 4: Blueprint 작성 (ADR 기반)
- Stage 5: 작업 분해
- Stage 6: 체크리스트

---

## 📊 현재 검증 상태

| 항목 | 상태 | 비고 |
|------|------|------|
| Phase 1: 이론 매핑 | ✅ 완료 | SEI, Fowler, CAP 검증 완료 |
| 사례 1: 문서 생성 | ✅ 완료 | 패밀리 1 (A-A-A) |
| 사례 2: AI 메모리 | ✅ 완료 | 패밀리 2 (C-B-B), 충돌 해결 |
| 사례 3: 채팅 앱 | ✅ 완료 | 패밀리 3 (B-C-A) |
| **사례 4: 주식 거래** | 🔄 진행 중 | **패밀리 A-C-A** (새 패턴!) |
| **Stage 1** | ✅ 완료 | 아키텍처 패밀리 결정 |
| **Stage 2** | ✅ 완료 | 환경 제약 + 구현 결정 |
| **Stage 3** | ✅ 완료 | ADR 18개 목록 + 3개 예시 |
| **Stage 4** | ⏸️ 대기 | Blueprint 작성 |

---

## 🚀 현재 작업 진행 상황

### ✅ Stage 1 완료 (아키텍처 패밀리 결정)
1. **Part 0: 핵심 기능 구분 명확화**
   - ❌ 수동/자동 = 2개 기능 → ✅ 거래 = 1개 기능
   - 문서: `20251112_핵심기능_판단기준.md`

2. **Part 1-2: Layer 1-2 분석 완료**
   - Layer 1: A-C-A (새 패밀리 패턴!)
   - Layer 2: A-B-B-A

### ✅ Stage 2 완료 (환경 제약 및 구현 결정)

3. **Part 1: Layer 3 외부 제약 조사**
   - 증권사 API 비교 (6개)
   - 금융 규제 조사
   - 한국투자증권 선택
   - 문서: `20251112_Layer3_외부제약조사.md`

4. **Part 2: 충돌 패턴 발견** ⭐
   - 충돌 #1: 정확성 A vs API 20건/초
   - 충돌 #2: 즉시성 A vs WebSocket 41개
   - 충돌 #3: 모의투자 vs 실전투자 성능 차이

5. **Part 3: 구현방법 결정 (5단계)** ⭐
   - 1️⃣ 기능 분해: F1~F5 정의
   - 2️⃣ 속성 질문: NFR 구체화 (성능, 품질, 규모, 보안, 환경)
   - 3️⃣ 제약조건: 외부 (API) + 내부 (팀, 비용, 일정)
   - 4️⃣ 기술 옵션: 3개 비교 → WebSocket + Polling 하이브리드 선택
   - 5️⃣ 통합 설계: 아키텍처, Schema v1.0, API v1.0

### ✅ Stage 3 완료 (ADR 작성)

6. **ADR 목록 작성 (18개)** ⭐
   - 외부 제약: 2개 (증권사 API, REST 선택)
   - 충돌 해결: 3개 (하이브리드, 우선순위, Rate Limit)
   - 기술 스택: 5개 (FastAPI, PostgreSQL, Redis, Next.js, Docker)
   - 데이터 설계: 4개 (UUID, JSONB, 인덱스, Redis 구조)
   - API 설계: 2개 (버전 관리, 에러 형식)
   - 품질/보안: 2개 (멱등성, 토큰 갱신)

7. **ADR 예시 작성 (3개)** ⭐
   - ADR-001: 한국투자증권 API 선택 (외부 제약)
   - ADR-003: WebSocket + Polling 하이브리드 (충돌 해결)
   - ADR-006: FastAPI 선택 (기술 스택)

**핵심 발견**:
> "제약에 의한 결정도 ADR이다!"
> 선택지가 1개여도 "왜 이것밖에 없었는지" 기록해야 함

### ⏸️ Stage 4 대기 (Blueprint 작성)
8. **Blueprint 작성**
   - ADR 기반 상세 설계 문서

### ⏸️ 기타 작업
9. **02-1_IMPLEMENTATION_CASES.md**에 사례 4 추가
   - Case 4: 주식 거래 플랫폼 (A-C-A)

10. **A-C-A 패밀리** 이론적 검증 (Fowler Pattern 매핑)

---

**작성**: 2호 (Claude Code)
**검토**: Jason
**상태**: Stage 3 완료! (ADR 18개 목록 + 3개 예시)
**핵심**: 모든 "왜?"에 대한 답 = ADR (제약에 의한 결정도 ADR!)
