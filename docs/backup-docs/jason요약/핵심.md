```python
[전체 방법론 흐름]
아키텍처 결정 → ADR 작성 → 청사진 (초상세)
  ↑
Jason + 1호/2호 대화 (에이전트 불가능)
  ↓
----------------------------------← SPARK
시작 가능 지점
작업분해 문서 → 체크리스트 → 실제 구현
  ↑
SPARK 에이전트 활용 가능

핵심 인사이트:
- ❌ SPARK로 청사진 만들기 = 불가능 (수많은 대화, 결정, 맥락 필요)
- ✅ SPARK로 작업분해 = 가능 (청사진이 이미 있으니)
- ✅ SPARK로 체크리스트 = 가능 (템플릿 기반)
- ✅ SPARK로 구현 = 가능 (체크리스트 기반)

---

[방법론 핵심]
Jason의 방법론 = "3단계 정보 제공 + 시스템 강제화"

1단계: 청사진 (초상세 계획)
 ↓
2단계: 작업분해 (레고블럭 단위)
 ↓
3단계: 체크리스트 (정확한 지시)
 ↓
시스템: 환경 강제화
 ├─ Pre-task validation (시작 전 차단)
 ├─ Real-time check (작업 중 차단)
 ├─ Quality gates (완료 후 차단)
 └─ Pre-commit hooks (Git 차단)

핵심:
- 정보는 필요한 만큼만 (전체 5000줄 X, 필요한 30줄만 O)
- 규칙은 지침이 아닌 시스템으로 강제

---

핵심 깨달음

"완성된 레고블럭" ≠ "전체 시스템 완성"

인증 시스템 예시로 다시 이해

❌ 제가 잘못 생각한 것

"인증 시스템 전체를 한 Task로?"
→ 불가능함 (200K 컨텍스트 초과)
→ 그럼 무조건 나쁜 Task?

✅ 실제로는

Case 1: 모듈화 분할
Task 1: "JWT 토큰 생성 모듈"

- create_token(user_id) → JWT 생성
- 완전히 작동
- 단독 테스트 가능
- 레고블럭 ✓

Task 2: "JWT 토큰 검증 모듈"

- validate_token(token) → 검증
- 완전히 작동
- 단독 테스트 가능
- 레고블럭 ✓

Task 3: "Login 엔드포인트"

- Task 1, 2를 조립
- /auth/login 완성
- 레고블럭 ✓

Case 2: 단계별 구현 (일관성 + 누락없음)
Task 1: "Login 기능만 (완전 구현)"

- login() 완전 작동 ✓
- 토큰 생성 ✓
- 로깅 ✓
- 테스트 완료 ✓
- logout, refresh는 미구현이지만 OK!
→ "Login 레고블럭" 완성

Task 2: "Logout 기능 (완전 구현)"

- logout() 완전 작동 ✓
- 토큰 무효화 ✓
- 로깅 ✓
- 테스트 완료 ✓
- Task 1과 일관된 패턴 ✓
→ "Logout 레고블럭" 완성

Task 3: "Token Refresh (완전 구현)"

- refresh_token() 완전 작동 ✓
- Task 1, 2와 일관된 패턴 ✓
→ "Refresh 레고블럭" 완성

---

핵심 원칙 2가지

1️⃣ 일관성 (Consistency)

# ✅ 일관된 패턴

Task 1: Login

- structlog로 로깅
- Pydantic으로 검증
- FastAPI 엔드포인트
- pytest로 테스트

Task 2: Logout

- structlog로 로깅 (같은 방식!)
- Pydantic으로 검증 (같은 방식!)
- FastAPI 엔드포인트 (같은 방식!)
- pytest로 테스트 (같은 방식!)

→ 같은 스타일, 같은 도구, 같은 구조

2️⃣ 누락없음 (Completeness)

# ✅ 계획된 순서대로 빠짐없이

청사진:
├── Task 1: Login ✓
├── Task 2: Logout ✓
├── Task 3: Refresh ✓
└── Task 4: Password Reset ✓

→ 청사진에 있는 모든 Task 완료
→ 하나도 빠뜨리지 않음

# ❌ 누락 발생

청사진:
├── Task 1: Login ✓
├── Task 2: Logout ✓
├── Task 3: Refresh ❌ (건너뜀)
└── Task 4: Password Reset ✓

→ Refresh가 누락됨
→ 나중에 발견하면 혼란

---

실전 판단 기준

Task를 나눌 때 질문

Q1: 200K 컨텍스트로 가능한가?

- YES → 한 Task로 진행 가능
- NO → 모듈화 또는 단계별 분할

Q2: 이 Task만으로 의미있는 기능인가?

- YES → 레고블럭 ✓
- NO → Task 크기 재조정 필요

Q3: 다른 Task와 일관성이 있나?

- 같은 도구 사용?
- 같은 패턴 사용?
- 같은 구조 사용?

Q4: 청사진에서 누락된 Task는 없나?

- 모든 Task가 계획대로 진행되는가?
- 건너뛴 Task는 없는가?

---

예시: 인증 시스템을 어떻게 Task로 나누나

청사진 (전체 계획)

인증 시스템 (Auth System)
├── 1. JWT 토큰 관리
│   ├── Task 1.1: 토큰 생성 모듈
│   └── Task 1.2: 토큰 검증 모듈
├── 2. 인증 엔드포인트
│   ├── Task 2.1: Login 엔드포인트
│   ├── Task 2.2: Logout 엔드포인트
│   └── Task 2.3: Refresh 엔드포인트
└── 3. 보안 기능
  ├── Task 3.1: Rate Limiting (5회 실패 잠금)
  └── Task 3.2: Password Hashing

작업 순서 (누락없이, 일관성 유지)

# Task 1.1 완료

def create_token(user_id: str) -> str:
  # Pydantic 검증 ✓
  # structlog 로깅 ✓
  # pytest 테스트 ✓
  # 완전 작동 ✓

# Task 1.2 완료 (일관된 패턴!)

def validate_token(token: str) -> bool:
  # Pydantic 검증 ✓ (1.1과 같은 방식)
  # structlog 로깅 ✓ (1.1과 같은 방식)
  # pytest 테스트 ✓ (1.1과 같은 방식)
  # 완전 작동 ✓

# Task 2.1 완료 (Task 1.1, 1.2 조립)

@app.post("/auth/login")
def login(...):
  token = create_token(user_id)  # 1.1 사용
  # FastAPI ✓
  # 완전 작동 ✓

# ... 계속 이어짐 (누락 없이)

---

정리

Task (단위작업) = 레고블럭

레고블럭의 조건

1. ✅ 완성: TODO 없음, 완전 작동
2. ✅ 독립: 단독 테스트 가능
3. ✅ 일관성: 다른 Task와 같은 패턴/도구/구조
4. ✅ 조립 가능: 명확한 인터페이스

전체 시스템 완성 조건

1. ✅ 누락없음: 청사진의 모든 Task 완료
2. ✅ 일관성 유지: 모든 Task가 같은 스타일
3. ✅ 조립 검증: 레고블럭들이 잘 조립되는가

핵심:

- 작은 완성된 블럭들을 만들되
- 일관된 방식으로 만들고
- 하나도 빠뜨리지 않으면
- 전체가 완성됨!

---

이제야 이해한 전체 구조

청사진 (Blueprint) = 완전한 건축 설계도

왜 초상세해야 하나?
→ 모든 레고블럭의 목록이 여기 있어야 하니까!

인증 시스템 청사진 (5000줄):
├── 1. JWT 토큰 관리
│   ├── 1.1 토큰 생성
│   │   ├── 알고리즘: HS256
│   │   ├── Payload: {user_id, exp, iat}
│   │   ├── Secret: 환경변수에서 로드
│   │   ├── TTL: 1시간
│   │   └── 에러 처리: InvalidUserError
│   └── 1.2 토큰 검증
│       ├── 서명 검증
│       ├── 만료 시간 체크
│       ├── Payload 파싱
│       └── 에러 처리: TokenExpiredError
├── 2. 인증 엔드포인트
│   ├── 2.1 Login
│   │   ├── Endpoint: POST /auth/login
│   │   ├── Request: {email: str, password:str}
│   │   ├── Response: {access_token,refresh_token, expires_in}
│   │   ├── 성공: 200 + 토큰
│   │   ├── 실패: 401 + 에러 메시지
│   │   ├── Rate Limit 체크 (Task 3.1 연동)
│   │   └── 로깅: structlog로 모든 시도 기록
... (계속 초상세)

왜 이렇게 상세한가?
→ 모든 레고블럭의 명세서
→ 누락 없이 만들기 위한 완전한 리스트
→ 일관성 있게 만들기 위한 상세 규격

---

작업분해 (Task Breakdown) = 레고블럭 제작
순서

청사진 5000줄 → 작업분해 문서

Task 1.1: 토큰 생성 모듈
📘 청사진 참조:
- Line 145-178: JWT 알고리즘 명세
- Line 179-195: Payload 구조
- Line 196-210: 에러 처리 시나리오

📋 프로젝트 표준:
- Line 12-25: structlog 로깅 방법
- Line 56-71: Pydantic 검증 패턴

🔧 사용 도구:
- PyJWT (표준 JWT 라이브러리)
- Pydantic (TokenPayload 모델)
- structlog (토큰 생성 로깅)

📦 입력: user_id: str
📦 출력: token: str
📦 의존성: 없음 (독립 실행 가능)
🎯 완성 조건:
- [ ] create_token() 함수 작동
- [ ] 올바른 JWT 생성 확인
- [ ] 만료 시간 정확히 설정
- [ ] 단독 테스트 통과

---

Task 1.2: 토큰 검증 모듈
📘 청사진 참조:
- Line 211-245: 검증 로직
- Line 246-268: 에러 케이스

📦 입력: token: str
📦 출력: payload: dict | None
📦 의존성: Task 1.1과 일관된 패턴
🎯 완성 조건:
- [ ] validate_token() 함수 작동
- [ ] 유효한 토큰 → payload 반환
- [ ] 만료된 토큰 → TokenExpiredError
- [ ] Task 1.1과 일관성 확인
- [ ] 단독 테스트 통과

---

Task 2.1: Login 엔드포인트
📘 청사진 참조:
- Line 345-412: Login API 명세
- Line 413-448: 성공/실패 시나리오

📦 입력: LoginRequest (email, password)
📦 출력: LoginResponse (tokens)
📦 의존성: Task 1.1 (토큰 생성), Task 3.2
(패스워드 검증)
🔗 조립: Task 1.1 + Task 3.2를 조합
🎯 완성 조건:
- [ ] POST /auth/login 작동
- [ ] Task 1.1의 create_token() 사용
- [ ] Task 3.2의 verify_password() 사용
- [ ] 일관된 structlog 패턴
- [ ] 통합 테스트 통과

---

작업분해가 필수인 이유!

1️⃣ 청사진은 너무 크다 (5000줄)

에이전트에게 청사진 전체를 주면?
❌ 200K 컨텍스트 초과
❌ Transformer attention 약화
❌ 어디서 뭘 해야 할지 모름

2️⃣ 작업분해가 레고블럭 제작 지침서

Task 1.1에만 집중:
✅ 청사진 Line 145-210만 읽음 (66줄)
✅ 프로젝트 표준 필요한 부분만 (40줄)
✅ 총 ~100줄 정보로 완성된 블럭 제작
✅ 나머지 4900줄은 신경 안 써도 됨!

3️⃣ 일관성과 누락 방지

작업분해 문서:
├── Task 1.1 ✓
├── Task 1.2 ✓
├── Task 2.1 ✓
├── Task 2.2 ✓
├── Task 2.3 ✓
├── Task 3.1 ✓
└── Task 3.2 ✓

→ 체크리스트처럼 하나씩
→ 누락 없이 완성
→ 모든 Task에 같은 패턴 적용

---

전체 흐름이 이제 명확해요!

[Stage 1-2: Jason + 1호/2호 대화]
아키텍처 결정 → ADR
  ↓
[Stage 3: 청사진 작성] (초상세 5000줄)
모든 레고블럭 명세
├── 인증 시스템
│   ├── JWT 토큰 관리 (Line 100-300)
│   ├── 인증 엔드포인트 (Line 301-600)
│   └── 보안 기능 (Line 601-800)
└── ... 모든 시스템

───────────────────────────────────
↓ SPARK 시작!

[Stage 4: 작업분해] ← SPARK 에이전트 가능!
청사진 5000줄 → Task 목록
├── Task 1.1 (청사진 Line 145-210 참조)
├── Task 1.2 (청사진 Line 211-268 참조)
├── Task 2.1 (청사진 Line 345-448 참조)
└── ... (총 50개 Task)

[Stage 5: 체크리스트] ← SPARK 에이전트
각 Task별 9-Step 체크리스트
├── Task 1.1 체크리스트
│   - [ ] 청사진 Line 145-210 읽기
│   - [ ] create_token() 구현
│   - [ ] 테스트 작성
│   - [ ] ruff/mypy 통과
│   - [ ] 완성!
└── ...

[Stage 6: 구현] ← SPARK 에이전트 강제화
Task 1.1 체크리스트 기반 실행
→ 완성된 레고블럭 하나 완성
→ Task 1.2 체크리스트 기반 실행
→ 완성된 레고블럭 하나 완성
→ ... 반복

[최종 결과]
모든 레고블럭 조립 완료 = 인증 시스템 완성!

---

이제 완전히 이해한 핵심!

왜 청사진이 초상세해야 하나?

→ 모든 레고블럭의 완전한 명세서
→ 누락 방지의 유일한 방법
→ 일관성 유지의 기준

왜 작업분해가 필수인가?

→ 5000줄을 100줄로 압축 (Task별)
→ 에이전트가 집중할 수 있는 크기로 분할
→ 레고블럭 제작 지침서
→ 순서와 의존성 명시

SPARK의 진짜 역할

→ 작업분해를 자동화
→ 체크리스트를 자동 생성
→ 구현을 강제화
→ 레고블럭 조립 공장

---

Jason, 이제 정말 완벽하게 이해했어요!

청사진 없이는 뭘 만들어야 할지 모르고
작업분해 없이는 어떻게 만들어야 할지 모르고
SPARK 없이는 일관성 있게 못 만드는 거네요!

이 세 가지가 완벽하게 연결되는 게 보여요!🚀✨
```

