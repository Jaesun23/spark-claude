# DNA Development Methodology

## AI와 함께하는 소프트웨어 개발의 새로운 패러다임

## 🎯 방법론의 본질

**DNA 방법론은 단 하나의 질문에서 시작되었습니다:**

> "AI의 컨텍스트 제약 하에서 소프트웨어 개발에 성공하려면 어떻게 해야 하는가?"

**그 답은:**

> "AI가 집중할 수 있는 크기로 쪼개는 것이다"

------

## 🚨 AI의 근본적 제약

### 1. Context Rot (Anthropic 공식 연구)

**Anthropic이 발견한 것:**

- Context Rot: 컨텍스트 토큰 수가 증가하면 정보 회상 능력 감소
- n² pairwise relationships: n개 토큰은 n² 개의 관계를 만듦
- Performance gradient: 점진적 성능 저하 (급격한 절벽이 아님)
- 짧은 시퀀스에 더 익숙함 (학습 데이터 분포 특성)

**Jason의 2년 실전 관찰:**

- 작업 초반: 꼼꼼하고 논리정연함
- 작업이 길어질수록: 품질 저하
- 나중에는: 급히 마무리하려는 경향

### 2. 컨텍스트 실제 사용 가능량 추정

**계산:**

```
200K 총 컨텍스트
  ↓
Write 작업: 2배 소모 (생각 + 쓰기)
  ↓
100K 가용 컨텍스트
  ↓
시스템 오버헤드: 약 20K
(시스템 프롬프트, 도구 정의, 명령어 등)
  ↓
80K 실제 작업 공간

Write 기준 환산: 160K 입력 가능
(읽기 80K + 쓰기 80K = 160K)
```

### 3. AI의 7가지 행동 패턴(Jason 관찰)

**법칙 1: 쉬운 길 선택**

- "A 또는 B" 선택지 → 간단하고 쉬워 보이는 것 선택
- "한다 또는 안한다" → 100% "안한다" 선택

**법칙 2: 좋은 말 법칙**

- 지켜야 할 것이 많으면 읽다가 "좋은 말" 정도로 여기고 넘김
- 일부만 기억하고 나머지는 무시

**법칙 3: '필수' 인플레이션**

- '필수' 또는 '절대 금지' 수가 많아지면 취사 선택

**법칙 4: 정보 또는 작업량 과부하**

- 너무 많은 정보가 주어지면 모두 읽지 않고 일부만 읽고 판단해서 행동
- 해야 할 작업이 많으면 처음 한 두개는 하지만 이후 작업은 하지 않으려고 함(숨막힌다는 표현도 함)

**법칙 5: 참조 귀찮음**

- 파일명만 적으면 찾기 싫어서 포기
- 파일경로를 적어도 찾아서 읽기 싫어서 포기
- Inline으로 직접 정확히 제공해야 확실히 읽음

**법칙 6: 컨텍스트 붕괴**

- 모든 걸 한 번에 다 하려고 함
- 처음에는 집중하지만 작업이 길어질수록 품질 저하
- 컨텍스트 윈도우 제한을 인식하면 그 안에서 해결하려고 급히 마무리

**법칙 7: 만능 착각**

- 진심으로 모든 걸 다 할 수 있다고 믿음
- 계획부터 세우라고 해도 별도 지시 없으면 문서로 만들지 않음
- 바로 작업 시작하는 경향

------

## 🏗️ DNA 방법론의 구조

### 두 개의 방향, 두 개의 전략

```
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 전반부: 확장 (아이디어 → 청사진)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

하나의 아이디어
    ↓ 
 확장 (발산)
    ↓
전체의 모든 것을 담은 청사진

방향: 하나 → 전체
전략: 전체 구조를 잃지 않으면서 확장

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 후반부: 쪼개기 (청사진 → 구현)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

청사진 (완전한 전체)
    ↓
 쪼개기 (수렴)
    ↓
작업분해 (Task 단위)
    ↓
체크리스트 (실행 가이드)
    ↓
구현 (레고블럭)

방향: 전체 → 단위
전략: AI가 집중할 수 있는 크기로 분할
```

------

## ✅ 후반부: 확립된 방법론

### 핵심 통찰

> **"완전히 정해져 있어야 쪼개기가 의미 있다"**

- 청사진이 완전하면 → 작업분해 가능 → 구현 성공
- 청사진이 불완전하면 → 작업분해 실패 → 프로젝트 실패

### Stage 4: 청사진 (Blueprint)

**역할:** 전체의 모든 것을 담은 설계도

**포함 내용:**

1. 프로젝트 표준과 ADR을 바탕으로 한 전체 시스템
2. 전체 시스템 구조, 11개 DNA 시스템, 도메인 구조
3. 데이터 구조 및 흐름, API Layer (내부/외부 모두)
4. 각 도메인, 모든 컴포넌트, API, 데이터 설계 가이드
5. 프로젝트의 모든 기능들의 구체적 목록, 입출력, 제약조건, 아키텍처
6. 기능 간 의존성 및 조합 순서

**핵심:** 단 1도 빠짐 없는 모든 것을 담고 있어야 함

**이유:**

- 작업분해 시 누락 방지
- Task 목록 = Blueprint 기능 목록
- 일관성 보장의 기준점

### Stage 5: 작업분해 (Task Breakdown)

**역할:** 청사진을 레고블럭으로 쪼개기

**단위작업 = 레고블럭 정의:**

- 독립적으로 실행 및 테스트 가능
- 의미 있는 기능이 있음
- 명확한 입출력이 있음
- TODO, pass 없이 완전한 코드

**두 가지 완성 조건:**

1. 일관성 (Consistency):
   - 모든 Task가 같은 도구 사용 (DNA 시스템 환경 기반)
   - 모든 Task가 같은 패턴 따름
   - 모든 Task가 같은 표준 준수
2. 누락없음 (No Omissions):
   - Blueprint의 모든 기능이 Task로 분해됨
   - Task 목록 = Blueprint 기능 목록
   - 빠진 Task 없음

**Task 분할 방식:**

Case 1: 모듈화 분할 (수평분할)

- 재사용 가능한 독립 모듈들을 먼저 만들고, 나중에 조립
- 재사용성이 높거나 복잡도가 높은 경우

Case 2: 단계별 구현 (수직구현)

- 전체 기능을 하나씩 단계별로 완성
- 간단한 구조, 빠른 결과 확인

**God Object 회피 원칙:**

- 단일 파일: 500줄 이하 (가독성, 유지보수 기본 원칙)
- Task 크기: 400~800줄 (구현 + 테스트)
- 단위작업 기준 80K 실제 작업 공간 고려

### Stage 6: 체크리스트 (Checklist)

**역할:** Task 하나의 상세 청사진

**TDD 필수 원칙:**

왜 TDD인가 (Jason의 발견):

- 구현 후 테스트: 계획과 다른 구현이 되었더라도 구현이 정답이 됨 → 원래 의도에서 이탈
- 테스트 먼저: 의도가 정답이 됨 → 원래 계획 준수
- AI는 과도한 일반화 경향 → 불필요한 기능 추가
- 테스트가 범위 제한 → 필요한 것만 구현

**체크리스트 구성:**

- 작업분해 단계에서 분해한 Task별 작업 목록
- TDD 기반 9-Step Checklist
- 체크리스트 완성 조건: 실행가능성, 자급자족성, 검증가능성
- 실제 작업을 실행할 2호/Agent를 위한 완전한 정보

**핵심:** 전체 컨텍스트 불필요! 체크리스트만 읽고 구현 가능

### Stage 7: 구현 (Implementation)

**실행 방식:**

- 체크리스트만 읽고 실행
- Project Standards 준수
- 자동화 강제
- 전체 컨텍스트 불필요
- 레고블럭을 하나씩 완성해 나가면 전체가 완성

**Agent 병렬 작업 활용:**

- 2호: Blueprint 관리 + Task 할당
- Agent들: 각자 독립 Task 구현 (병렬)
- 각 Agent가 독립 파일 작업 → Git 충돌 없음
- 자동 통합 가능

**컨텍스트 배분 (Agent 하나당):**

```
80K 실제 작업 공간:
├─ 체크리스트 읽기
├─ DNA 시스템 참조
├─ 관련 인터페이스
├─ 도메인 모델
├─ 구현 공간
└─ 테스트 코드
```

------

## ❓ 전반부: 미해결 과제

### 핵심 문제

**목표:** 하나의 아이디어에서 "모든 것을 담은 청사진"으로 확장

**제약:**

- AI는 Context Rot이 있음
- AI는 만능 착각이 있음 (진심으로 다 할 수 있다고 믿음)
- 한 번에 전체 작성 불가능
- 나눠서 작성해야 함

**딜레마:**

```
나눠서 작성하면 → 전체 구조가 흐려질 위험
한 번에 작성하면 → Context Rot 발생

확장하면서도 → 전체 구조는 유지해야 함
부분에 집중하면서도 → 전체를 봐야 함
```

### 찾아야 할 해답

**Jason의 고민:**

"청사진을 어떻게 나눠서 작성하면 전체 일관성을 유지하면서도 AI Context Rot을 피할 수 있는가?"

**필요한 것:**

- 청사진을 나누는 기준
- 나누는 순서
- 각 부분의 적정 크기
- 부분 간 연결 방법
- 전체 구조 유지 방법

**목표:** 청사진 = 나눠서 작성된 문서들의 합 (일관성 유지, 완전성 보장)

**현재 상태:**

- 후반부는 2년의 실패 경험으로 확립됨
- 전반부는 성공 사례 부족으로 불확실함

------

## 🎯 DNA 방법론의 기반

```
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
Jason의 AI 행동 패턴 7가지 발견
Jason의 작업 분할의 중요성 인식
-> Kent Beck의 TDD 이론 (왜 TDD인가)
-> Anthropic의 Context Rot 연구 (AI의 한계)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
= DNA Development Methodology
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

핵심 답:
"AI가 집중할 수 있는 크기로 쪼개는 것"

확립된 부분 (후반부):
청사진 → 작업분해 → 체크리스트 → 구현

진화 중인 부분 (전반부):
아이디어 → 청사진
(전체 구조 유지하며 확장하는 방법)
```

------

## 📝 마치며

DNA 방법론은 완성된 방법론이 아닙니다.

**확립된 것:**

- 청사진 → 구현의 "쪼개기" 전략
- TDD의 필요성과 이유
- AI 행동 패턴 7가지
- 컨텍스트 제약의 정확한 이해

**진화 중인 것:**

- 아이디어 → 청사진의 "확장" 전략
- 전체 구조를 유지하며 나누는 방법

핵심은 명확합니다:

> **"AI의 제약을 이해하고, 그 제약 안에서 성공하는 방법을 찾는 것"**

