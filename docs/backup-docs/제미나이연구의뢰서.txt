  🔍 Gemini 리서치 의뢰서: 엔터프라이즈 소프트웨어 개발 계획 프로세스

  📋 요청 배경 및 컨텍스트

  1. 우리가 만들고 있는 것

  우리는 **AI 협업 소프트웨어 개발 방법론 (DNA v4.0)**을 개발하고 있습니다. 이 방법론은 단순히 AI를 보조 도구로
  쓰는 것이 아니라, AI를 핵심 개발 파트너로 활용하여 소프트웨어를 구축하는 체계적인 방법론입니다.

  2. 핵심 발견: 컨텍스트 한계 극복이 성공의 열쇠

  수많은 실패 경험을 통해 발견한 사실:
  - AI와의 협업에서 가장 큰 장애물은 컨텍스트 한계
  - AI는 200K 토큰 제한 내에서만 정보를 처리 가능
  - 프로젝트가 커질수록 AI는 전체 맥락을 잃고 혼란스러워짐
  - 결과: 잘못된 구현, 일관성 없는 코드, 반복적인 실수

  해결책 발견:
  - TDD(Test-Driven Development) 방식처럼 작은 단위로 작업
  - AI의 컨텍스트가 온전하게 보전되는 정도의 업무량으로 쪼개기
  - 이 방식으로 작업하면 AI의 효과가 극대화됨

  3. '단위작업'과 체크리스트 방식의 성공

  단위작업 정의:
  - 기능적으로 작동하는 완결된 작업
  - 테스트로 검증 가능한 크기
  - 2-4시간 내에 완료 가능
  - 예: "사용자 로그인 API 엔드포인트 구현 + 테스트"

  발견한 사실:
  - AI에게 이런 '단위작업'을 요청하면 매우 잘 수행함
  - 각 단위작업별로 상세 체크리스트를 제공하면 더욱 완벽함
  - 체크리스트만 있으면 AI가 독립적으로 작업 완수 가능

  우리의 작업 프로세스 (하향식):
  1. Blueprint (청사진) 작성
     ↓ 프로젝트 전체 계획

  2. Task Breakdown (작업 분해) 문서 작성
     ↓ 청사진을 레고 블럭처럼 나누기

  3. Checklist (체크리스트) 작성
     ↓ 각 작업별 상세 실행 매뉴얼

  4. Implementation (실제 구현)
     ↓ AI가 체크리스트 보고 구현

  4. 성공적이지만 불완전했던 이유

  문제점 발견:
  - 위 프로세스는 가장 성공적이었지만 완벽하지는 않음
  - AI가 여전히 실수를 반복하거나 표준을 위반하는 경우 발생

  근본 원인:
  - AI의 "행동 제약"이 사후적(reactive)으로만 작용
  - 예: 코드 작성 → 에러 발견 → 수정 → 또 다른 에러...
  - 이미 작성된 코드를 고치는 것은 비효율적

  깨달음:
  "사후적인 것도 좋지만 작업하면서 제대로 작업하기를 바라는 거에요" - Jason

  해결 방향:
  - 작업의 '환경' 자체를 AI의 행동 제약으로 만들기
  - Pre-commit hooks로 강제하는 것처럼, 사전 제약을 만들기
  - 이런 환경은 프로젝트 초기 계획에서부터 준비되어야 함

  5. 상향식 프로세스: Idea → Blueprint

  문제 인식:
  - 위의 하향식(Blueprint → Implementation)은 성공
  - 하지만 **상향식(Idea → Blueprint)**은 정의되지 않음
  - "아이디어만 있는데 어떻게 Blueprint를 만들지?"

  우리가 설계한 상향식 프로세스:

  Stage 1: 아키텍처 패밀리 결정
  ├─ 핵심 기능 파악 (비즈니스 목적 기준)
  ├─ 3-Layer Decision Tree 질문
  │  ├─ Layer 1: 실패 시 영향? (A=손실, B=허용)
  │  ├─ Layer 2: 데이터 구조? (A=정형, B=비정형, C=스트림)
  │  └─ Layer 3: 응답 시간? (A=<100ms, B=<3s, C=>3s)
  └─ 결과: 7개 패밀리 중 하나 (A-A-A, A-C-A, B-B-B 등)

  Stage 2: 환경 제약 및 구현 방법 결정
  ├─ Part 1: Layer 3 외부 제약 조사
  │  └─ 외부 API, 규제, 클라우드, 비용, 기술 제약
  ├─ Part 2: 충돌 패턴 식별
  │  └─ NFR 간 충돌, 트레이드오프 결정
  └─ Part 3: 6단계 구현 방법 (SEI ADD 기반)
     ├─ 1단계: 기능 요구사항 확인
     ├─ 2단계: NFR 속성 질문
     ├─ 3단계: 제약 통합
     ├─ 4단계: 기술 스택 선택
     ├─ 5단계: 아키텍처 설계 (도메인 기술)
     └─ 6단계: DNA 시스템 11개 구성

  Stage 3: ADR 작성 (현재 단계!)
  ├─ Stage 2 결과를 ADR 문서로 작성
  └─ 5개 카테고리, 총 22-29개 ADR
     ├─ 외부 제약 ADR (3-5개): ADR-101~105
     ├─ 충돌 해결 ADR (2-3개): ADR-201~203
     ├─ 기술 스택 ADR (4-6개): ADR-301~306
     ├─ 도메인 기술 ADR (2-4개): ADR-401~404
     └─ DNA 시스템 ADR (11개): ADR-001~011

  Stage 4-6: Blueprint → Task → Checklist (목표!)
  └─ 여기가 우리가 막힌 부분!

  6. ADR 5개 카테고리 상세

  1️⃣ 외부 제약 ADR (어쩔 수 없는 선택)
  - 외부 API/서비스 선택 (예: 한국투자증권 API)
  - 클라우드 제공자 (예: AWS Seoul Region)
  - 규제/컴플라이언스 (예: 금융위원회 전자금융거래법)

  2️⃣ 충돌 해결 ADR (어쩔 수 없는 타협)
  - NFR 간 충돌과 트레이드오프 결정
  - 예: "성능 vs 일관성" → 하이브리드 아키텍처 선택

  3️⃣ 기술 스택 ADR (최선의 선택)
  - 패밀리 권장 + 제약으로 필터링된 기술
  - 예: Python, FastAPI, PostgreSQL, Redis

  4️⃣ 도메인 기술 ADR (문제 해결 필수)
  - 아이디어 현실화를 위해 구상한 시스템/컴포넌트
  - 예: Priority Queue Scheduler, Dynamic Subscription Manager

  5️⃣ DNA 시스템 ADR (자동 결정, 11개 필수)
  - 모든 소프트웨어에 필요한 공통 시스템
  - 로깅, 에러 핸들링, 설정 관리, DB 연결, 인증/인가, 캐싱, 비동기 처리, API 설계, 테스트, 배포, 모니터링
  - 패밀리 특성 + 규모/예산으로 대부분 자동 결정

  핵심 통찰:
  "어쩔 수 없는 것부터 식별하고 분류한 후에 우리가 정할 수 있는 것들은 최선으로 선택을 하는 거에요. 그런데 잘
  생각해보면 대부분은 꼬리에 꼬리를 물면서 결정이 되어 버린답니다." - Jason

  ---
  ❓ 리서치 요청 사항

  핵심 질문

  우리가 막힌 부분:
  Stage 3 (ADR 22-29개 작성 완료)
    ↓
    ??? (이 gap을 어떻게 채울 것인가?)
    ↓
  Stage 4 (Blueprint: 프로젝트 전체 청사진 작성)

  (원래 방법론에는 DNA 11개 시스템 구축 및 Project Standards 작성이 있으나 미싱링크는 ADR ➟ Blueprint이기 때문에 중간단계를 생략함)

  구체적으로 알고 싶은 것:

  1. 엔터프라이즈에서 ADR → Implementation 프로세스

  질문:
  - 대기업/엔터프라이즈 소프트웨어 개발에서 Architecture Decision Records 작성 후, 실제 구현까지 어떤 문서들을
  거치나요?
  - 문서 계층 구조가 있나요? (예: ADR → Architecture Document → Design Specification → Implementation Guide)
  - 각 문서의 목적과 포함 내용은?
  - 각 문서 간 정보 전달 방식은? (어떻게 상위 문서를 참조하여 하위 문서를 작성하나요?)

  우리가 특히 알고 싶은 것:
  - ADR에 "FastAPI 사용 결정"만 적혀 있다면, 다음 단계 문서에서는 무엇을 작성하나요?
  - 구현자가 "아, 이렇게 구현하면 되겠구나!"라고 알 수 있으려면 어떤 정보가 필요한가요?

  2. ADR의 내용과 형식

  질문:
  - 엔터프라이즈에서 사용하는 ADR의 표준 템플릿은?
  - ADR에 일반적으로 포함되는 섹션들은? (Status, Context, Decision, Consequences 외에?)
  - **"Implementation Guidance"**나 "Design Constraints" 같은 섹션을 ADR에 포함하나요?
  - ADR에서 "결정"과 "설계"의 경계는 어디인가요?

  우리의 고민:
  - ADR-001 "로깅 전략: structlog 사용"이라고 결정했을 때
  - Blueprint에서는 "어느 디렉토리에 logger.py를 만들고, 어떤 포맷으로 로그를 남기고..." 같은 구체적 내용이 필요함
  - 이런 구체적 내용을 ADR에 담아야 하나요? 아니면 중간 문서에?

  3. SEI ADD 방법론과 ADR의 관계

  질문:
  - SEI의 Attribute-Driven Design (ADD) 방법론에서 ADR은 어디에 위치하나요?
  - ADD의 결과물(architecture design)과 ADR의 차이는?
  - ADD에서 "architectural tactics" → "architectural patterns" → "detailed design"으로 가는 프로세스가 있는데, 이게
   우리의 ADR → Blueprint와 어떻게 매핑되나요?

  4. AI Agent를 위한 ADR → Blueprint 연결

  우리의 특수한 상황:
  - 사람은 ADR을 읽고 암묵적 지식/경험으로 Blueprint를 작성
  - AI Agent는 명시적으로 작성된 정보만 사용 가능
  - AI Agent에게 "컨텍스트 온전하게 보전"되는 정보를 제공해야 함

  질문:
  - ADR에 어떤 형식/내용을 추가하면 AI가 Blueprint를 자동 생성할 수 있을까요?
  - 또는 ADR과 Blueprint 사이에 중간 문서가 필요할까요?
  - 엔터프라이즈에서 "주니어 개발자"나 "새로운 팀원"에게 ADR → Implementation을 설명할 때 어떤 추가 문서를
  제공하나요?

  5. Blueprint의 정의와 내용

  질문:
  - 엔터프라이즈에서 "전체 시스템 설계서" 또는 "구현 청사진"이라고 부르는 문서의 정식 명칭은?
  - 그 문서에는 무엇이 포함되나요?
    - 디렉토리 구조?
    - 모듈 간 관계?
    - API 엔드포인트 목록?
    - 데이터베이스 스키마?
    - 클래스 다이어그램?
  - 얼마나 상세해야 하나요? (코드 수준? 의사코드 수준?)

  6. 실전 사례

  가능하다면:
  - 실제 엔터프라이즈 프로젝트에서 ADR → 구현까지의 문서 예시
  - 오픈소스 프로젝트 중 이런 프로세스를 잘 따르는 사례
  - Microsoft, Google, Amazon 같은 큰 회사의 공개된 프로세스 문서

  ---
  📌 추가 컨텍스트

  우리의 제약 조건

  1. AI 컨텍스트 한계: 200K 토큰 내에서 모든 정보를 제공해야 함
  2. 명시적 정보만: AI는 암묵적 지식이나 경험이 없음
  3. 독립 실행 가능: 각 체크리스트는 그것만 보고 작업 가능해야 함

  우리가 이미 가진 것

  - 7개 아키텍처 패밀리: 시스템 유형별 분류 (A-A-A, A-C-A, B-B-B, B-C-A, B-A-C, A-A-B, A-B-A)
  - SEI ADD 기반 5단계: Function → Attribute → Constraint → Technology → Architecture
  - DNA 시스템 11개: 모든 프로젝트 공통 시스템
  - ADR 5개 카테고리: 외부/충돌/기술/도메인/DNA

  참고 문서

  우리가 이미 조사한 자료들:
  - SEI Attribute-Driven Design 3.0
  - ADR 관련 논문 및 best practices
  - Martin Fowler의 아키텍처 문서화 글

  ---
  🎯 리서치 결과로 기대하는 것

  이상적인 답변:

  1. 엔터프라이즈에서 사용하는 표준 프로세스와 문서 체계
  2. ADR 템플릿에 어떤 섹션을 추가해야 Blueprint 작성에 충분한지
  3. ADR과 Blueprint 사이에 중간 문서가 필요한지, 필요하다면 그 형식은?
  4. 실제 사례와 템플릿 (가능하다면)
  5. AI가 ADR을 읽고 Blueprint를 생성하기 위해 최소한으로 필요한 정보 목록

  최종 목표:
  AI Agent가:
  1. Stage 2 결과 (ADR 작성 목록) 읽기
  2. Stage 3에서 ADR 22-29개 작성
  3. 이 ADR들을 읽고
  4. Stage 4에서 완전한 Blueprint 자동 생성
  5. 사람의 추가 해석이나 판단 없이!