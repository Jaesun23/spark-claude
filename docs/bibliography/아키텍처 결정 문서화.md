# 아키텍처 결정 문서화

[Michael Nygard](https://cognitect.com/authors/MichaelNygard.html) - 2011년 11월 15일

[민첩성](https://cognitect.com/blog/tags?tag=agility) [아키텍처](https://cognitect.com/blog/tags?tag=architecture)

## 맥락

애자일 프로젝트의 아키텍처는 다르게 기술되고 정의되어야 합니다. 모든 결정이 한 번에 내려지지도 않고, 프로젝트가 시작될 때 모든 것이 완료되지도 않습니다.

애자일 방법론은 문서화에 반대하는 것이 아니라, 가치 없는 문서화에만 반대합니다. 팀 자체에 도움이 되는 문서는 가치가 있을 수 있지만, 최신 상태로 유지되는 경우에만 그렇습니다. 큰 문서는 절대 최신 상태로 유지되지 않습니다. 작고 모듈화된 문서는 적어도 업데이트될 가능성이 있습니다.

아무도 큰 문서를 읽지 않습니다. 대부분의 개발자들은 명세 문서가 전체 소스 코드 크기보다 더 큰(바이트 단위로) 프로젝트를 적어도 한 번은 경험해봤을 것입니다. 그런 문서들은 열기도, 읽기도, 업데이트하기도 너무 큽니다. 한 입 크기의 작은 조각들이 모든 이해관계자들이 소화하기에 더 쉽습니다.

프로젝트 진행 과정에서 추적하기 가장 어려운 것 중 하나는 특정 결정들 뒤에 숨겨진 동기입니다. 프로젝트에 새로 참여하는 사람은 과거의 어떤 결정에 대해 당황하거나, 혼란스러워하거나, 기뻐하거나, 분노할 수 있습니다. 그 근거나 결과를 이해하지 못한 채로, 이 사람에게는 단 두 가지 선택만이 있습니다:

1. **맹목적으로 그 결정을 받아들이는 것.**

   결정이 여전히 유효하다면 이런 대응은 괜찮을 수 있습니다. 하지만 상황이 변했고 결정을 실제로 재검토해야 한다면 좋지 않을 수 있습니다. 프로젝트에 이해 없이 받아들인 결정들이 너무 많이 쌓이면, 개발팀은 어떤 것도 변경하기를 두려워하게 되고 프로젝트는 자체 무게에 짓눌려 무너지게 됩니다.

2. **무작정 변경하기.**

   다시 말하지만, 결정을 되돌려야 하는 경우라면 이것이 괜찮을 수 있습니다. 반면에 동기나 결과를 이해하지 못한 채 결정을 변경하는 것은 그것을 깨닫지 못한 채 프로젝트의 전체적인 가치를 손상시킬 수 있습니다. (예를 들어, 그 결정이 아직 테스트되지 않은 비기능적 요구사항을 지원했을 수도 있습니다.)

맹목적인 수용이나 맹목적인 번복 모두 피하는 것이 좋습니다.

## 결정

우리는 "아키텍처적으로 중요한" 결정들에 대한 기록 모음을 유지할 것입니다: 구조, 비기능적 특성, 의존성, 인터페이스 또는 구축 기법에 영향을 미치는 결정들 말입니다.

아키텍처 결정 기록은 알렉산드리아 패턴과 유사한 형식의 짧은 텍스트 파일입니다. (결정 자체가 반드시 패턴은 아니지만, 힘의 균형을 맞추는 특성을 공유합니다.) 각 기록은 일련의 힘과 그러한 힘에 대응하는 단일 결정을 설명합니다. 결정이 여기서 핵심 요소이므로, 특정 힘들이 여러 ADR에 나타날 수 있다는 점에 주목하세요.

우리는 ADR을 프로젝트 저장소의 doc/arch/adr-NNN.md 경로에 보관할 것입니다.

마크다운이나 텍스타일과 같은 가벼운 텍스트 포맷팅 언어를 사용해야 합니다.

ADR은 순차적이고 단조적으로 번호가 매겨집니다. 번호는 재사용되지 않습니다.

결정이 번복되면, 기존 것을 유지하되 대체되었다고 표시할 것입니다. (그것이*결정이었다는*사실을 아는 것은 여전히 관련이 있지만,*더 이상*결정.)

우리는 각 문서를 쉽게 이해할 수 있도록 몇 개의 부분만으로 구성된 형식을 사용할 것입니다. 이 형식은 단지 몇 개의 부분만을 가지고 있습니다.

**제목**이러한 문서들은 짧은 명사구로 된 이름을 가집니다. 예를 들어, "ADR 1: Ruby on Rails 3.0.10에서의 배포" 또는 "ADR 9: 멀티테넌트 통합을 위한 LDAP"

**맥락**이 섹션은 기술적, 정치적, 사회적, 프로젝트 지역적 요소를 포함하여 작용하는 힘들을 설명합니다. 이러한 힘들은 아마도 긴장 관계에 있을 것이며, 그렇게 명시되어야 합니다. 이 섹션의 언어는 가치 중립적입니다. 단순히 사실을 설명하는 것입니다.

**결정**이 섹션은 이러한 힘들에 대한 우리의 대응을 설명합니다. 능동태를 사용하여 완전한 문장으로 서술됩니다. "우리는 …할 것이다"

**상태**결정은 프로젝트 이해관계자들이 아직 동의하지 않은 경우 "제안됨"으로 표시되거나, 동의가 이루어지면 "승인됨"으로 표시될 수 있습니다. 나중에 ADR이 결정을 변경하거나 뒤집는 경우, 대체 문서에 대한 참조와 함께 "폐기됨" 또는 "대체됨"으로 표시될 수 있습니다.

**결과**이 섹션은 결정을 적용한 후의 결과적 맥락을 설명합니다. 모든 결과가 여기에 나열되어야 하며, "긍정적인" 것들만이 아닙니다. 특정 결정은 긍정적, 부정적, 중립적 결과를 가질 수 있지만, 이 모든 것들이 향후 팀과 프로젝트에 영향을 미칩니다.

전체 문서는 한두 페이지 분량이어야 합니다. 우리는 각 ADR을 미래의 개발자와 나누는 대화인 것처럼 작성할 것입니다. 이를 위해서는 완전한 문장들이 단락으로 구성된 좋은 글쓰기 스타일이 필요합니다. 불릿 포인트는 시각적 스타일을 위해서만 허용되며, 문장 조각을 쓰는 핑계로 사용해서는 안 됩니다. (불릿은 사람을 죽입니다. 파워포인트 불릿도 마찬가지입니다.)

## 상태

승인됨.

## 결과

하나의 ADR은 특정 프로젝트에 대한 하나의 중요한 결정을 설명합니다. 이는 프로젝트의 나머지 부분이 어떻게 진행될지에 영향을 미치는 것이어야 합니다.

하나의 ADR의 결과는 후속 ADR들의 맥락이 될 가능성이 매우 높습니다. 이는 Alexander의 패턴 언어 개념과도 유사합니다: 대규모 응답이 소규모가 들어맞을 수 있는 공간을 만들어냅니다.

개발자와 프로젝트 이해관계자들은 시간이 지나면서 팀 구성이 변경되더라도 ADR을 볼 수 있습니다.

이전 결정들의 동기가 현재와 미래의 모든 사람들에게 보입니다. 아무도 "그들이 무슨 생각을 했던 걸까?"라고 머리를 긁적이며 이해하려 하지 않아도 되고, 기존 결정을 변경할 시점은 프로젝트 맥락의 변화로부터 명확해질 것입니다.ㄱ

## 경험 보고서

이 게시물이 ADR 자체와 같은 형식으로 작성되었다는 것을 눈치채셨을 것입니다. 우리는 8월 초부터 몇 개의 프로젝트에서 이 형식을 사용해 왔습니다. 전체적인 관점에서 보면 그리 긴 시간은 아니지만, 클라이언트와 개발자 모두로부터 받은 초기 피드백은 상당히 긍정적이었습니다. 그 기간 동안 6명에서 10명의 개발자가 ADR을 사용하는 프로젝트를 순환하며 참여했습니다. 그들 모두는 ADR을 읽음으로써 얻은 맥락의 정도에 대해 감사하다고 말했습니다.

ADR은 장기적인 의도를 포착하는 데 특히 유용했습니다. 현재 시스템을 안정화하고 있지만 그리 멀지 않은 미래에 더 큰 재설계를 고려하고 있는 여러 고객이 있습니다. 이러한 의도를 문서화함으로써 향후 변경 사항을 실수로 더 어렵게 만들지 않을 수 있습니다.

한 가지 잠재적인 반대 의견은 이러한 문서들을 코드와 함께 버전 관리에 보관하면 개발팀처럼 버전 관리에 익숙하지 않은 프로젝트 매니저, 클라이언트 이해관계자 및 기타 사람들이 접근하기 어려워진다는 것입니다. 실제로 우리 프로젝트는 거의 모두 GitHub 비공개 저장소에 있기 때문에 master의 최신 버전에 대한 링크를 교환할 수 있습니다. GitHub이 자동으로 마크다운 처리를 해주기 때문에 어떤 위키 페이지만큼이나 친숙하게 보입니다.

지금까지 ADR은 유용한 도구임이 입증되고 있어서, 계속 사용할 예정입니다.

## 더 읽어보기

아키텍처 결정의 [중요성](http://www.computer.org/portal/web/csdl/doi/10.1109/MS.2009.52)에 대해 논의해 주신 Philipe Kruchten에게 감사드립니다. 이에 대한 더 많은 내용이 다음에 있다고 들었습니다[소프트웨어 아키텍처 문서화](http://www.sei.cmu.edu/library/abstracts/books/0321552687.cfm)이 책은 제 독서 목록의 상위권에 있습니다.



# Documenting Architecture Decisions

[Michael Nygard](https://cognitect.com/authors/MichaelNygard.html) - November 15, 2011

[agility](https://cognitect.com/blog/tags?tag=agility) [architecture](https://cognitect.com/blog/tags?tag=architecture)

## Context

Architecture for agile projects has to be described and defined differently. Not all decisions will be made at once, nor will all of them be done when the project begins.

Agile methods are not opposed to documentation, only to valueless documentation. Documents that assist the team itself can have value, but only if they are kept up to date. Large documents are never kept up to date. Small, modular documents have at least a chance at being updated.

Nobody ever reads large documents, either. Most developers have been on at least one project where the specification document was larger (in bytes) than the total source code size. Those documents are too large to open, read, or update. Bite sized pieces are easier for for all stakeholders to consume.

One of the hardest things to track during the life of a project is the motivation behind certain decisions. A new person coming on to a project may be perplexed, baffled, delighted, or infuriated by some past decision. Without understanding the rationale or consequences, this person has only two choices:

1. **Blindly accept the decision.**

   This response may be OK, if the decision is still valid. It may not be good, however, if the context has changed and the decision should really be revisited. If the project accumulates too many decisions accepted without understanding, then the development team becomes afraid to change anything and the project collapses under its own weight.

2. **Blindly change it.**

   Again, this may be OK if the decision needs to be reversed. On the other hand, changing the decision without understanding its motivation or consequences could mean damaging the project's overall value without realizing it. (E.g., the decision supported a non-functional requirement that hasn't been tested yet.)

It's better to avoid either blind acceptance or blind reversal.

## Decision

We will keep a collection of records for "architecturally significant" decisions: those that affect the structure, non-functional characteristics, dependencies, interfaces, or construction techniques.

An architecture decision record is a short text file in a format similar to an Alexandrian pattern. (Though the decisions themselves are not necessarily patterns, they share the characteristic balancing of forces.) Each record describes a set of forces and a single decision in response to those forces. Note that the decision is the central piece here, so specific forces may appear in multiple ADRs.

We will keep ADRs in the project repository under doc/arch/adr-NNN.md

We should use a lightweight text formatting language like Markdown or Textile.

ADRs will be numbered sequentially and monotonically. Numbers will not be reused.

If a decision is reversed, we will keep the old one around, but mark it as superseded. (It's still relevant to know that it *was* the decision, but is *no longer* the decision.)

We will use a format with just a few parts, so each document is easy to digest. The format has just a few parts.

**Title** These documents have names that are short noun phrases. For example, "ADR 1: Deployment on Ruby on Rails 3.0.10" or "ADR 9: LDAP for Multitenant Integration"

**Context** This section describes the forces at play, including technological, political, social, and project local. These forces are probably in tension, and should be called out as such. The language in this section is value-neutral. It is simply describing facts.

**Decision** This section describes our response to these forces. It is stated in full sentences, with active voice. "We will …"

**Status** A decision may be "proposed" if the project stakeholders haven't agreed with it yet, or "accepted" once it is agreed. If a later ADR changes or reverses a decision, it may be marked as "deprecated" or "superseded" with a reference to its replacement.

**Consequences** This section describes the resulting context, after applying the decision. All consequences should be listed here, not just the "positive" ones. A particular decision may have positive, negative, and neutral consequences, but all of them affect the team and project in the future.

The whole document should be one or two pages long. We will write each ADR as if it is a conversation with a future developer. This requires good writing style, with full sentences organized into paragraphs. Bullets are acceptable only for visual style, not as an excuse for writing sentence fragments. (Bullets kill people, even PowerPoint bullets.)

## Status

Accepted.

## Consequences

One ADR describes one significant decision for a specific project. It should be something that has an effect on how the rest of the project will run.

The consequences of one ADR are very likely to become the context for subsequent ADRs. This is also similar to Alexander's idea of a pattern language: the large-scale responses create spaces for the smaller scale to fit into.

Developers and project stakeholders can see the ADRs, even as the team composition changes over time.

The motivation behind previous decisions is visible for everyone, present and future. Nobody is left scratching their heads to understand, "What were they thinking?" and the time to change old decisions will be clear from changes in the project's context.

------

## Experience Report

You may have noticed that this post is formatted like an ADR itself. We've been using this format on a few of our projects since early August. That's not a very long time in the global sense, but early feedback from both clients and developers has been quite positive. In that time, we've had six to ten developers rotate through projects using ADRs. All of them have stated that they appreciate the degree of context they received by reading them.

ADRs have been especially useful for capturing longer-term intentions. We have several clients who are stabilizing their current systems, but looking toward a larger rearchitecture in the not-too-distant future. By writing these intentions down, we don't inadvertently make those future changes harder.

One potential objection is that keeping these in version control with the code makes them less accessible for project managers, client stakeholders, and others who don't live in version control like the development team does. In practice, our projects almost all live in GitHub private repositories, so we can exchange links to the latest version in master. Since GitHub does markdown processing automatically, it looks just as friendly as any wiki page would.

So far, ADRs are proving to be a useful tool, so we'll keep using them.

## More Reading

Thanks to Philipe Kruchten for discussing the [importance of architecture decisions](http://www.computer.org/portal/web/csdl/doi/10.1109/MS.2009.52). I'm told there is more about them in [Documenting Software Architectures](http://www.sei.cmu.edu/library/abstracts/books/0321552687.cfm) which is near the top of my reading queue.