# 📜 프로젝트 설계 원칙 방법론 (Project Design Principles Methodology)

**작성일**: 2025-09-08  
**작성자**: 2호  
**목적**: 신규/리팩토링 프로젝트에서 모든 개발자가 지켜야 할 설계 원칙 수립 방법론  
**버전**: v1.0

---

## 🎯 핵심 철학: "매 작업마다 백지상태로 참여하는 에이전트들의 인식 통일"

### 문제점
- 에이전트(개발자)는 매 작업마다 새롭게 참여 (이전 컨텍스트 없음)
- 프로젝트 전체 원칙을 모른 채 부분적으로 구현
- 결과: 레고블럭들이 어긋나고, 위반사항 발생, 통합 실패

### 해결책: Phase 0 설계 원칙 수립
모든 프로젝트는 구현 전 **"프로젝트 헌법"**을 만들어야 함

---

## 📊 프로젝트 유형별 Phase 0 전략

### 🔄 리팩토링 프로젝트
```typescript
Phase 0-1: 현재 시스템 완전 분석
- 실제 요청 흐름 추적
- 각 레이어의 실제 책임 파악
- 문제점과 순환 참조 발견

Phase 0-2: 리팩토링 루트 발견  
- 현재 → 목표 변환 경로 매핑
- 단계별 의존성 분석
- 실패 시 롤백 지점 정의

Phase 0-3: 시스템 불변 규칙 도출
- 리팩토링 중 절대 바뀌면 안 되는 것들
- 클라이언트 인터페이스 계약
- 데이터 무결성 보장 규칙
```

### 🆕 신규 프로젝트
```typescript
Phase 0-1: 도메인 완전 분석
- 비즈니스 요구사항 상세 분석
- 성능/보안/가용성 제약조건
- 사용자 시나리오와 엣지 케이스

Phase 0-2: 아키텍처 설계 루트 발견
- 기술 스택 선택과 근거
- 아키텍처 패턴 결정 (Clean, Hexagonal, etc)
- 레이어별 책임 분리 전략

Phase 0-3: 프로젝트 설계 원칙 수립
- 모든 개발자가 지켜야 할 불변 규칙
- 코딩 표준과 품질 기준
- 성능/보안/확장성 원칙
```

---

## 📋 설계 원칙 문서 템플릿

### 신규 프로젝트용 템플릿
```markdown
# 📜 [프로젝트명] 설계 원칙 (Project Design Invariants)

**작성일**: YYYY-MM-DD
**프로젝트**: [프로젝트명]
**중요도**: 🔴 CRITICAL - 이 원칙 위반 시 프로젝트 실패

---

## 🏗️ 아키텍처 원칙 (Lines 15-65)

### 1. Clean Architecture 4-Layer 강제 (Lines 15-25)
- Presentation Layer: API/UI만 담당
- Application Layer: 비즈니스 흐름 조정
- Domain Layer: 핵심 비즈니스 로직
- Infrastructure Layer: 외부 시스템 연동

**위반 시 결과**: 테스트 불가능, 의존성 순환, 유지보수 불가

### 2. 의존성 역전 원칙 (Lines 27-35)
- 상위 레이어만 하위 레이어 의존
- Interface 기반 의존성 주입 필수
- 구체 클래스 직접 의존 금지

**위반 시 결과**: 단위 테스트 불가, 모듈 교체 불가

### 3. 단일 책임 원칙 (Lines 37-45)
- 하나의 클래스는 하나의 책임만
- 변경 이유가 두 개 이상이면 분리
- God Object 생성 절대 금지

**위반 시 결과**: 코드 복잡성 급증, 버그 확산

---

## 🔒 보안 원칙 (Lines 67-120)

### 1. 입력 검증 원칙 (Lines 67-78)
- 모든 외부 입력은 검증 필수
- Whitelist 방식 검증 적용
- 검증 실패 시 명확한 에러 응답

**구현 예시**:
```python
def validate_user_input(data: dict) -> ValidationResult:
    # Line 234-245 청사진 참조 필수!
    pass
```

### 2. 인증/인가 원칙 (Lines 80-95)
- JWT 토큰 기반 인증 통일
- Role-based 권한 관리
- 토큰 만료 시간 1시간 고정

**위반 시 결과**: 보안 취약점, 전체 시스템 위험

### 3. 민감정보 처리 (Lines 97-108)
- API 키/비밀번호 환경변수만
- 로그에 민감정보 노출 금지
- 암호화 알고리즘 AES-256 고정

**위반 시 결과**: 정보 유출, 컴플라이언스 위반

---

## ⚡ 성능 목표 (Lines 122-160)

### 1. 응답 시간 기준 (Lines 122-135)
- API 응답 시간 < 200ms (95 percentile)
- 데이터베이스 쿼리 < 50ms
- 외부 API 호출 타임아웃 5초

**측정 방법**: Prometheus + Grafana 모니터링

### 2. 동시성 목표 (Lines 137-148)
- 동시 사용자 1,000명 지원
- Connection Pool 최대 100개
- 메모리 사용량 < 2GB

**위반 시 결과**: 시스템 다운, 사용자 이탈

### 3. 가용성 목표 (Lines 150-160)
- 99.9% 가용성 (월 43분 다운타임)
- Circuit Breaker 패턴 필수
- Health Check 엔드포인트 필수

---

## 🔄 데이터 무결성 원칙 (Lines 162-210)

### 1. 트랜잭션 관리 (Lines 162-175)
- 모든 비즈니스 트랜잭션은 원자적
- 외부 API 호출은 트랜잭션 밖에서
- 보상 트랜잭션(Saga) 패턴 적용

**구현 예시**:
```python
@transactional
async def create_user(user_data: dict) -> User:
    # 청사진 Line 567-589 트랜잭션 패턴 필수!
    pass
```

### 2. 이벤트 기반 아키텍처 (Lines 177-190)
- 상태 변경은 Event 발행
- Event Sourcing 적용
- 이벤트 중복 처리 방지 (Idempotency)

### 3. 데이터 검증 (Lines 192-210)
- 비즈니스 규칙 Domain Layer에서 검증
- 데이터베이스 제약조건 활용
- 검증 실패 시 명확한 에러 메시지

---

## 📏 코딩 표준 (Lines 212-250)

### 1. 네이밍 규칙 (Lines 212-225)
- 클래스: PascalCase (UserService)
- 함수: snake_case (create_user)
- 상수: UPPER_SNAKE_CASE (MAX_RETRY_COUNT)
- 변수: camelCase (userName)

### 2. 코드 품질 기준 (Lines 227-240)
- 함수 최대 길이: 20줄
- 클래스 최대 길이: 200줄
- 순환복잡도(Cyclomatic) < 10
- 테스트 커버리지 > 90%

### 3. 문서화 규칙 (Lines 242-250)
- 모든 public 메서드 docstring 필수
- API 문서 자동 생성 (OpenAPI)
- README 업데이트 필수

**위반 시 결과**: 유지보수성 저하, 팀 협업 방해
```

---

## 🔗 체크리스트 연동 방법

### ✅ 올바른 참조 방법
```markdown
# 📋 체크리스트 - 사용자 인증 API 구현

## 🔴 필수 숙지 설계 원칙 (반드시 읽고 시작!)

### 1. 아키텍처 준수 필수
**참조**: [설계원칙.md Line 15-25] Clean Architecture 4-Layer
**이유**: 의존성 위반 시 테스트 불가능, 전체 구조 붕괴
**확인법**: 각 레이어가 상위만 의존하는지 import 검증

### 2. 보안 규칙 준수 필수  
**참조**: [설계원칙.md Line 80-95] JWT 인증 원칙
**이유**: 보안 취약점 발생 시 전체 시스템 위험
**확인법**: 토큰 만료시간 1시간, Role 기반 권한 체크

### 3. 성능 목표 달성 필수
**참조**: [설계원칙.md Line 122-135] API 응답시간 < 200ms
**이유**: SLA 위반 시 사용자 이탈, 비즈니스 손실
**확인법**: Load Test로 200ms 이내 확인

## 🎯 구현 세부사항
**청사진 참조**: [청사진.md Line 456-523] JWT 구현 패턴
**핵심 포인트**: 토큰 생성, 검증, 갱신 로직 정확히 구현
```

### ❌ 잘못된 참조 방법
```markdown
# 이렇게 하면 아무도 안 읽음!
- 설계 원칙을 준수하세요: [링크]
- 청사진을 참조하세요: [링크] 
- 보안에 주의하세요
```

---

## 💡 핵심 성공 요소

### 1. **컨텍스트 온전할 때 모든 것 정리**
- Phase 0에서 모든 원칙을 확정
- 나중에는 기억 못함 → 초기에 완벽히

### 2. **구체적 라인 번호 + 이유**
- 단순 링크 = 무시됨
- 라인 번호 + 왜 중요한지 = 읽힘

### 3. **에이전트 백지상태 가정**
- 매 작업마다 처음 참여한다고 가정
- 모든 컨텍스트를 체크리스트에 명시

### 4. **위반 시 결과 명시**
- 규칙을 지키지 않으면 어떻게 되는지
- 구체적 피해와 복구 비용 명시

---

## 🎯 적용 전략

### 리팩토링 프로젝트
1. 현재 시스템의 **실제 동작** 완전 분석
2. 목표 아키텍처로 가는 **안전한 경로** 매핑  
3. 경로상에서 **절대 바뀌면 안 되는 것들** 정의
4. 불변 규칙 기반으로 상세 청사진 작성

### 신규 프로젝트  
1. 비즈니스 도메인의 **핵심 제약조건** 분석
2. 기술적 아키텍처 **최적 설계 루트** 선택
3. 모든 개발자가 지켜야 할 **설계 원칙** 수립  
4. 설계 원칙 기반으로 상세 청사진 작성

---

## 🏆 최종 목표

**"매 작업마다 백지상태로 참여하는 모든 에이전트(개발자)가 동일한 원칙으로 일관된 품질의 레고블럭을 만들어서, 어긋남 없이 위반 없이 오류 없이 전체 프로젝트를 완성한다"**

이것이 Phase 0 설계 원칙 수립의 궁극적 목표입니다.

---

**Remember**: 
- 원칙 없는 구현 = 실패 확정
- 체크리스트의 구체적 참조 = 성공의 열쇠  
- 컨텍스트 온전할 때 모든 것 정리 = 프로젝트 성공